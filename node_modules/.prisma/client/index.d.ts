
/**
 * Client
**/

import * as runtime from '@prisma/client/runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model User
 * 
 */
export type User = $Result.DefaultSelection<Prisma.$UserPayload>
/**
 * Model AdminUser
 * 
 */
export type AdminUser = $Result.DefaultSelection<Prisma.$AdminUserPayload>
/**
 * Model AdminUserRole
 * 
 */
export type AdminUserRole = $Result.DefaultSelection<Prisma.$AdminUserRolePayload>
/**
 * Model Session
 * 
 */
export type Session = $Result.DefaultSelection<Prisma.$SessionPayload>
/**
 * Model PasswordResetToken
 * 
 */
export type PasswordResetToken = $Result.DefaultSelection<Prisma.$PasswordResetTokenPayload>
/**
 * Model Movie
 * 
 */
export type Movie = $Result.DefaultSelection<Prisma.$MoviePayload>
/**
 * Model MovieGenre
 * 
 */
export type MovieGenre = $Result.DefaultSelection<Prisma.$MovieGenrePayload>
/**
 * Model MovieLanguage
 * 
 */
export type MovieLanguage = $Result.DefaultSelection<Prisma.$MovieLanguagePayload>
/**
 * Model Auditorium
 * 
 */
export type Auditorium = $Result.DefaultSelection<Prisma.$AuditoriumPayload>
/**
 * Model Showtime
 * 
 */
export type Showtime = $Result.DefaultSelection<Prisma.$ShowtimePayload>
/**
 * Model ShowtimePricingTier
 * 
 */
export type ShowtimePricingTier = $Result.DefaultSelection<Prisma.$ShowtimePricingTierPayload>
/**
 * Model Booking
 * 
 */
export type Booking = $Result.DefaultSelection<Prisma.$BookingPayload>
/**
 * Model BookingTicket
 * 
 */
export type BookingTicket = $Result.DefaultSelection<Prisma.$BookingTicketPayload>
/**
 * Model BookingAudit
 * 
 */
export type BookingAudit = $Result.DefaultSelection<Prisma.$BookingAuditPayload>
/**
 * Model SettlementTransaction
 * 
 */
export type SettlementTransaction = $Result.DefaultSelection<Prisma.$SettlementTransactionPayload>
/**
 * Model NotificationSegment
 * 
 */
export type NotificationSegment = $Result.DefaultSelection<Prisma.$NotificationSegmentPayload>
/**
 * Model NotificationCampaign
 * 
 */
export type NotificationCampaign = $Result.DefaultSelection<Prisma.$NotificationCampaignPayload>
/**
 * Model PlatformSettings
 * 
 */
export type PlatformSettings = $Result.DefaultSelection<Prisma.$PlatformSettingsPayload>
/**
 * Model PaymentAudit
 * 
 */
export type PaymentAudit = $Result.DefaultSelection<Prisma.$PaymentAuditPayload>

/**
 * Enums
 */
export namespace $Enums {
  export const AdminStatus: {
  INVITED: 'INVITED',
  ACTIVE: 'ACTIVE',
  DISABLED: 'DISABLED'
};

export type AdminStatus = (typeof AdminStatus)[keyof typeof AdminStatus]


export const AdminRole: {
  OWNER: 'OWNER',
  FINANCE: 'FINANCE',
  CONTENT: 'CONTENT',
  OPERATIONS: 'OPERATIONS',
  SUPPORT: 'SUPPORT',
  MARKETING: 'MARKETING'
};

export type AdminRole = (typeof AdminRole)[keyof typeof AdminRole]


export const MovieStatus: {
  DRAFT: 'DRAFT',
  PUBLISHED: 'PUBLISHED'
};

export type MovieStatus = (typeof MovieStatus)[keyof typeof MovieStatus]


export const ShowtimeStatus: {
  SCHEDULED: 'SCHEDULED',
  ON_SALE: 'ON_SALE',
  COMPLETED: 'COMPLETED',
  CANCELLED: 'CANCELLED'
};

export type ShowtimeStatus = (typeof ShowtimeStatus)[keyof typeof ShowtimeStatus]


export const BookingStatus: {
  RESERVED: 'RESERVED',
  CONFIRMED: 'CONFIRMED',
  CANCELLED: 'CANCELLED',
  REFUNDED: 'REFUNDED'
};

export type BookingStatus = (typeof BookingStatus)[keyof typeof BookingStatus]


export const SettlementStatus: {
  PENDING: 'PENDING',
  PROCESSING: 'PROCESSING',
  COMPLETED: 'COMPLETED'
};

export type SettlementStatus = (typeof SettlementStatus)[keyof typeof SettlementStatus]


export const CampaignStatus: {
  DRAFT: 'DRAFT',
  SCHEDULED: 'SCHEDULED',
  IN_FLIGHT: 'IN_FLIGHT',
  COMPLETED: 'COMPLETED'
};

export type CampaignStatus = (typeof CampaignStatus)[keyof typeof CampaignStatus]

}

export type AdminStatus = $Enums.AdminStatus

export const AdminStatus: typeof $Enums.AdminStatus

export type AdminRole = $Enums.AdminRole

export const AdminRole: typeof $Enums.AdminRole

export type MovieStatus = $Enums.MovieStatus

export const MovieStatus: typeof $Enums.MovieStatus

export type ShowtimeStatus = $Enums.ShowtimeStatus

export const ShowtimeStatus: typeof $Enums.ShowtimeStatus

export type BookingStatus = $Enums.BookingStatus

export const BookingStatus: typeof $Enums.BookingStatus

export type SettlementStatus = $Enums.SettlementStatus

export const SettlementStatus: typeof $Enums.SettlementStatus

export type CampaignStatus = $Enums.CampaignStatus

export const CampaignStatus: typeof $Enums.CampaignStatus

/**
 * ##  Prisma Client ʲˢ
 * 
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Users
 * const users = await prisma.user.findMany()
 * ```
 *
 * 
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   * 
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Users
   * const users = await prisma.user.findMany()
   * ```
   *
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): void;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

  /**
   * Add a middleware
   * @deprecated since 4.16.0. For new code, prefer client extensions instead.
   * @see https://pris.ly/d/extensions
   */
  $use(cb: Prisma.Middleware): void

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb, ExtArgs>

      /**
   * `prisma.user`: Exposes CRUD operations for the **User** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users
    * const users = await prisma.user.findMany()
    * ```
    */
  get user(): Prisma.UserDelegate<ExtArgs>;

  /**
   * `prisma.adminUser`: Exposes CRUD operations for the **AdminUser** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AdminUsers
    * const adminUsers = await prisma.adminUser.findMany()
    * ```
    */
  get adminUser(): Prisma.AdminUserDelegate<ExtArgs>;

  /**
   * `prisma.adminUserRole`: Exposes CRUD operations for the **AdminUserRole** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AdminUserRoles
    * const adminUserRoles = await prisma.adminUserRole.findMany()
    * ```
    */
  get adminUserRole(): Prisma.AdminUserRoleDelegate<ExtArgs>;

  /**
   * `prisma.session`: Exposes CRUD operations for the **Session** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Sessions
    * const sessions = await prisma.session.findMany()
    * ```
    */
  get session(): Prisma.SessionDelegate<ExtArgs>;

  /**
   * `prisma.passwordResetToken`: Exposes CRUD operations for the **PasswordResetToken** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PasswordResetTokens
    * const passwordResetTokens = await prisma.passwordResetToken.findMany()
    * ```
    */
  get passwordResetToken(): Prisma.PasswordResetTokenDelegate<ExtArgs>;

  /**
   * `prisma.movie`: Exposes CRUD operations for the **Movie** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Movies
    * const movies = await prisma.movie.findMany()
    * ```
    */
  get movie(): Prisma.MovieDelegate<ExtArgs>;

  /**
   * `prisma.movieGenre`: Exposes CRUD operations for the **MovieGenre** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more MovieGenres
    * const movieGenres = await prisma.movieGenre.findMany()
    * ```
    */
  get movieGenre(): Prisma.MovieGenreDelegate<ExtArgs>;

  /**
   * `prisma.movieLanguage`: Exposes CRUD operations for the **MovieLanguage** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more MovieLanguages
    * const movieLanguages = await prisma.movieLanguage.findMany()
    * ```
    */
  get movieLanguage(): Prisma.MovieLanguageDelegate<ExtArgs>;

  /**
   * `prisma.auditorium`: Exposes CRUD operations for the **Auditorium** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Auditoriums
    * const auditoriums = await prisma.auditorium.findMany()
    * ```
    */
  get auditorium(): Prisma.AuditoriumDelegate<ExtArgs>;

  /**
   * `prisma.showtime`: Exposes CRUD operations for the **Showtime** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Showtimes
    * const showtimes = await prisma.showtime.findMany()
    * ```
    */
  get showtime(): Prisma.ShowtimeDelegate<ExtArgs>;

  /**
   * `prisma.showtimePricingTier`: Exposes CRUD operations for the **ShowtimePricingTier** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ShowtimePricingTiers
    * const showtimePricingTiers = await prisma.showtimePricingTier.findMany()
    * ```
    */
  get showtimePricingTier(): Prisma.ShowtimePricingTierDelegate<ExtArgs>;

  /**
   * `prisma.booking`: Exposes CRUD operations for the **Booking** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Bookings
    * const bookings = await prisma.booking.findMany()
    * ```
    */
  get booking(): Prisma.BookingDelegate<ExtArgs>;

  /**
   * `prisma.bookingTicket`: Exposes CRUD operations for the **BookingTicket** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more BookingTickets
    * const bookingTickets = await prisma.bookingTicket.findMany()
    * ```
    */
  get bookingTicket(): Prisma.BookingTicketDelegate<ExtArgs>;

  /**
   * `prisma.bookingAudit`: Exposes CRUD operations for the **BookingAudit** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more BookingAudits
    * const bookingAudits = await prisma.bookingAudit.findMany()
    * ```
    */
  get bookingAudit(): Prisma.BookingAuditDelegate<ExtArgs>;

  /**
   * `prisma.settlementTransaction`: Exposes CRUD operations for the **SettlementTransaction** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SettlementTransactions
    * const settlementTransactions = await prisma.settlementTransaction.findMany()
    * ```
    */
  get settlementTransaction(): Prisma.SettlementTransactionDelegate<ExtArgs>;

  /**
   * `prisma.notificationSegment`: Exposes CRUD operations for the **NotificationSegment** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more NotificationSegments
    * const notificationSegments = await prisma.notificationSegment.findMany()
    * ```
    */
  get notificationSegment(): Prisma.NotificationSegmentDelegate<ExtArgs>;

  /**
   * `prisma.notificationCampaign`: Exposes CRUD operations for the **NotificationCampaign** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more NotificationCampaigns
    * const notificationCampaigns = await prisma.notificationCampaign.findMany()
    * ```
    */
  get notificationCampaign(): Prisma.NotificationCampaignDelegate<ExtArgs>;

  /**
   * `prisma.platformSettings`: Exposes CRUD operations for the **PlatformSettings** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PlatformSettings
    * const platformSettings = await prisma.platformSettings.findMany()
    * ```
    */
  get platformSettings(): Prisma.PlatformSettingsDelegate<ExtArgs>;

  /**
   * `prisma.paymentAudit`: Exposes CRUD operations for the **PaymentAudit** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PaymentAudits
    * const paymentAudits = await prisma.paymentAudit.findMany()
    * ```
    */
  get paymentAudit(): Prisma.PaymentAuditDelegate<ExtArgs>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError
  export import NotFoundError = runtime.NotFoundError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics 
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 5.22.0
   * Query Engine version: 605197351a3c8bdd595af2d2a9bc3025bca48ea2
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion 

  /**
   * Utility Types
   */


  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? K : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    User: 'User',
    AdminUser: 'AdminUser',
    AdminUserRole: 'AdminUserRole',
    Session: 'Session',
    PasswordResetToken: 'PasswordResetToken',
    Movie: 'Movie',
    MovieGenre: 'MovieGenre',
    MovieLanguage: 'MovieLanguage',
    Auditorium: 'Auditorium',
    Showtime: 'Showtime',
    ShowtimePricingTier: 'ShowtimePricingTier',
    Booking: 'Booking',
    BookingTicket: 'BookingTicket',
    BookingAudit: 'BookingAudit',
    SettlementTransaction: 'SettlementTransaction',
    NotificationSegment: 'NotificationSegment',
    NotificationCampaign: 'NotificationCampaign',
    PlatformSettings: 'PlatformSettings',
    PaymentAudit: 'PaymentAudit'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  interface TypeMapCb extends $Utils.Fn<{extArgs: $Extensions.InternalArgs, clientOptions: PrismaClientOptions }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], this['params']['clientOptions']>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> = {
    meta: {
      modelProps: "user" | "adminUser" | "adminUserRole" | "session" | "passwordResetToken" | "movie" | "movieGenre" | "movieLanguage" | "auditorium" | "showtime" | "showtimePricingTier" | "booking" | "bookingTicket" | "bookingAudit" | "settlementTransaction" | "notificationSegment" | "notificationCampaign" | "platformSettings" | "paymentAudit"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      User: {
        payload: Prisma.$UserPayload<ExtArgs>
        fields: Prisma.UserFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findFirst: {
            args: Prisma.UserFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findMany: {
            args: Prisma.UserFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          create: {
            args: Prisma.UserCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          createMany: {
            args: Prisma.UserCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.UserDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          update: {
            args: Prisma.UserUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          deleteMany: {
            args: Prisma.UserDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.UserUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          aggregate: {
            args: Prisma.UserAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUser>
          }
          groupBy: {
            args: Prisma.UserGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserCountArgs<ExtArgs>
            result: $Utils.Optional<UserCountAggregateOutputType> | number
          }
        }
      }
      AdminUser: {
        payload: Prisma.$AdminUserPayload<ExtArgs>
        fields: Prisma.AdminUserFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AdminUserFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminUserPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AdminUserFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminUserPayload>
          }
          findFirst: {
            args: Prisma.AdminUserFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminUserPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AdminUserFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminUserPayload>
          }
          findMany: {
            args: Prisma.AdminUserFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminUserPayload>[]
          }
          create: {
            args: Prisma.AdminUserCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminUserPayload>
          }
          createMany: {
            args: Prisma.AdminUserCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.AdminUserDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminUserPayload>
          }
          update: {
            args: Prisma.AdminUserUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminUserPayload>
          }
          deleteMany: {
            args: Prisma.AdminUserDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AdminUserUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.AdminUserUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminUserPayload>
          }
          aggregate: {
            args: Prisma.AdminUserAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAdminUser>
          }
          groupBy: {
            args: Prisma.AdminUserGroupByArgs<ExtArgs>
            result: $Utils.Optional<AdminUserGroupByOutputType>[]
          }
          count: {
            args: Prisma.AdminUserCountArgs<ExtArgs>
            result: $Utils.Optional<AdminUserCountAggregateOutputType> | number
          }
        }
      }
      AdminUserRole: {
        payload: Prisma.$AdminUserRolePayload<ExtArgs>
        fields: Prisma.AdminUserRoleFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AdminUserRoleFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminUserRolePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AdminUserRoleFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminUserRolePayload>
          }
          findFirst: {
            args: Prisma.AdminUserRoleFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminUserRolePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AdminUserRoleFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminUserRolePayload>
          }
          findMany: {
            args: Prisma.AdminUserRoleFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminUserRolePayload>[]
          }
          create: {
            args: Prisma.AdminUserRoleCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminUserRolePayload>
          }
          createMany: {
            args: Prisma.AdminUserRoleCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.AdminUserRoleDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminUserRolePayload>
          }
          update: {
            args: Prisma.AdminUserRoleUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminUserRolePayload>
          }
          deleteMany: {
            args: Prisma.AdminUserRoleDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AdminUserRoleUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.AdminUserRoleUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminUserRolePayload>
          }
          aggregate: {
            args: Prisma.AdminUserRoleAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAdminUserRole>
          }
          groupBy: {
            args: Prisma.AdminUserRoleGroupByArgs<ExtArgs>
            result: $Utils.Optional<AdminUserRoleGroupByOutputType>[]
          }
          count: {
            args: Prisma.AdminUserRoleCountArgs<ExtArgs>
            result: $Utils.Optional<AdminUserRoleCountAggregateOutputType> | number
          }
        }
      }
      Session: {
        payload: Prisma.$SessionPayload<ExtArgs>
        fields: Prisma.SessionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SessionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SessionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          findFirst: {
            args: Prisma.SessionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SessionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          findMany: {
            args: Prisma.SessionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>[]
          }
          create: {
            args: Prisma.SessionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          createMany: {
            args: Prisma.SessionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.SessionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          update: {
            args: Prisma.SessionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          deleteMany: {
            args: Prisma.SessionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SessionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.SessionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          aggregate: {
            args: Prisma.SessionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSession>
          }
          groupBy: {
            args: Prisma.SessionGroupByArgs<ExtArgs>
            result: $Utils.Optional<SessionGroupByOutputType>[]
          }
          count: {
            args: Prisma.SessionCountArgs<ExtArgs>
            result: $Utils.Optional<SessionCountAggregateOutputType> | number
          }
        }
      }
      PasswordResetToken: {
        payload: Prisma.$PasswordResetTokenPayload<ExtArgs>
        fields: Prisma.PasswordResetTokenFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PasswordResetTokenFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PasswordResetTokenPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PasswordResetTokenFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PasswordResetTokenPayload>
          }
          findFirst: {
            args: Prisma.PasswordResetTokenFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PasswordResetTokenPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PasswordResetTokenFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PasswordResetTokenPayload>
          }
          findMany: {
            args: Prisma.PasswordResetTokenFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PasswordResetTokenPayload>[]
          }
          create: {
            args: Prisma.PasswordResetTokenCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PasswordResetTokenPayload>
          }
          createMany: {
            args: Prisma.PasswordResetTokenCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.PasswordResetTokenDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PasswordResetTokenPayload>
          }
          update: {
            args: Prisma.PasswordResetTokenUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PasswordResetTokenPayload>
          }
          deleteMany: {
            args: Prisma.PasswordResetTokenDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PasswordResetTokenUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.PasswordResetTokenUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PasswordResetTokenPayload>
          }
          aggregate: {
            args: Prisma.PasswordResetTokenAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePasswordResetToken>
          }
          groupBy: {
            args: Prisma.PasswordResetTokenGroupByArgs<ExtArgs>
            result: $Utils.Optional<PasswordResetTokenGroupByOutputType>[]
          }
          count: {
            args: Prisma.PasswordResetTokenCountArgs<ExtArgs>
            result: $Utils.Optional<PasswordResetTokenCountAggregateOutputType> | number
          }
        }
      }
      Movie: {
        payload: Prisma.$MoviePayload<ExtArgs>
        fields: Prisma.MovieFieldRefs
        operations: {
          findUnique: {
            args: Prisma.MovieFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MoviePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.MovieFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MoviePayload>
          }
          findFirst: {
            args: Prisma.MovieFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MoviePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.MovieFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MoviePayload>
          }
          findMany: {
            args: Prisma.MovieFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MoviePayload>[]
          }
          create: {
            args: Prisma.MovieCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MoviePayload>
          }
          createMany: {
            args: Prisma.MovieCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.MovieDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MoviePayload>
          }
          update: {
            args: Prisma.MovieUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MoviePayload>
          }
          deleteMany: {
            args: Prisma.MovieDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.MovieUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.MovieUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MoviePayload>
          }
          aggregate: {
            args: Prisma.MovieAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMovie>
          }
          groupBy: {
            args: Prisma.MovieGroupByArgs<ExtArgs>
            result: $Utils.Optional<MovieGroupByOutputType>[]
          }
          count: {
            args: Prisma.MovieCountArgs<ExtArgs>
            result: $Utils.Optional<MovieCountAggregateOutputType> | number
          }
        }
      }
      MovieGenre: {
        payload: Prisma.$MovieGenrePayload<ExtArgs>
        fields: Prisma.MovieGenreFieldRefs
        operations: {
          findUnique: {
            args: Prisma.MovieGenreFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MovieGenrePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.MovieGenreFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MovieGenrePayload>
          }
          findFirst: {
            args: Prisma.MovieGenreFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MovieGenrePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.MovieGenreFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MovieGenrePayload>
          }
          findMany: {
            args: Prisma.MovieGenreFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MovieGenrePayload>[]
          }
          create: {
            args: Prisma.MovieGenreCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MovieGenrePayload>
          }
          createMany: {
            args: Prisma.MovieGenreCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.MovieGenreDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MovieGenrePayload>
          }
          update: {
            args: Prisma.MovieGenreUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MovieGenrePayload>
          }
          deleteMany: {
            args: Prisma.MovieGenreDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.MovieGenreUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.MovieGenreUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MovieGenrePayload>
          }
          aggregate: {
            args: Prisma.MovieGenreAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMovieGenre>
          }
          groupBy: {
            args: Prisma.MovieGenreGroupByArgs<ExtArgs>
            result: $Utils.Optional<MovieGenreGroupByOutputType>[]
          }
          count: {
            args: Prisma.MovieGenreCountArgs<ExtArgs>
            result: $Utils.Optional<MovieGenreCountAggregateOutputType> | number
          }
        }
      }
      MovieLanguage: {
        payload: Prisma.$MovieLanguagePayload<ExtArgs>
        fields: Prisma.MovieLanguageFieldRefs
        operations: {
          findUnique: {
            args: Prisma.MovieLanguageFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MovieLanguagePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.MovieLanguageFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MovieLanguagePayload>
          }
          findFirst: {
            args: Prisma.MovieLanguageFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MovieLanguagePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.MovieLanguageFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MovieLanguagePayload>
          }
          findMany: {
            args: Prisma.MovieLanguageFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MovieLanguagePayload>[]
          }
          create: {
            args: Prisma.MovieLanguageCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MovieLanguagePayload>
          }
          createMany: {
            args: Prisma.MovieLanguageCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.MovieLanguageDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MovieLanguagePayload>
          }
          update: {
            args: Prisma.MovieLanguageUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MovieLanguagePayload>
          }
          deleteMany: {
            args: Prisma.MovieLanguageDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.MovieLanguageUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.MovieLanguageUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MovieLanguagePayload>
          }
          aggregate: {
            args: Prisma.MovieLanguageAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMovieLanguage>
          }
          groupBy: {
            args: Prisma.MovieLanguageGroupByArgs<ExtArgs>
            result: $Utils.Optional<MovieLanguageGroupByOutputType>[]
          }
          count: {
            args: Prisma.MovieLanguageCountArgs<ExtArgs>
            result: $Utils.Optional<MovieLanguageCountAggregateOutputType> | number
          }
        }
      }
      Auditorium: {
        payload: Prisma.$AuditoriumPayload<ExtArgs>
        fields: Prisma.AuditoriumFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AuditoriumFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditoriumPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AuditoriumFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditoriumPayload>
          }
          findFirst: {
            args: Prisma.AuditoriumFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditoriumPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AuditoriumFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditoriumPayload>
          }
          findMany: {
            args: Prisma.AuditoriumFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditoriumPayload>[]
          }
          create: {
            args: Prisma.AuditoriumCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditoriumPayload>
          }
          createMany: {
            args: Prisma.AuditoriumCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.AuditoriumDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditoriumPayload>
          }
          update: {
            args: Prisma.AuditoriumUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditoriumPayload>
          }
          deleteMany: {
            args: Prisma.AuditoriumDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AuditoriumUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.AuditoriumUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditoriumPayload>
          }
          aggregate: {
            args: Prisma.AuditoriumAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAuditorium>
          }
          groupBy: {
            args: Prisma.AuditoriumGroupByArgs<ExtArgs>
            result: $Utils.Optional<AuditoriumGroupByOutputType>[]
          }
          count: {
            args: Prisma.AuditoriumCountArgs<ExtArgs>
            result: $Utils.Optional<AuditoriumCountAggregateOutputType> | number
          }
        }
      }
      Showtime: {
        payload: Prisma.$ShowtimePayload<ExtArgs>
        fields: Prisma.ShowtimeFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ShowtimeFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ShowtimePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ShowtimeFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ShowtimePayload>
          }
          findFirst: {
            args: Prisma.ShowtimeFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ShowtimePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ShowtimeFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ShowtimePayload>
          }
          findMany: {
            args: Prisma.ShowtimeFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ShowtimePayload>[]
          }
          create: {
            args: Prisma.ShowtimeCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ShowtimePayload>
          }
          createMany: {
            args: Prisma.ShowtimeCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.ShowtimeDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ShowtimePayload>
          }
          update: {
            args: Prisma.ShowtimeUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ShowtimePayload>
          }
          deleteMany: {
            args: Prisma.ShowtimeDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ShowtimeUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ShowtimeUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ShowtimePayload>
          }
          aggregate: {
            args: Prisma.ShowtimeAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateShowtime>
          }
          groupBy: {
            args: Prisma.ShowtimeGroupByArgs<ExtArgs>
            result: $Utils.Optional<ShowtimeGroupByOutputType>[]
          }
          count: {
            args: Prisma.ShowtimeCountArgs<ExtArgs>
            result: $Utils.Optional<ShowtimeCountAggregateOutputType> | number
          }
        }
      }
      ShowtimePricingTier: {
        payload: Prisma.$ShowtimePricingTierPayload<ExtArgs>
        fields: Prisma.ShowtimePricingTierFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ShowtimePricingTierFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ShowtimePricingTierPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ShowtimePricingTierFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ShowtimePricingTierPayload>
          }
          findFirst: {
            args: Prisma.ShowtimePricingTierFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ShowtimePricingTierPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ShowtimePricingTierFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ShowtimePricingTierPayload>
          }
          findMany: {
            args: Prisma.ShowtimePricingTierFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ShowtimePricingTierPayload>[]
          }
          create: {
            args: Prisma.ShowtimePricingTierCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ShowtimePricingTierPayload>
          }
          createMany: {
            args: Prisma.ShowtimePricingTierCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.ShowtimePricingTierDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ShowtimePricingTierPayload>
          }
          update: {
            args: Prisma.ShowtimePricingTierUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ShowtimePricingTierPayload>
          }
          deleteMany: {
            args: Prisma.ShowtimePricingTierDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ShowtimePricingTierUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ShowtimePricingTierUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ShowtimePricingTierPayload>
          }
          aggregate: {
            args: Prisma.ShowtimePricingTierAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateShowtimePricingTier>
          }
          groupBy: {
            args: Prisma.ShowtimePricingTierGroupByArgs<ExtArgs>
            result: $Utils.Optional<ShowtimePricingTierGroupByOutputType>[]
          }
          count: {
            args: Prisma.ShowtimePricingTierCountArgs<ExtArgs>
            result: $Utils.Optional<ShowtimePricingTierCountAggregateOutputType> | number
          }
        }
      }
      Booking: {
        payload: Prisma.$BookingPayload<ExtArgs>
        fields: Prisma.BookingFieldRefs
        operations: {
          findUnique: {
            args: Prisma.BookingFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookingPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.BookingFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookingPayload>
          }
          findFirst: {
            args: Prisma.BookingFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookingPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.BookingFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookingPayload>
          }
          findMany: {
            args: Prisma.BookingFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookingPayload>[]
          }
          create: {
            args: Prisma.BookingCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookingPayload>
          }
          createMany: {
            args: Prisma.BookingCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.BookingDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookingPayload>
          }
          update: {
            args: Prisma.BookingUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookingPayload>
          }
          deleteMany: {
            args: Prisma.BookingDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.BookingUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.BookingUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookingPayload>
          }
          aggregate: {
            args: Prisma.BookingAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateBooking>
          }
          groupBy: {
            args: Prisma.BookingGroupByArgs<ExtArgs>
            result: $Utils.Optional<BookingGroupByOutputType>[]
          }
          count: {
            args: Prisma.BookingCountArgs<ExtArgs>
            result: $Utils.Optional<BookingCountAggregateOutputType> | number
          }
        }
      }
      BookingTicket: {
        payload: Prisma.$BookingTicketPayload<ExtArgs>
        fields: Prisma.BookingTicketFieldRefs
        operations: {
          findUnique: {
            args: Prisma.BookingTicketFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookingTicketPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.BookingTicketFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookingTicketPayload>
          }
          findFirst: {
            args: Prisma.BookingTicketFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookingTicketPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.BookingTicketFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookingTicketPayload>
          }
          findMany: {
            args: Prisma.BookingTicketFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookingTicketPayload>[]
          }
          create: {
            args: Prisma.BookingTicketCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookingTicketPayload>
          }
          createMany: {
            args: Prisma.BookingTicketCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.BookingTicketDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookingTicketPayload>
          }
          update: {
            args: Prisma.BookingTicketUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookingTicketPayload>
          }
          deleteMany: {
            args: Prisma.BookingTicketDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.BookingTicketUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.BookingTicketUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookingTicketPayload>
          }
          aggregate: {
            args: Prisma.BookingTicketAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateBookingTicket>
          }
          groupBy: {
            args: Prisma.BookingTicketGroupByArgs<ExtArgs>
            result: $Utils.Optional<BookingTicketGroupByOutputType>[]
          }
          count: {
            args: Prisma.BookingTicketCountArgs<ExtArgs>
            result: $Utils.Optional<BookingTicketCountAggregateOutputType> | number
          }
        }
      }
      BookingAudit: {
        payload: Prisma.$BookingAuditPayload<ExtArgs>
        fields: Prisma.BookingAuditFieldRefs
        operations: {
          findUnique: {
            args: Prisma.BookingAuditFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookingAuditPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.BookingAuditFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookingAuditPayload>
          }
          findFirst: {
            args: Prisma.BookingAuditFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookingAuditPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.BookingAuditFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookingAuditPayload>
          }
          findMany: {
            args: Prisma.BookingAuditFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookingAuditPayload>[]
          }
          create: {
            args: Prisma.BookingAuditCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookingAuditPayload>
          }
          createMany: {
            args: Prisma.BookingAuditCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.BookingAuditDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookingAuditPayload>
          }
          update: {
            args: Prisma.BookingAuditUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookingAuditPayload>
          }
          deleteMany: {
            args: Prisma.BookingAuditDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.BookingAuditUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.BookingAuditUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookingAuditPayload>
          }
          aggregate: {
            args: Prisma.BookingAuditAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateBookingAudit>
          }
          groupBy: {
            args: Prisma.BookingAuditGroupByArgs<ExtArgs>
            result: $Utils.Optional<BookingAuditGroupByOutputType>[]
          }
          count: {
            args: Prisma.BookingAuditCountArgs<ExtArgs>
            result: $Utils.Optional<BookingAuditCountAggregateOutputType> | number
          }
        }
      }
      SettlementTransaction: {
        payload: Prisma.$SettlementTransactionPayload<ExtArgs>
        fields: Prisma.SettlementTransactionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SettlementTransactionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SettlementTransactionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SettlementTransactionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SettlementTransactionPayload>
          }
          findFirst: {
            args: Prisma.SettlementTransactionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SettlementTransactionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SettlementTransactionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SettlementTransactionPayload>
          }
          findMany: {
            args: Prisma.SettlementTransactionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SettlementTransactionPayload>[]
          }
          create: {
            args: Prisma.SettlementTransactionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SettlementTransactionPayload>
          }
          createMany: {
            args: Prisma.SettlementTransactionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.SettlementTransactionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SettlementTransactionPayload>
          }
          update: {
            args: Prisma.SettlementTransactionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SettlementTransactionPayload>
          }
          deleteMany: {
            args: Prisma.SettlementTransactionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SettlementTransactionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.SettlementTransactionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SettlementTransactionPayload>
          }
          aggregate: {
            args: Prisma.SettlementTransactionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSettlementTransaction>
          }
          groupBy: {
            args: Prisma.SettlementTransactionGroupByArgs<ExtArgs>
            result: $Utils.Optional<SettlementTransactionGroupByOutputType>[]
          }
          count: {
            args: Prisma.SettlementTransactionCountArgs<ExtArgs>
            result: $Utils.Optional<SettlementTransactionCountAggregateOutputType> | number
          }
        }
      }
      NotificationSegment: {
        payload: Prisma.$NotificationSegmentPayload<ExtArgs>
        fields: Prisma.NotificationSegmentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.NotificationSegmentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationSegmentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.NotificationSegmentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationSegmentPayload>
          }
          findFirst: {
            args: Prisma.NotificationSegmentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationSegmentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.NotificationSegmentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationSegmentPayload>
          }
          findMany: {
            args: Prisma.NotificationSegmentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationSegmentPayload>[]
          }
          create: {
            args: Prisma.NotificationSegmentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationSegmentPayload>
          }
          createMany: {
            args: Prisma.NotificationSegmentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.NotificationSegmentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationSegmentPayload>
          }
          update: {
            args: Prisma.NotificationSegmentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationSegmentPayload>
          }
          deleteMany: {
            args: Prisma.NotificationSegmentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.NotificationSegmentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.NotificationSegmentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationSegmentPayload>
          }
          aggregate: {
            args: Prisma.NotificationSegmentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateNotificationSegment>
          }
          groupBy: {
            args: Prisma.NotificationSegmentGroupByArgs<ExtArgs>
            result: $Utils.Optional<NotificationSegmentGroupByOutputType>[]
          }
          count: {
            args: Prisma.NotificationSegmentCountArgs<ExtArgs>
            result: $Utils.Optional<NotificationSegmentCountAggregateOutputType> | number
          }
        }
      }
      NotificationCampaign: {
        payload: Prisma.$NotificationCampaignPayload<ExtArgs>
        fields: Prisma.NotificationCampaignFieldRefs
        operations: {
          findUnique: {
            args: Prisma.NotificationCampaignFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationCampaignPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.NotificationCampaignFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationCampaignPayload>
          }
          findFirst: {
            args: Prisma.NotificationCampaignFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationCampaignPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.NotificationCampaignFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationCampaignPayload>
          }
          findMany: {
            args: Prisma.NotificationCampaignFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationCampaignPayload>[]
          }
          create: {
            args: Prisma.NotificationCampaignCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationCampaignPayload>
          }
          createMany: {
            args: Prisma.NotificationCampaignCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.NotificationCampaignDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationCampaignPayload>
          }
          update: {
            args: Prisma.NotificationCampaignUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationCampaignPayload>
          }
          deleteMany: {
            args: Prisma.NotificationCampaignDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.NotificationCampaignUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.NotificationCampaignUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationCampaignPayload>
          }
          aggregate: {
            args: Prisma.NotificationCampaignAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateNotificationCampaign>
          }
          groupBy: {
            args: Prisma.NotificationCampaignGroupByArgs<ExtArgs>
            result: $Utils.Optional<NotificationCampaignGroupByOutputType>[]
          }
          count: {
            args: Prisma.NotificationCampaignCountArgs<ExtArgs>
            result: $Utils.Optional<NotificationCampaignCountAggregateOutputType> | number
          }
        }
      }
      PlatformSettings: {
        payload: Prisma.$PlatformSettingsPayload<ExtArgs>
        fields: Prisma.PlatformSettingsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PlatformSettingsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlatformSettingsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PlatformSettingsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlatformSettingsPayload>
          }
          findFirst: {
            args: Prisma.PlatformSettingsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlatformSettingsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PlatformSettingsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlatformSettingsPayload>
          }
          findMany: {
            args: Prisma.PlatformSettingsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlatformSettingsPayload>[]
          }
          create: {
            args: Prisma.PlatformSettingsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlatformSettingsPayload>
          }
          createMany: {
            args: Prisma.PlatformSettingsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.PlatformSettingsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlatformSettingsPayload>
          }
          update: {
            args: Prisma.PlatformSettingsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlatformSettingsPayload>
          }
          deleteMany: {
            args: Prisma.PlatformSettingsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PlatformSettingsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.PlatformSettingsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlatformSettingsPayload>
          }
          aggregate: {
            args: Prisma.PlatformSettingsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePlatformSettings>
          }
          groupBy: {
            args: Prisma.PlatformSettingsGroupByArgs<ExtArgs>
            result: $Utils.Optional<PlatformSettingsGroupByOutputType>[]
          }
          count: {
            args: Prisma.PlatformSettingsCountArgs<ExtArgs>
            result: $Utils.Optional<PlatformSettingsCountAggregateOutputType> | number
          }
        }
      }
      PaymentAudit: {
        payload: Prisma.$PaymentAuditPayload<ExtArgs>
        fields: Prisma.PaymentAuditFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PaymentAuditFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentAuditPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PaymentAuditFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentAuditPayload>
          }
          findFirst: {
            args: Prisma.PaymentAuditFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentAuditPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PaymentAuditFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentAuditPayload>
          }
          findMany: {
            args: Prisma.PaymentAuditFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentAuditPayload>[]
          }
          create: {
            args: Prisma.PaymentAuditCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentAuditPayload>
          }
          createMany: {
            args: Prisma.PaymentAuditCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.PaymentAuditDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentAuditPayload>
          }
          update: {
            args: Prisma.PaymentAuditUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentAuditPayload>
          }
          deleteMany: {
            args: Prisma.PaymentAuditDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PaymentAuditUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.PaymentAuditUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentAuditPayload>
          }
          aggregate: {
            args: Prisma.PaymentAuditAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePaymentAudit>
          }
          groupBy: {
            args: Prisma.PaymentAuditGroupByArgs<ExtArgs>
            result: $Utils.Optional<PaymentAuditGroupByOutputType>[]
          }
          count: {
            args: Prisma.PaymentAuditCountArgs<ExtArgs>
            result: $Utils.Optional<PaymentAuditCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *   { emit: 'stdout', level: 'query' },
     *   { emit: 'stdout', level: 'info' },
     *   { emit: 'stdout', level: 'warn' }
     *   { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
  }


  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  /**
   * These options are being passed into the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => $Utils.JsPromise<T>,
  ) => $Utils.JsPromise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type UserCountOutputType
   */

  export type UserCountOutputType = {
    sessions: number
    bookings: number
    passwordResetTokens: number
  }

  export type UserCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    sessions?: boolean | UserCountOutputTypeCountSessionsArgs
    bookings?: boolean | UserCountOutputTypeCountBookingsArgs
    passwordResetTokens?: boolean | UserCountOutputTypeCountPasswordResetTokensArgs
  }

  // Custom InputTypes
  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCountOutputType
     */
    select?: UserCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountSessionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SessionWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountBookingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BookingWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountPasswordResetTokensArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PasswordResetTokenWhereInput
  }


  /**
   * Count Type AdminUserCountOutputType
   */

  export type AdminUserCountOutputType = {
    roles: number
  }

  export type AdminUserCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    roles?: boolean | AdminUserCountOutputTypeCountRolesArgs
  }

  // Custom InputTypes
  /**
   * AdminUserCountOutputType without action
   */
  export type AdminUserCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminUserCountOutputType
     */
    select?: AdminUserCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * AdminUserCountOutputType without action
   */
  export type AdminUserCountOutputTypeCountRolesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AdminUserRoleWhereInput
  }


  /**
   * Count Type MovieCountOutputType
   */

  export type MovieCountOutputType = {
    genres: number
    languages: number
    showtimes: number
  }

  export type MovieCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    genres?: boolean | MovieCountOutputTypeCountGenresArgs
    languages?: boolean | MovieCountOutputTypeCountLanguagesArgs
    showtimes?: boolean | MovieCountOutputTypeCountShowtimesArgs
  }

  // Custom InputTypes
  /**
   * MovieCountOutputType without action
   */
  export type MovieCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MovieCountOutputType
     */
    select?: MovieCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * MovieCountOutputType without action
   */
  export type MovieCountOutputTypeCountGenresArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MovieGenreWhereInput
  }

  /**
   * MovieCountOutputType without action
   */
  export type MovieCountOutputTypeCountLanguagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MovieLanguageWhereInput
  }

  /**
   * MovieCountOutputType without action
   */
  export type MovieCountOutputTypeCountShowtimesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ShowtimeWhereInput
  }


  /**
   * Count Type AuditoriumCountOutputType
   */

  export type AuditoriumCountOutputType = {
    showtimes: number
  }

  export type AuditoriumCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    showtimes?: boolean | AuditoriumCountOutputTypeCountShowtimesArgs
  }

  // Custom InputTypes
  /**
   * AuditoriumCountOutputType without action
   */
  export type AuditoriumCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditoriumCountOutputType
     */
    select?: AuditoriumCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * AuditoriumCountOutputType without action
   */
  export type AuditoriumCountOutputTypeCountShowtimesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ShowtimeWhereInput
  }


  /**
   * Count Type ShowtimeCountOutputType
   */

  export type ShowtimeCountOutputType = {
    pricingTiers: number
    bookings: number
  }

  export type ShowtimeCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    pricingTiers?: boolean | ShowtimeCountOutputTypeCountPricingTiersArgs
    bookings?: boolean | ShowtimeCountOutputTypeCountBookingsArgs
  }

  // Custom InputTypes
  /**
   * ShowtimeCountOutputType without action
   */
  export type ShowtimeCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ShowtimeCountOutputType
     */
    select?: ShowtimeCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ShowtimeCountOutputType without action
   */
  export type ShowtimeCountOutputTypeCountPricingTiersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ShowtimePricingTierWhereInput
  }

  /**
   * ShowtimeCountOutputType without action
   */
  export type ShowtimeCountOutputTypeCountBookingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BookingWhereInput
  }


  /**
   * Count Type BookingCountOutputType
   */

  export type BookingCountOutputType = {
    tickets: number
    auditLog: number
    settlements: number
  }

  export type BookingCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tickets?: boolean | BookingCountOutputTypeCountTicketsArgs
    auditLog?: boolean | BookingCountOutputTypeCountAuditLogArgs
    settlements?: boolean | BookingCountOutputTypeCountSettlementsArgs
  }

  // Custom InputTypes
  /**
   * BookingCountOutputType without action
   */
  export type BookingCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BookingCountOutputType
     */
    select?: BookingCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * BookingCountOutputType without action
   */
  export type BookingCountOutputTypeCountTicketsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BookingTicketWhereInput
  }

  /**
   * BookingCountOutputType without action
   */
  export type BookingCountOutputTypeCountAuditLogArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BookingAuditWhereInput
  }

  /**
   * BookingCountOutputType without action
   */
  export type BookingCountOutputTypeCountSettlementsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SettlementTransactionWhereInput
  }


  /**
   * Count Type NotificationSegmentCountOutputType
   */

  export type NotificationSegmentCountOutputType = {
    campaigns: number
  }

  export type NotificationSegmentCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    campaigns?: boolean | NotificationSegmentCountOutputTypeCountCampaignsArgs
  }

  // Custom InputTypes
  /**
   * NotificationSegmentCountOutputType without action
   */
  export type NotificationSegmentCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationSegmentCountOutputType
     */
    select?: NotificationSegmentCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * NotificationSegmentCountOutputType without action
   */
  export type NotificationSegmentCountOutputTypeCountCampaignsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NotificationCampaignWhereInput
  }


  /**
   * Models
   */

  /**
   * Model User
   */

  export type AggregateUser = {
    _count: UserCountAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  export type UserMinAggregateOutputType = {
    id: string | null
    email: string | null
    passwordHash: string | null
    displayName: string | null
    avatarUrl: string | null
    phoneNumber: string | null
    isAdmin: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserMaxAggregateOutputType = {
    id: string | null
    email: string | null
    passwordHash: string | null
    displayName: string | null
    avatarUrl: string | null
    phoneNumber: string | null
    isAdmin: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserCountAggregateOutputType = {
    id: number
    email: number
    passwordHash: number
    displayName: number
    avatarUrl: number
    phoneNumber: number
    isAdmin: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type UserMinAggregateInputType = {
    id?: true
    email?: true
    passwordHash?: true
    displayName?: true
    avatarUrl?: true
    phoneNumber?: true
    isAdmin?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserMaxAggregateInputType = {
    id?: true
    email?: true
    passwordHash?: true
    displayName?: true
    avatarUrl?: true
    phoneNumber?: true
    isAdmin?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserCountAggregateInputType = {
    id?: true
    email?: true
    passwordHash?: true
    displayName?: true
    avatarUrl?: true
    phoneNumber?: true
    isAdmin?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type UserAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which User to aggregate.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Users
    **/
    _count?: true | UserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserMaxAggregateInputType
  }

  export type GetUserAggregateType<T extends UserAggregateArgs> = {
        [P in keyof T & keyof AggregateUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUser[P]>
      : GetScalarType<T[P], AggregateUser[P]>
  }




  export type UserGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
    orderBy?: UserOrderByWithAggregationInput | UserOrderByWithAggregationInput[]
    by: UserScalarFieldEnum[] | UserScalarFieldEnum
    having?: UserScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserCountAggregateInputType | true
    _min?: UserMinAggregateInputType
    _max?: UserMaxAggregateInputType
  }

  export type UserGroupByOutputType = {
    id: string
    email: string
    passwordHash: string
    displayName: string
    avatarUrl: string | null
    phoneNumber: string | null
    isAdmin: boolean
    createdAt: Date
    updatedAt: Date
    _count: UserCountAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  type GetUserGroupByPayload<T extends UserGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserGroupByOutputType[P]>
            : GetScalarType<T[P], UserGroupByOutputType[P]>
        }
      >
    >


  export type UserSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    passwordHash?: boolean
    displayName?: boolean
    avatarUrl?: boolean
    phoneNumber?: boolean
    isAdmin?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    adminProfile?: boolean | User$adminProfileArgs<ExtArgs>
    sessions?: boolean | User$sessionsArgs<ExtArgs>
    bookings?: boolean | User$bookingsArgs<ExtArgs>
    passwordResetTokens?: boolean | User$passwordResetTokensArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>


  export type UserSelectScalar = {
    id?: boolean
    email?: boolean
    passwordHash?: boolean
    displayName?: boolean
    avatarUrl?: boolean
    phoneNumber?: boolean
    isAdmin?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type UserInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    adminProfile?: boolean | User$adminProfileArgs<ExtArgs>
    sessions?: boolean | User$sessionsArgs<ExtArgs>
    bookings?: boolean | User$bookingsArgs<ExtArgs>
    passwordResetTokens?: boolean | User$passwordResetTokensArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $UserPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "User"
    objects: {
      adminProfile: Prisma.$AdminUserPayload<ExtArgs> | null
      sessions: Prisma.$SessionPayload<ExtArgs>[]
      bookings: Prisma.$BookingPayload<ExtArgs>[]
      passwordResetTokens: Prisma.$PasswordResetTokenPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      email: string
      passwordHash: string
      displayName: string
      avatarUrl: string | null
      phoneNumber: string | null
      isAdmin: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["user"]>
    composites: {}
  }

  type UserGetPayload<S extends boolean | null | undefined | UserDefaultArgs> = $Result.GetResult<Prisma.$UserPayload, S>

  type UserCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<UserFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: UserCountAggregateInputType | true
    }

  export interface UserDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['User'], meta: { name: 'User' } }
    /**
     * Find zero or one User that matches the filter.
     * @param {UserFindUniqueArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserFindUniqueArgs>(args: SelectSubset<T, UserFindUniqueArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one User that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {UserFindUniqueOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserFindUniqueOrThrowArgs>(args: SelectSubset<T, UserFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first User that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserFindFirstArgs>(args?: SelectSubset<T, UserFindFirstArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first User that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserFindFirstOrThrowArgs>(args?: SelectSubset<T, UserFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.user.findMany()
     * 
     * // Get first 10 Users
     * const users = await prisma.user.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userWithIdOnly = await prisma.user.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserFindManyArgs>(args?: SelectSubset<T, UserFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a User.
     * @param {UserCreateArgs} args - Arguments to create a User.
     * @example
     * // Create one User
     * const User = await prisma.user.create({
     *   data: {
     *     // ... data to create a User
     *   }
     * })
     * 
     */
    create<T extends UserCreateArgs>(args: SelectSubset<T, UserCreateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Users.
     * @param {UserCreateManyArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserCreateManyArgs>(args?: SelectSubset<T, UserCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a User.
     * @param {UserDeleteArgs} args - Arguments to delete one User.
     * @example
     * // Delete one User
     * const User = await prisma.user.delete({
     *   where: {
     *     // ... filter to delete one User
     *   }
     * })
     * 
     */
    delete<T extends UserDeleteArgs>(args: SelectSubset<T, UserDeleteArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one User.
     * @param {UserUpdateArgs} args - Arguments to update one User.
     * @example
     * // Update one User
     * const user = await prisma.user.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserUpdateArgs>(args: SelectSubset<T, UserUpdateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Users.
     * @param {UserDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.user.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserDeleteManyArgs>(args?: SelectSubset<T, UserDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserUpdateManyArgs>(args: SelectSubset<T, UserUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one User.
     * @param {UserUpsertArgs} args - Arguments to update or create a User.
     * @example
     * // Update or create a User
     * const user = await prisma.user.upsert({
     *   create: {
     *     // ... data to create a User
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User we want to update
     *   }
     * })
     */
    upsert<T extends UserUpsertArgs>(args: SelectSubset<T, UserUpsertArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.user.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
    **/
    count<T extends UserCountArgs>(
      args?: Subset<T, UserCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserAggregateArgs>(args: Subset<T, UserAggregateArgs>): Prisma.PrismaPromise<GetUserAggregateType<T>>

    /**
     * Group by User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserGroupByArgs['orderBy'] }
        : { orderBy?: UserGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the User model
   */
  readonly fields: UserFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for User.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    adminProfile<T extends User$adminProfileArgs<ExtArgs> = {}>(args?: Subset<T, User$adminProfileArgs<ExtArgs>>): Prisma__AdminUserClient<$Result.GetResult<Prisma.$AdminUserPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    sessions<T extends User$sessionsArgs<ExtArgs> = {}>(args?: Subset<T, User$sessionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findMany"> | Null>
    bookings<T extends User$bookingsArgs<ExtArgs> = {}>(args?: Subset<T, User$bookingsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BookingPayload<ExtArgs>, T, "findMany"> | Null>
    passwordResetTokens<T extends User$passwordResetTokensArgs<ExtArgs> = {}>(args?: Subset<T, User$passwordResetTokensArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PasswordResetTokenPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the User model
   */ 
  interface UserFieldRefs {
    readonly id: FieldRef<"User", 'String'>
    readonly email: FieldRef<"User", 'String'>
    readonly passwordHash: FieldRef<"User", 'String'>
    readonly displayName: FieldRef<"User", 'String'>
    readonly avatarUrl: FieldRef<"User", 'String'>
    readonly phoneNumber: FieldRef<"User", 'String'>
    readonly isAdmin: FieldRef<"User", 'Boolean'>
    readonly createdAt: FieldRef<"User", 'DateTime'>
    readonly updatedAt: FieldRef<"User", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * User findUnique
   */
  export type UserFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findUniqueOrThrow
   */
  export type UserFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findFirst
   */
  export type UserFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findFirstOrThrow
   */
  export type UserFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findMany
   */
  export type UserFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which Users to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User create
   */
  export type UserCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to create a User.
     */
    data: XOR<UserCreateInput, UserUncheckedCreateInput>
  }

  /**
   * User createMany
   */
  export type UserCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * User update
   */
  export type UserUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to update a User.
     */
    data: XOR<UserUpdateInput, UserUncheckedUpdateInput>
    /**
     * Choose, which User to update.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User updateMany
   */
  export type UserUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
  }

  /**
   * User upsert
   */
  export type UserUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The filter to search for the User to update in case it exists.
     */
    where: UserWhereUniqueInput
    /**
     * In case the User found by the `where` argument doesn't exist, create a new User with this data.
     */
    create: XOR<UserCreateInput, UserUncheckedCreateInput>
    /**
     * In case the User was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserUpdateInput, UserUncheckedUpdateInput>
  }

  /**
   * User delete
   */
  export type UserDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter which User to delete.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User deleteMany
   */
  export type UserDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Users to delete
     */
    where?: UserWhereInput
  }

  /**
   * User.adminProfile
   */
  export type User$adminProfileArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminUser
     */
    select?: AdminUserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminUserInclude<ExtArgs> | null
    where?: AdminUserWhereInput
  }

  /**
   * User.sessions
   */
  export type User$sessionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    where?: SessionWhereInput
    orderBy?: SessionOrderByWithRelationInput | SessionOrderByWithRelationInput[]
    cursor?: SessionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SessionScalarFieldEnum | SessionScalarFieldEnum[]
  }

  /**
   * User.bookings
   */
  export type User$bookingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Booking
     */
    select?: BookingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingInclude<ExtArgs> | null
    where?: BookingWhereInput
    orderBy?: BookingOrderByWithRelationInput | BookingOrderByWithRelationInput[]
    cursor?: BookingWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BookingScalarFieldEnum | BookingScalarFieldEnum[]
  }

  /**
   * User.passwordResetTokens
   */
  export type User$passwordResetTokensArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PasswordResetToken
     */
    select?: PasswordResetTokenSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PasswordResetTokenInclude<ExtArgs> | null
    where?: PasswordResetTokenWhereInput
    orderBy?: PasswordResetTokenOrderByWithRelationInput | PasswordResetTokenOrderByWithRelationInput[]
    cursor?: PasswordResetTokenWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PasswordResetTokenScalarFieldEnum | PasswordResetTokenScalarFieldEnum[]
  }

  /**
   * User without action
   */
  export type UserDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
  }


  /**
   * Model AdminUser
   */

  export type AggregateAdminUser = {
    _count: AdminUserCountAggregateOutputType | null
    _min: AdminUserMinAggregateOutputType | null
    _max: AdminUserMaxAggregateOutputType | null
  }

  export type AdminUserMinAggregateOutputType = {
    id: string | null
    userId: string | null
    status: $Enums.AdminStatus | null
    lastActiveAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AdminUserMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    status: $Enums.AdminStatus | null
    lastActiveAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AdminUserCountAggregateOutputType = {
    id: number
    userId: number
    status: number
    lastActiveAt: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type AdminUserMinAggregateInputType = {
    id?: true
    userId?: true
    status?: true
    lastActiveAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AdminUserMaxAggregateInputType = {
    id?: true
    userId?: true
    status?: true
    lastActiveAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AdminUserCountAggregateInputType = {
    id?: true
    userId?: true
    status?: true
    lastActiveAt?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type AdminUserAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AdminUser to aggregate.
     */
    where?: AdminUserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AdminUsers to fetch.
     */
    orderBy?: AdminUserOrderByWithRelationInput | AdminUserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AdminUserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AdminUsers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AdminUsers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AdminUsers
    **/
    _count?: true | AdminUserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AdminUserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AdminUserMaxAggregateInputType
  }

  export type GetAdminUserAggregateType<T extends AdminUserAggregateArgs> = {
        [P in keyof T & keyof AggregateAdminUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAdminUser[P]>
      : GetScalarType<T[P], AggregateAdminUser[P]>
  }




  export type AdminUserGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AdminUserWhereInput
    orderBy?: AdminUserOrderByWithAggregationInput | AdminUserOrderByWithAggregationInput[]
    by: AdminUserScalarFieldEnum[] | AdminUserScalarFieldEnum
    having?: AdminUserScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AdminUserCountAggregateInputType | true
    _min?: AdminUserMinAggregateInputType
    _max?: AdminUserMaxAggregateInputType
  }

  export type AdminUserGroupByOutputType = {
    id: string
    userId: string
    status: $Enums.AdminStatus
    lastActiveAt: Date | null
    createdAt: Date
    updatedAt: Date
    _count: AdminUserCountAggregateOutputType | null
    _min: AdminUserMinAggregateOutputType | null
    _max: AdminUserMaxAggregateOutputType | null
  }

  type GetAdminUserGroupByPayload<T extends AdminUserGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AdminUserGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AdminUserGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AdminUserGroupByOutputType[P]>
            : GetScalarType<T[P], AdminUserGroupByOutputType[P]>
        }
      >
    >


  export type AdminUserSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    status?: boolean
    lastActiveAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    roles?: boolean | AdminUser$rolesArgs<ExtArgs>
    _count?: boolean | AdminUserCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["adminUser"]>


  export type AdminUserSelectScalar = {
    id?: boolean
    userId?: boolean
    status?: boolean
    lastActiveAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type AdminUserInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    roles?: boolean | AdminUser$rolesArgs<ExtArgs>
    _count?: boolean | AdminUserCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $AdminUserPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "AdminUser"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      roles: Prisma.$AdminUserRolePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      status: $Enums.AdminStatus
      lastActiveAt: Date | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["adminUser"]>
    composites: {}
  }

  type AdminUserGetPayload<S extends boolean | null | undefined | AdminUserDefaultArgs> = $Result.GetResult<Prisma.$AdminUserPayload, S>

  type AdminUserCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<AdminUserFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: AdminUserCountAggregateInputType | true
    }

  export interface AdminUserDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AdminUser'], meta: { name: 'AdminUser' } }
    /**
     * Find zero or one AdminUser that matches the filter.
     * @param {AdminUserFindUniqueArgs} args - Arguments to find a AdminUser
     * @example
     * // Get one AdminUser
     * const adminUser = await prisma.adminUser.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AdminUserFindUniqueArgs>(args: SelectSubset<T, AdminUserFindUniqueArgs<ExtArgs>>): Prisma__AdminUserClient<$Result.GetResult<Prisma.$AdminUserPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one AdminUser that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {AdminUserFindUniqueOrThrowArgs} args - Arguments to find a AdminUser
     * @example
     * // Get one AdminUser
     * const adminUser = await prisma.adminUser.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AdminUserFindUniqueOrThrowArgs>(args: SelectSubset<T, AdminUserFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AdminUserClient<$Result.GetResult<Prisma.$AdminUserPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first AdminUser that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminUserFindFirstArgs} args - Arguments to find a AdminUser
     * @example
     * // Get one AdminUser
     * const adminUser = await prisma.adminUser.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AdminUserFindFirstArgs>(args?: SelectSubset<T, AdminUserFindFirstArgs<ExtArgs>>): Prisma__AdminUserClient<$Result.GetResult<Prisma.$AdminUserPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first AdminUser that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminUserFindFirstOrThrowArgs} args - Arguments to find a AdminUser
     * @example
     * // Get one AdminUser
     * const adminUser = await prisma.adminUser.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AdminUserFindFirstOrThrowArgs>(args?: SelectSubset<T, AdminUserFindFirstOrThrowArgs<ExtArgs>>): Prisma__AdminUserClient<$Result.GetResult<Prisma.$AdminUserPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more AdminUsers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminUserFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AdminUsers
     * const adminUsers = await prisma.adminUser.findMany()
     * 
     * // Get first 10 AdminUsers
     * const adminUsers = await prisma.adminUser.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const adminUserWithIdOnly = await prisma.adminUser.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AdminUserFindManyArgs>(args?: SelectSubset<T, AdminUserFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AdminUserPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a AdminUser.
     * @param {AdminUserCreateArgs} args - Arguments to create a AdminUser.
     * @example
     * // Create one AdminUser
     * const AdminUser = await prisma.adminUser.create({
     *   data: {
     *     // ... data to create a AdminUser
     *   }
     * })
     * 
     */
    create<T extends AdminUserCreateArgs>(args: SelectSubset<T, AdminUserCreateArgs<ExtArgs>>): Prisma__AdminUserClient<$Result.GetResult<Prisma.$AdminUserPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many AdminUsers.
     * @param {AdminUserCreateManyArgs} args - Arguments to create many AdminUsers.
     * @example
     * // Create many AdminUsers
     * const adminUser = await prisma.adminUser.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AdminUserCreateManyArgs>(args?: SelectSubset<T, AdminUserCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a AdminUser.
     * @param {AdminUserDeleteArgs} args - Arguments to delete one AdminUser.
     * @example
     * // Delete one AdminUser
     * const AdminUser = await prisma.adminUser.delete({
     *   where: {
     *     // ... filter to delete one AdminUser
     *   }
     * })
     * 
     */
    delete<T extends AdminUserDeleteArgs>(args: SelectSubset<T, AdminUserDeleteArgs<ExtArgs>>): Prisma__AdminUserClient<$Result.GetResult<Prisma.$AdminUserPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one AdminUser.
     * @param {AdminUserUpdateArgs} args - Arguments to update one AdminUser.
     * @example
     * // Update one AdminUser
     * const adminUser = await prisma.adminUser.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AdminUserUpdateArgs>(args: SelectSubset<T, AdminUserUpdateArgs<ExtArgs>>): Prisma__AdminUserClient<$Result.GetResult<Prisma.$AdminUserPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more AdminUsers.
     * @param {AdminUserDeleteManyArgs} args - Arguments to filter AdminUsers to delete.
     * @example
     * // Delete a few AdminUsers
     * const { count } = await prisma.adminUser.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AdminUserDeleteManyArgs>(args?: SelectSubset<T, AdminUserDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AdminUsers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminUserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AdminUsers
     * const adminUser = await prisma.adminUser.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AdminUserUpdateManyArgs>(args: SelectSubset<T, AdminUserUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one AdminUser.
     * @param {AdminUserUpsertArgs} args - Arguments to update or create a AdminUser.
     * @example
     * // Update or create a AdminUser
     * const adminUser = await prisma.adminUser.upsert({
     *   create: {
     *     // ... data to create a AdminUser
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AdminUser we want to update
     *   }
     * })
     */
    upsert<T extends AdminUserUpsertArgs>(args: SelectSubset<T, AdminUserUpsertArgs<ExtArgs>>): Prisma__AdminUserClient<$Result.GetResult<Prisma.$AdminUserPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of AdminUsers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminUserCountArgs} args - Arguments to filter AdminUsers to count.
     * @example
     * // Count the number of AdminUsers
     * const count = await prisma.adminUser.count({
     *   where: {
     *     // ... the filter for the AdminUsers we want to count
     *   }
     * })
    **/
    count<T extends AdminUserCountArgs>(
      args?: Subset<T, AdminUserCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AdminUserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AdminUser.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminUserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AdminUserAggregateArgs>(args: Subset<T, AdminUserAggregateArgs>): Prisma.PrismaPromise<GetAdminUserAggregateType<T>>

    /**
     * Group by AdminUser.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminUserGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AdminUserGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AdminUserGroupByArgs['orderBy'] }
        : { orderBy?: AdminUserGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AdminUserGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAdminUserGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the AdminUser model
   */
  readonly fields: AdminUserFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AdminUser.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AdminUserClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    roles<T extends AdminUser$rolesArgs<ExtArgs> = {}>(args?: Subset<T, AdminUser$rolesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AdminUserRolePayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the AdminUser model
   */ 
  interface AdminUserFieldRefs {
    readonly id: FieldRef<"AdminUser", 'String'>
    readonly userId: FieldRef<"AdminUser", 'String'>
    readonly status: FieldRef<"AdminUser", 'AdminStatus'>
    readonly lastActiveAt: FieldRef<"AdminUser", 'DateTime'>
    readonly createdAt: FieldRef<"AdminUser", 'DateTime'>
    readonly updatedAt: FieldRef<"AdminUser", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * AdminUser findUnique
   */
  export type AdminUserFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminUser
     */
    select?: AdminUserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminUserInclude<ExtArgs> | null
    /**
     * Filter, which AdminUser to fetch.
     */
    where: AdminUserWhereUniqueInput
  }

  /**
   * AdminUser findUniqueOrThrow
   */
  export type AdminUserFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminUser
     */
    select?: AdminUserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminUserInclude<ExtArgs> | null
    /**
     * Filter, which AdminUser to fetch.
     */
    where: AdminUserWhereUniqueInput
  }

  /**
   * AdminUser findFirst
   */
  export type AdminUserFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminUser
     */
    select?: AdminUserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminUserInclude<ExtArgs> | null
    /**
     * Filter, which AdminUser to fetch.
     */
    where?: AdminUserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AdminUsers to fetch.
     */
    orderBy?: AdminUserOrderByWithRelationInput | AdminUserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AdminUsers.
     */
    cursor?: AdminUserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AdminUsers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AdminUsers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AdminUsers.
     */
    distinct?: AdminUserScalarFieldEnum | AdminUserScalarFieldEnum[]
  }

  /**
   * AdminUser findFirstOrThrow
   */
  export type AdminUserFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminUser
     */
    select?: AdminUserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminUserInclude<ExtArgs> | null
    /**
     * Filter, which AdminUser to fetch.
     */
    where?: AdminUserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AdminUsers to fetch.
     */
    orderBy?: AdminUserOrderByWithRelationInput | AdminUserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AdminUsers.
     */
    cursor?: AdminUserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AdminUsers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AdminUsers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AdminUsers.
     */
    distinct?: AdminUserScalarFieldEnum | AdminUserScalarFieldEnum[]
  }

  /**
   * AdminUser findMany
   */
  export type AdminUserFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminUser
     */
    select?: AdminUserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminUserInclude<ExtArgs> | null
    /**
     * Filter, which AdminUsers to fetch.
     */
    where?: AdminUserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AdminUsers to fetch.
     */
    orderBy?: AdminUserOrderByWithRelationInput | AdminUserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AdminUsers.
     */
    cursor?: AdminUserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AdminUsers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AdminUsers.
     */
    skip?: number
    distinct?: AdminUserScalarFieldEnum | AdminUserScalarFieldEnum[]
  }

  /**
   * AdminUser create
   */
  export type AdminUserCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminUser
     */
    select?: AdminUserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminUserInclude<ExtArgs> | null
    /**
     * The data needed to create a AdminUser.
     */
    data: XOR<AdminUserCreateInput, AdminUserUncheckedCreateInput>
  }

  /**
   * AdminUser createMany
   */
  export type AdminUserCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AdminUsers.
     */
    data: AdminUserCreateManyInput | AdminUserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AdminUser update
   */
  export type AdminUserUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminUser
     */
    select?: AdminUserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminUserInclude<ExtArgs> | null
    /**
     * The data needed to update a AdminUser.
     */
    data: XOR<AdminUserUpdateInput, AdminUserUncheckedUpdateInput>
    /**
     * Choose, which AdminUser to update.
     */
    where: AdminUserWhereUniqueInput
  }

  /**
   * AdminUser updateMany
   */
  export type AdminUserUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AdminUsers.
     */
    data: XOR<AdminUserUpdateManyMutationInput, AdminUserUncheckedUpdateManyInput>
    /**
     * Filter which AdminUsers to update
     */
    where?: AdminUserWhereInput
  }

  /**
   * AdminUser upsert
   */
  export type AdminUserUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminUser
     */
    select?: AdminUserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminUserInclude<ExtArgs> | null
    /**
     * The filter to search for the AdminUser to update in case it exists.
     */
    where: AdminUserWhereUniqueInput
    /**
     * In case the AdminUser found by the `where` argument doesn't exist, create a new AdminUser with this data.
     */
    create: XOR<AdminUserCreateInput, AdminUserUncheckedCreateInput>
    /**
     * In case the AdminUser was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AdminUserUpdateInput, AdminUserUncheckedUpdateInput>
  }

  /**
   * AdminUser delete
   */
  export type AdminUserDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminUser
     */
    select?: AdminUserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminUserInclude<ExtArgs> | null
    /**
     * Filter which AdminUser to delete.
     */
    where: AdminUserWhereUniqueInput
  }

  /**
   * AdminUser deleteMany
   */
  export type AdminUserDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AdminUsers to delete
     */
    where?: AdminUserWhereInput
  }

  /**
   * AdminUser.roles
   */
  export type AdminUser$rolesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminUserRole
     */
    select?: AdminUserRoleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminUserRoleInclude<ExtArgs> | null
    where?: AdminUserRoleWhereInput
    orderBy?: AdminUserRoleOrderByWithRelationInput | AdminUserRoleOrderByWithRelationInput[]
    cursor?: AdminUserRoleWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AdminUserRoleScalarFieldEnum | AdminUserRoleScalarFieldEnum[]
  }

  /**
   * AdminUser without action
   */
  export type AdminUserDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminUser
     */
    select?: AdminUserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminUserInclude<ExtArgs> | null
  }


  /**
   * Model AdminUserRole
   */

  export type AggregateAdminUserRole = {
    _count: AdminUserRoleCountAggregateOutputType | null
    _avg: AdminUserRoleAvgAggregateOutputType | null
    _sum: AdminUserRoleSumAggregateOutputType | null
    _min: AdminUserRoleMinAggregateOutputType | null
    _max: AdminUserRoleMaxAggregateOutputType | null
  }

  export type AdminUserRoleAvgAggregateOutputType = {
    id: number | null
  }

  export type AdminUserRoleSumAggregateOutputType = {
    id: number | null
  }

  export type AdminUserRoleMinAggregateOutputType = {
    id: number | null
    adminUserId: string | null
    role: $Enums.AdminRole | null
  }

  export type AdminUserRoleMaxAggregateOutputType = {
    id: number | null
    adminUserId: string | null
    role: $Enums.AdminRole | null
  }

  export type AdminUserRoleCountAggregateOutputType = {
    id: number
    adminUserId: number
    role: number
    _all: number
  }


  export type AdminUserRoleAvgAggregateInputType = {
    id?: true
  }

  export type AdminUserRoleSumAggregateInputType = {
    id?: true
  }

  export type AdminUserRoleMinAggregateInputType = {
    id?: true
    adminUserId?: true
    role?: true
  }

  export type AdminUserRoleMaxAggregateInputType = {
    id?: true
    adminUserId?: true
    role?: true
  }

  export type AdminUserRoleCountAggregateInputType = {
    id?: true
    adminUserId?: true
    role?: true
    _all?: true
  }

  export type AdminUserRoleAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AdminUserRole to aggregate.
     */
    where?: AdminUserRoleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AdminUserRoles to fetch.
     */
    orderBy?: AdminUserRoleOrderByWithRelationInput | AdminUserRoleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AdminUserRoleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AdminUserRoles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AdminUserRoles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AdminUserRoles
    **/
    _count?: true | AdminUserRoleCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AdminUserRoleAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AdminUserRoleSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AdminUserRoleMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AdminUserRoleMaxAggregateInputType
  }

  export type GetAdminUserRoleAggregateType<T extends AdminUserRoleAggregateArgs> = {
        [P in keyof T & keyof AggregateAdminUserRole]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAdminUserRole[P]>
      : GetScalarType<T[P], AggregateAdminUserRole[P]>
  }




  export type AdminUserRoleGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AdminUserRoleWhereInput
    orderBy?: AdminUserRoleOrderByWithAggregationInput | AdminUserRoleOrderByWithAggregationInput[]
    by: AdminUserRoleScalarFieldEnum[] | AdminUserRoleScalarFieldEnum
    having?: AdminUserRoleScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AdminUserRoleCountAggregateInputType | true
    _avg?: AdminUserRoleAvgAggregateInputType
    _sum?: AdminUserRoleSumAggregateInputType
    _min?: AdminUserRoleMinAggregateInputType
    _max?: AdminUserRoleMaxAggregateInputType
  }

  export type AdminUserRoleGroupByOutputType = {
    id: number
    adminUserId: string
    role: $Enums.AdminRole
    _count: AdminUserRoleCountAggregateOutputType | null
    _avg: AdminUserRoleAvgAggregateOutputType | null
    _sum: AdminUserRoleSumAggregateOutputType | null
    _min: AdminUserRoleMinAggregateOutputType | null
    _max: AdminUserRoleMaxAggregateOutputType | null
  }

  type GetAdminUserRoleGroupByPayload<T extends AdminUserRoleGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AdminUserRoleGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AdminUserRoleGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AdminUserRoleGroupByOutputType[P]>
            : GetScalarType<T[P], AdminUserRoleGroupByOutputType[P]>
        }
      >
    >


  export type AdminUserRoleSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    adminUserId?: boolean
    role?: boolean
    adminUser?: boolean | AdminUserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["adminUserRole"]>


  export type AdminUserRoleSelectScalar = {
    id?: boolean
    adminUserId?: boolean
    role?: boolean
  }

  export type AdminUserRoleInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    adminUser?: boolean | AdminUserDefaultArgs<ExtArgs>
  }

  export type $AdminUserRolePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "AdminUserRole"
    objects: {
      adminUser: Prisma.$AdminUserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      adminUserId: string
      role: $Enums.AdminRole
    }, ExtArgs["result"]["adminUserRole"]>
    composites: {}
  }

  type AdminUserRoleGetPayload<S extends boolean | null | undefined | AdminUserRoleDefaultArgs> = $Result.GetResult<Prisma.$AdminUserRolePayload, S>

  type AdminUserRoleCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<AdminUserRoleFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: AdminUserRoleCountAggregateInputType | true
    }

  export interface AdminUserRoleDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AdminUserRole'], meta: { name: 'AdminUserRole' } }
    /**
     * Find zero or one AdminUserRole that matches the filter.
     * @param {AdminUserRoleFindUniqueArgs} args - Arguments to find a AdminUserRole
     * @example
     * // Get one AdminUserRole
     * const adminUserRole = await prisma.adminUserRole.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AdminUserRoleFindUniqueArgs>(args: SelectSubset<T, AdminUserRoleFindUniqueArgs<ExtArgs>>): Prisma__AdminUserRoleClient<$Result.GetResult<Prisma.$AdminUserRolePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one AdminUserRole that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {AdminUserRoleFindUniqueOrThrowArgs} args - Arguments to find a AdminUserRole
     * @example
     * // Get one AdminUserRole
     * const adminUserRole = await prisma.adminUserRole.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AdminUserRoleFindUniqueOrThrowArgs>(args: SelectSubset<T, AdminUserRoleFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AdminUserRoleClient<$Result.GetResult<Prisma.$AdminUserRolePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first AdminUserRole that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminUserRoleFindFirstArgs} args - Arguments to find a AdminUserRole
     * @example
     * // Get one AdminUserRole
     * const adminUserRole = await prisma.adminUserRole.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AdminUserRoleFindFirstArgs>(args?: SelectSubset<T, AdminUserRoleFindFirstArgs<ExtArgs>>): Prisma__AdminUserRoleClient<$Result.GetResult<Prisma.$AdminUserRolePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first AdminUserRole that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminUserRoleFindFirstOrThrowArgs} args - Arguments to find a AdminUserRole
     * @example
     * // Get one AdminUserRole
     * const adminUserRole = await prisma.adminUserRole.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AdminUserRoleFindFirstOrThrowArgs>(args?: SelectSubset<T, AdminUserRoleFindFirstOrThrowArgs<ExtArgs>>): Prisma__AdminUserRoleClient<$Result.GetResult<Prisma.$AdminUserRolePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more AdminUserRoles that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminUserRoleFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AdminUserRoles
     * const adminUserRoles = await prisma.adminUserRole.findMany()
     * 
     * // Get first 10 AdminUserRoles
     * const adminUserRoles = await prisma.adminUserRole.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const adminUserRoleWithIdOnly = await prisma.adminUserRole.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AdminUserRoleFindManyArgs>(args?: SelectSubset<T, AdminUserRoleFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AdminUserRolePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a AdminUserRole.
     * @param {AdminUserRoleCreateArgs} args - Arguments to create a AdminUserRole.
     * @example
     * // Create one AdminUserRole
     * const AdminUserRole = await prisma.adminUserRole.create({
     *   data: {
     *     // ... data to create a AdminUserRole
     *   }
     * })
     * 
     */
    create<T extends AdminUserRoleCreateArgs>(args: SelectSubset<T, AdminUserRoleCreateArgs<ExtArgs>>): Prisma__AdminUserRoleClient<$Result.GetResult<Prisma.$AdminUserRolePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many AdminUserRoles.
     * @param {AdminUserRoleCreateManyArgs} args - Arguments to create many AdminUserRoles.
     * @example
     * // Create many AdminUserRoles
     * const adminUserRole = await prisma.adminUserRole.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AdminUserRoleCreateManyArgs>(args?: SelectSubset<T, AdminUserRoleCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a AdminUserRole.
     * @param {AdminUserRoleDeleteArgs} args - Arguments to delete one AdminUserRole.
     * @example
     * // Delete one AdminUserRole
     * const AdminUserRole = await prisma.adminUserRole.delete({
     *   where: {
     *     // ... filter to delete one AdminUserRole
     *   }
     * })
     * 
     */
    delete<T extends AdminUserRoleDeleteArgs>(args: SelectSubset<T, AdminUserRoleDeleteArgs<ExtArgs>>): Prisma__AdminUserRoleClient<$Result.GetResult<Prisma.$AdminUserRolePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one AdminUserRole.
     * @param {AdminUserRoleUpdateArgs} args - Arguments to update one AdminUserRole.
     * @example
     * // Update one AdminUserRole
     * const adminUserRole = await prisma.adminUserRole.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AdminUserRoleUpdateArgs>(args: SelectSubset<T, AdminUserRoleUpdateArgs<ExtArgs>>): Prisma__AdminUserRoleClient<$Result.GetResult<Prisma.$AdminUserRolePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more AdminUserRoles.
     * @param {AdminUserRoleDeleteManyArgs} args - Arguments to filter AdminUserRoles to delete.
     * @example
     * // Delete a few AdminUserRoles
     * const { count } = await prisma.adminUserRole.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AdminUserRoleDeleteManyArgs>(args?: SelectSubset<T, AdminUserRoleDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AdminUserRoles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminUserRoleUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AdminUserRoles
     * const adminUserRole = await prisma.adminUserRole.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AdminUserRoleUpdateManyArgs>(args: SelectSubset<T, AdminUserRoleUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one AdminUserRole.
     * @param {AdminUserRoleUpsertArgs} args - Arguments to update or create a AdminUserRole.
     * @example
     * // Update or create a AdminUserRole
     * const adminUserRole = await prisma.adminUserRole.upsert({
     *   create: {
     *     // ... data to create a AdminUserRole
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AdminUserRole we want to update
     *   }
     * })
     */
    upsert<T extends AdminUserRoleUpsertArgs>(args: SelectSubset<T, AdminUserRoleUpsertArgs<ExtArgs>>): Prisma__AdminUserRoleClient<$Result.GetResult<Prisma.$AdminUserRolePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of AdminUserRoles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminUserRoleCountArgs} args - Arguments to filter AdminUserRoles to count.
     * @example
     * // Count the number of AdminUserRoles
     * const count = await prisma.adminUserRole.count({
     *   where: {
     *     // ... the filter for the AdminUserRoles we want to count
     *   }
     * })
    **/
    count<T extends AdminUserRoleCountArgs>(
      args?: Subset<T, AdminUserRoleCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AdminUserRoleCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AdminUserRole.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminUserRoleAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AdminUserRoleAggregateArgs>(args: Subset<T, AdminUserRoleAggregateArgs>): Prisma.PrismaPromise<GetAdminUserRoleAggregateType<T>>

    /**
     * Group by AdminUserRole.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminUserRoleGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AdminUserRoleGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AdminUserRoleGroupByArgs['orderBy'] }
        : { orderBy?: AdminUserRoleGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AdminUserRoleGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAdminUserRoleGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the AdminUserRole model
   */
  readonly fields: AdminUserRoleFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AdminUserRole.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AdminUserRoleClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    adminUser<T extends AdminUserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, AdminUserDefaultArgs<ExtArgs>>): Prisma__AdminUserClient<$Result.GetResult<Prisma.$AdminUserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the AdminUserRole model
   */ 
  interface AdminUserRoleFieldRefs {
    readonly id: FieldRef<"AdminUserRole", 'Int'>
    readonly adminUserId: FieldRef<"AdminUserRole", 'String'>
    readonly role: FieldRef<"AdminUserRole", 'AdminRole'>
  }
    

  // Custom InputTypes
  /**
   * AdminUserRole findUnique
   */
  export type AdminUserRoleFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminUserRole
     */
    select?: AdminUserRoleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminUserRoleInclude<ExtArgs> | null
    /**
     * Filter, which AdminUserRole to fetch.
     */
    where: AdminUserRoleWhereUniqueInput
  }

  /**
   * AdminUserRole findUniqueOrThrow
   */
  export type AdminUserRoleFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminUserRole
     */
    select?: AdminUserRoleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminUserRoleInclude<ExtArgs> | null
    /**
     * Filter, which AdminUserRole to fetch.
     */
    where: AdminUserRoleWhereUniqueInput
  }

  /**
   * AdminUserRole findFirst
   */
  export type AdminUserRoleFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminUserRole
     */
    select?: AdminUserRoleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminUserRoleInclude<ExtArgs> | null
    /**
     * Filter, which AdminUserRole to fetch.
     */
    where?: AdminUserRoleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AdminUserRoles to fetch.
     */
    orderBy?: AdminUserRoleOrderByWithRelationInput | AdminUserRoleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AdminUserRoles.
     */
    cursor?: AdminUserRoleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AdminUserRoles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AdminUserRoles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AdminUserRoles.
     */
    distinct?: AdminUserRoleScalarFieldEnum | AdminUserRoleScalarFieldEnum[]
  }

  /**
   * AdminUserRole findFirstOrThrow
   */
  export type AdminUserRoleFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminUserRole
     */
    select?: AdminUserRoleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminUserRoleInclude<ExtArgs> | null
    /**
     * Filter, which AdminUserRole to fetch.
     */
    where?: AdminUserRoleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AdminUserRoles to fetch.
     */
    orderBy?: AdminUserRoleOrderByWithRelationInput | AdminUserRoleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AdminUserRoles.
     */
    cursor?: AdminUserRoleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AdminUserRoles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AdminUserRoles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AdminUserRoles.
     */
    distinct?: AdminUserRoleScalarFieldEnum | AdminUserRoleScalarFieldEnum[]
  }

  /**
   * AdminUserRole findMany
   */
  export type AdminUserRoleFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminUserRole
     */
    select?: AdminUserRoleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminUserRoleInclude<ExtArgs> | null
    /**
     * Filter, which AdminUserRoles to fetch.
     */
    where?: AdminUserRoleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AdminUserRoles to fetch.
     */
    orderBy?: AdminUserRoleOrderByWithRelationInput | AdminUserRoleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AdminUserRoles.
     */
    cursor?: AdminUserRoleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AdminUserRoles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AdminUserRoles.
     */
    skip?: number
    distinct?: AdminUserRoleScalarFieldEnum | AdminUserRoleScalarFieldEnum[]
  }

  /**
   * AdminUserRole create
   */
  export type AdminUserRoleCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminUserRole
     */
    select?: AdminUserRoleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminUserRoleInclude<ExtArgs> | null
    /**
     * The data needed to create a AdminUserRole.
     */
    data: XOR<AdminUserRoleCreateInput, AdminUserRoleUncheckedCreateInput>
  }

  /**
   * AdminUserRole createMany
   */
  export type AdminUserRoleCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AdminUserRoles.
     */
    data: AdminUserRoleCreateManyInput | AdminUserRoleCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AdminUserRole update
   */
  export type AdminUserRoleUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminUserRole
     */
    select?: AdminUserRoleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminUserRoleInclude<ExtArgs> | null
    /**
     * The data needed to update a AdminUserRole.
     */
    data: XOR<AdminUserRoleUpdateInput, AdminUserRoleUncheckedUpdateInput>
    /**
     * Choose, which AdminUserRole to update.
     */
    where: AdminUserRoleWhereUniqueInput
  }

  /**
   * AdminUserRole updateMany
   */
  export type AdminUserRoleUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AdminUserRoles.
     */
    data: XOR<AdminUserRoleUpdateManyMutationInput, AdminUserRoleUncheckedUpdateManyInput>
    /**
     * Filter which AdminUserRoles to update
     */
    where?: AdminUserRoleWhereInput
  }

  /**
   * AdminUserRole upsert
   */
  export type AdminUserRoleUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminUserRole
     */
    select?: AdminUserRoleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminUserRoleInclude<ExtArgs> | null
    /**
     * The filter to search for the AdminUserRole to update in case it exists.
     */
    where: AdminUserRoleWhereUniqueInput
    /**
     * In case the AdminUserRole found by the `where` argument doesn't exist, create a new AdminUserRole with this data.
     */
    create: XOR<AdminUserRoleCreateInput, AdminUserRoleUncheckedCreateInput>
    /**
     * In case the AdminUserRole was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AdminUserRoleUpdateInput, AdminUserRoleUncheckedUpdateInput>
  }

  /**
   * AdminUserRole delete
   */
  export type AdminUserRoleDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminUserRole
     */
    select?: AdminUserRoleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminUserRoleInclude<ExtArgs> | null
    /**
     * Filter which AdminUserRole to delete.
     */
    where: AdminUserRoleWhereUniqueInput
  }

  /**
   * AdminUserRole deleteMany
   */
  export type AdminUserRoleDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AdminUserRoles to delete
     */
    where?: AdminUserRoleWhereInput
  }

  /**
   * AdminUserRole without action
   */
  export type AdminUserRoleDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminUserRole
     */
    select?: AdminUserRoleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminUserRoleInclude<ExtArgs> | null
  }


  /**
   * Model Session
   */

  export type AggregateSession = {
    _count: SessionCountAggregateOutputType | null
    _min: SessionMinAggregateOutputType | null
    _max: SessionMaxAggregateOutputType | null
  }

  export type SessionMinAggregateOutputType = {
    id: string | null
    userId: string | null
    refreshToken: string | null
    expiresAt: Date | null
    createdAt: Date | null
    revokedAt: Date | null
    ipAddress: string | null
    userAgent: string | null
  }

  export type SessionMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    refreshToken: string | null
    expiresAt: Date | null
    createdAt: Date | null
    revokedAt: Date | null
    ipAddress: string | null
    userAgent: string | null
  }

  export type SessionCountAggregateOutputType = {
    id: number
    userId: number
    refreshToken: number
    expiresAt: number
    createdAt: number
    revokedAt: number
    ipAddress: number
    userAgent: number
    _all: number
  }


  export type SessionMinAggregateInputType = {
    id?: true
    userId?: true
    refreshToken?: true
    expiresAt?: true
    createdAt?: true
    revokedAt?: true
    ipAddress?: true
    userAgent?: true
  }

  export type SessionMaxAggregateInputType = {
    id?: true
    userId?: true
    refreshToken?: true
    expiresAt?: true
    createdAt?: true
    revokedAt?: true
    ipAddress?: true
    userAgent?: true
  }

  export type SessionCountAggregateInputType = {
    id?: true
    userId?: true
    refreshToken?: true
    expiresAt?: true
    createdAt?: true
    revokedAt?: true
    ipAddress?: true
    userAgent?: true
    _all?: true
  }

  export type SessionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Session to aggregate.
     */
    where?: SessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sessions to fetch.
     */
    orderBy?: SessionOrderByWithRelationInput | SessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Sessions
    **/
    _count?: true | SessionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SessionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SessionMaxAggregateInputType
  }

  export type GetSessionAggregateType<T extends SessionAggregateArgs> = {
        [P in keyof T & keyof AggregateSession]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSession[P]>
      : GetScalarType<T[P], AggregateSession[P]>
  }




  export type SessionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SessionWhereInput
    orderBy?: SessionOrderByWithAggregationInput | SessionOrderByWithAggregationInput[]
    by: SessionScalarFieldEnum[] | SessionScalarFieldEnum
    having?: SessionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SessionCountAggregateInputType | true
    _min?: SessionMinAggregateInputType
    _max?: SessionMaxAggregateInputType
  }

  export type SessionGroupByOutputType = {
    id: string
    userId: string
    refreshToken: string
    expiresAt: Date
    createdAt: Date
    revokedAt: Date | null
    ipAddress: string | null
    userAgent: string | null
    _count: SessionCountAggregateOutputType | null
    _min: SessionMinAggregateOutputType | null
    _max: SessionMaxAggregateOutputType | null
  }

  type GetSessionGroupByPayload<T extends SessionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SessionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SessionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SessionGroupByOutputType[P]>
            : GetScalarType<T[P], SessionGroupByOutputType[P]>
        }
      >
    >


  export type SessionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    refreshToken?: boolean
    expiresAt?: boolean
    createdAt?: boolean
    revokedAt?: boolean
    ipAddress?: boolean
    userAgent?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["session"]>


  export type SessionSelectScalar = {
    id?: boolean
    userId?: boolean
    refreshToken?: boolean
    expiresAt?: boolean
    createdAt?: boolean
    revokedAt?: boolean
    ipAddress?: boolean
    userAgent?: boolean
  }

  export type SessionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $SessionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Session"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      refreshToken: string
      expiresAt: Date
      createdAt: Date
      revokedAt: Date | null
      ipAddress: string | null
      userAgent: string | null
    }, ExtArgs["result"]["session"]>
    composites: {}
  }

  type SessionGetPayload<S extends boolean | null | undefined | SessionDefaultArgs> = $Result.GetResult<Prisma.$SessionPayload, S>

  type SessionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<SessionFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: SessionCountAggregateInputType | true
    }

  export interface SessionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Session'], meta: { name: 'Session' } }
    /**
     * Find zero or one Session that matches the filter.
     * @param {SessionFindUniqueArgs} args - Arguments to find a Session
     * @example
     * // Get one Session
     * const session = await prisma.session.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SessionFindUniqueArgs>(args: SelectSubset<T, SessionFindUniqueArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Session that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {SessionFindUniqueOrThrowArgs} args - Arguments to find a Session
     * @example
     * // Get one Session
     * const session = await prisma.session.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SessionFindUniqueOrThrowArgs>(args: SelectSubset<T, SessionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Session that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionFindFirstArgs} args - Arguments to find a Session
     * @example
     * // Get one Session
     * const session = await prisma.session.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SessionFindFirstArgs>(args?: SelectSubset<T, SessionFindFirstArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Session that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionFindFirstOrThrowArgs} args - Arguments to find a Session
     * @example
     * // Get one Session
     * const session = await prisma.session.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SessionFindFirstOrThrowArgs>(args?: SelectSubset<T, SessionFindFirstOrThrowArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Sessions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Sessions
     * const sessions = await prisma.session.findMany()
     * 
     * // Get first 10 Sessions
     * const sessions = await prisma.session.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const sessionWithIdOnly = await prisma.session.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SessionFindManyArgs>(args?: SelectSubset<T, SessionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Session.
     * @param {SessionCreateArgs} args - Arguments to create a Session.
     * @example
     * // Create one Session
     * const Session = await prisma.session.create({
     *   data: {
     *     // ... data to create a Session
     *   }
     * })
     * 
     */
    create<T extends SessionCreateArgs>(args: SelectSubset<T, SessionCreateArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Sessions.
     * @param {SessionCreateManyArgs} args - Arguments to create many Sessions.
     * @example
     * // Create many Sessions
     * const session = await prisma.session.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SessionCreateManyArgs>(args?: SelectSubset<T, SessionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Session.
     * @param {SessionDeleteArgs} args - Arguments to delete one Session.
     * @example
     * // Delete one Session
     * const Session = await prisma.session.delete({
     *   where: {
     *     // ... filter to delete one Session
     *   }
     * })
     * 
     */
    delete<T extends SessionDeleteArgs>(args: SelectSubset<T, SessionDeleteArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Session.
     * @param {SessionUpdateArgs} args - Arguments to update one Session.
     * @example
     * // Update one Session
     * const session = await prisma.session.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SessionUpdateArgs>(args: SelectSubset<T, SessionUpdateArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Sessions.
     * @param {SessionDeleteManyArgs} args - Arguments to filter Sessions to delete.
     * @example
     * // Delete a few Sessions
     * const { count } = await prisma.session.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SessionDeleteManyArgs>(args?: SelectSubset<T, SessionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Sessions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Sessions
     * const session = await prisma.session.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SessionUpdateManyArgs>(args: SelectSubset<T, SessionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Session.
     * @param {SessionUpsertArgs} args - Arguments to update or create a Session.
     * @example
     * // Update or create a Session
     * const session = await prisma.session.upsert({
     *   create: {
     *     // ... data to create a Session
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Session we want to update
     *   }
     * })
     */
    upsert<T extends SessionUpsertArgs>(args: SelectSubset<T, SessionUpsertArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Sessions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionCountArgs} args - Arguments to filter Sessions to count.
     * @example
     * // Count the number of Sessions
     * const count = await prisma.session.count({
     *   where: {
     *     // ... the filter for the Sessions we want to count
     *   }
     * })
    **/
    count<T extends SessionCountArgs>(
      args?: Subset<T, SessionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SessionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Session.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SessionAggregateArgs>(args: Subset<T, SessionAggregateArgs>): Prisma.PrismaPromise<GetSessionAggregateType<T>>

    /**
     * Group by Session.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SessionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SessionGroupByArgs['orderBy'] }
        : { orderBy?: SessionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SessionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSessionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Session model
   */
  readonly fields: SessionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Session.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SessionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Session model
   */ 
  interface SessionFieldRefs {
    readonly id: FieldRef<"Session", 'String'>
    readonly userId: FieldRef<"Session", 'String'>
    readonly refreshToken: FieldRef<"Session", 'String'>
    readonly expiresAt: FieldRef<"Session", 'DateTime'>
    readonly createdAt: FieldRef<"Session", 'DateTime'>
    readonly revokedAt: FieldRef<"Session", 'DateTime'>
    readonly ipAddress: FieldRef<"Session", 'String'>
    readonly userAgent: FieldRef<"Session", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Session findUnique
   */
  export type SessionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * Filter, which Session to fetch.
     */
    where: SessionWhereUniqueInput
  }

  /**
   * Session findUniqueOrThrow
   */
  export type SessionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * Filter, which Session to fetch.
     */
    where: SessionWhereUniqueInput
  }

  /**
   * Session findFirst
   */
  export type SessionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * Filter, which Session to fetch.
     */
    where?: SessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sessions to fetch.
     */
    orderBy?: SessionOrderByWithRelationInput | SessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Sessions.
     */
    cursor?: SessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Sessions.
     */
    distinct?: SessionScalarFieldEnum | SessionScalarFieldEnum[]
  }

  /**
   * Session findFirstOrThrow
   */
  export type SessionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * Filter, which Session to fetch.
     */
    where?: SessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sessions to fetch.
     */
    orderBy?: SessionOrderByWithRelationInput | SessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Sessions.
     */
    cursor?: SessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Sessions.
     */
    distinct?: SessionScalarFieldEnum | SessionScalarFieldEnum[]
  }

  /**
   * Session findMany
   */
  export type SessionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * Filter, which Sessions to fetch.
     */
    where?: SessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sessions to fetch.
     */
    orderBy?: SessionOrderByWithRelationInput | SessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Sessions.
     */
    cursor?: SessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sessions.
     */
    skip?: number
    distinct?: SessionScalarFieldEnum | SessionScalarFieldEnum[]
  }

  /**
   * Session create
   */
  export type SessionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * The data needed to create a Session.
     */
    data: XOR<SessionCreateInput, SessionUncheckedCreateInput>
  }

  /**
   * Session createMany
   */
  export type SessionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Sessions.
     */
    data: SessionCreateManyInput | SessionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Session update
   */
  export type SessionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * The data needed to update a Session.
     */
    data: XOR<SessionUpdateInput, SessionUncheckedUpdateInput>
    /**
     * Choose, which Session to update.
     */
    where: SessionWhereUniqueInput
  }

  /**
   * Session updateMany
   */
  export type SessionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Sessions.
     */
    data: XOR<SessionUpdateManyMutationInput, SessionUncheckedUpdateManyInput>
    /**
     * Filter which Sessions to update
     */
    where?: SessionWhereInput
  }

  /**
   * Session upsert
   */
  export type SessionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * The filter to search for the Session to update in case it exists.
     */
    where: SessionWhereUniqueInput
    /**
     * In case the Session found by the `where` argument doesn't exist, create a new Session with this data.
     */
    create: XOR<SessionCreateInput, SessionUncheckedCreateInput>
    /**
     * In case the Session was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SessionUpdateInput, SessionUncheckedUpdateInput>
  }

  /**
   * Session delete
   */
  export type SessionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * Filter which Session to delete.
     */
    where: SessionWhereUniqueInput
  }

  /**
   * Session deleteMany
   */
  export type SessionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Sessions to delete
     */
    where?: SessionWhereInput
  }

  /**
   * Session without action
   */
  export type SessionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
  }


  /**
   * Model PasswordResetToken
   */

  export type AggregatePasswordResetToken = {
    _count: PasswordResetTokenCountAggregateOutputType | null
    _min: PasswordResetTokenMinAggregateOutputType | null
    _max: PasswordResetTokenMaxAggregateOutputType | null
  }

  export type PasswordResetTokenMinAggregateOutputType = {
    id: string | null
    userId: string | null
    otp: string | null
    expiresAt: Date | null
    usedAt: Date | null
    createdAt: Date | null
  }

  export type PasswordResetTokenMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    otp: string | null
    expiresAt: Date | null
    usedAt: Date | null
    createdAt: Date | null
  }

  export type PasswordResetTokenCountAggregateOutputType = {
    id: number
    userId: number
    otp: number
    expiresAt: number
    usedAt: number
    createdAt: number
    _all: number
  }


  export type PasswordResetTokenMinAggregateInputType = {
    id?: true
    userId?: true
    otp?: true
    expiresAt?: true
    usedAt?: true
    createdAt?: true
  }

  export type PasswordResetTokenMaxAggregateInputType = {
    id?: true
    userId?: true
    otp?: true
    expiresAt?: true
    usedAt?: true
    createdAt?: true
  }

  export type PasswordResetTokenCountAggregateInputType = {
    id?: true
    userId?: true
    otp?: true
    expiresAt?: true
    usedAt?: true
    createdAt?: true
    _all?: true
  }

  export type PasswordResetTokenAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PasswordResetToken to aggregate.
     */
    where?: PasswordResetTokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PasswordResetTokens to fetch.
     */
    orderBy?: PasswordResetTokenOrderByWithRelationInput | PasswordResetTokenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PasswordResetTokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PasswordResetTokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PasswordResetTokens.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PasswordResetTokens
    **/
    _count?: true | PasswordResetTokenCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PasswordResetTokenMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PasswordResetTokenMaxAggregateInputType
  }

  export type GetPasswordResetTokenAggregateType<T extends PasswordResetTokenAggregateArgs> = {
        [P in keyof T & keyof AggregatePasswordResetToken]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePasswordResetToken[P]>
      : GetScalarType<T[P], AggregatePasswordResetToken[P]>
  }




  export type PasswordResetTokenGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PasswordResetTokenWhereInput
    orderBy?: PasswordResetTokenOrderByWithAggregationInput | PasswordResetTokenOrderByWithAggregationInput[]
    by: PasswordResetTokenScalarFieldEnum[] | PasswordResetTokenScalarFieldEnum
    having?: PasswordResetTokenScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PasswordResetTokenCountAggregateInputType | true
    _min?: PasswordResetTokenMinAggregateInputType
    _max?: PasswordResetTokenMaxAggregateInputType
  }

  export type PasswordResetTokenGroupByOutputType = {
    id: string
    userId: string
    otp: string
    expiresAt: Date
    usedAt: Date | null
    createdAt: Date
    _count: PasswordResetTokenCountAggregateOutputType | null
    _min: PasswordResetTokenMinAggregateOutputType | null
    _max: PasswordResetTokenMaxAggregateOutputType | null
  }

  type GetPasswordResetTokenGroupByPayload<T extends PasswordResetTokenGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PasswordResetTokenGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PasswordResetTokenGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PasswordResetTokenGroupByOutputType[P]>
            : GetScalarType<T[P], PasswordResetTokenGroupByOutputType[P]>
        }
      >
    >


  export type PasswordResetTokenSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    otp?: boolean
    expiresAt?: boolean
    usedAt?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["passwordResetToken"]>


  export type PasswordResetTokenSelectScalar = {
    id?: boolean
    userId?: boolean
    otp?: boolean
    expiresAt?: boolean
    usedAt?: boolean
    createdAt?: boolean
  }

  export type PasswordResetTokenInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $PasswordResetTokenPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "PasswordResetToken"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      otp: string
      expiresAt: Date
      usedAt: Date | null
      createdAt: Date
    }, ExtArgs["result"]["passwordResetToken"]>
    composites: {}
  }

  type PasswordResetTokenGetPayload<S extends boolean | null | undefined | PasswordResetTokenDefaultArgs> = $Result.GetResult<Prisma.$PasswordResetTokenPayload, S>

  type PasswordResetTokenCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<PasswordResetTokenFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: PasswordResetTokenCountAggregateInputType | true
    }

  export interface PasswordResetTokenDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PasswordResetToken'], meta: { name: 'PasswordResetToken' } }
    /**
     * Find zero or one PasswordResetToken that matches the filter.
     * @param {PasswordResetTokenFindUniqueArgs} args - Arguments to find a PasswordResetToken
     * @example
     * // Get one PasswordResetToken
     * const passwordResetToken = await prisma.passwordResetToken.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PasswordResetTokenFindUniqueArgs>(args: SelectSubset<T, PasswordResetTokenFindUniqueArgs<ExtArgs>>): Prisma__PasswordResetTokenClient<$Result.GetResult<Prisma.$PasswordResetTokenPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one PasswordResetToken that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {PasswordResetTokenFindUniqueOrThrowArgs} args - Arguments to find a PasswordResetToken
     * @example
     * // Get one PasswordResetToken
     * const passwordResetToken = await prisma.passwordResetToken.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PasswordResetTokenFindUniqueOrThrowArgs>(args: SelectSubset<T, PasswordResetTokenFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PasswordResetTokenClient<$Result.GetResult<Prisma.$PasswordResetTokenPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first PasswordResetToken that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PasswordResetTokenFindFirstArgs} args - Arguments to find a PasswordResetToken
     * @example
     * // Get one PasswordResetToken
     * const passwordResetToken = await prisma.passwordResetToken.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PasswordResetTokenFindFirstArgs>(args?: SelectSubset<T, PasswordResetTokenFindFirstArgs<ExtArgs>>): Prisma__PasswordResetTokenClient<$Result.GetResult<Prisma.$PasswordResetTokenPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first PasswordResetToken that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PasswordResetTokenFindFirstOrThrowArgs} args - Arguments to find a PasswordResetToken
     * @example
     * // Get one PasswordResetToken
     * const passwordResetToken = await prisma.passwordResetToken.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PasswordResetTokenFindFirstOrThrowArgs>(args?: SelectSubset<T, PasswordResetTokenFindFirstOrThrowArgs<ExtArgs>>): Prisma__PasswordResetTokenClient<$Result.GetResult<Prisma.$PasswordResetTokenPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more PasswordResetTokens that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PasswordResetTokenFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PasswordResetTokens
     * const passwordResetTokens = await prisma.passwordResetToken.findMany()
     * 
     * // Get first 10 PasswordResetTokens
     * const passwordResetTokens = await prisma.passwordResetToken.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const passwordResetTokenWithIdOnly = await prisma.passwordResetToken.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PasswordResetTokenFindManyArgs>(args?: SelectSubset<T, PasswordResetTokenFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PasswordResetTokenPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a PasswordResetToken.
     * @param {PasswordResetTokenCreateArgs} args - Arguments to create a PasswordResetToken.
     * @example
     * // Create one PasswordResetToken
     * const PasswordResetToken = await prisma.passwordResetToken.create({
     *   data: {
     *     // ... data to create a PasswordResetToken
     *   }
     * })
     * 
     */
    create<T extends PasswordResetTokenCreateArgs>(args: SelectSubset<T, PasswordResetTokenCreateArgs<ExtArgs>>): Prisma__PasswordResetTokenClient<$Result.GetResult<Prisma.$PasswordResetTokenPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many PasswordResetTokens.
     * @param {PasswordResetTokenCreateManyArgs} args - Arguments to create many PasswordResetTokens.
     * @example
     * // Create many PasswordResetTokens
     * const passwordResetToken = await prisma.passwordResetToken.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PasswordResetTokenCreateManyArgs>(args?: SelectSubset<T, PasswordResetTokenCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a PasswordResetToken.
     * @param {PasswordResetTokenDeleteArgs} args - Arguments to delete one PasswordResetToken.
     * @example
     * // Delete one PasswordResetToken
     * const PasswordResetToken = await prisma.passwordResetToken.delete({
     *   where: {
     *     // ... filter to delete one PasswordResetToken
     *   }
     * })
     * 
     */
    delete<T extends PasswordResetTokenDeleteArgs>(args: SelectSubset<T, PasswordResetTokenDeleteArgs<ExtArgs>>): Prisma__PasswordResetTokenClient<$Result.GetResult<Prisma.$PasswordResetTokenPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one PasswordResetToken.
     * @param {PasswordResetTokenUpdateArgs} args - Arguments to update one PasswordResetToken.
     * @example
     * // Update one PasswordResetToken
     * const passwordResetToken = await prisma.passwordResetToken.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PasswordResetTokenUpdateArgs>(args: SelectSubset<T, PasswordResetTokenUpdateArgs<ExtArgs>>): Prisma__PasswordResetTokenClient<$Result.GetResult<Prisma.$PasswordResetTokenPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more PasswordResetTokens.
     * @param {PasswordResetTokenDeleteManyArgs} args - Arguments to filter PasswordResetTokens to delete.
     * @example
     * // Delete a few PasswordResetTokens
     * const { count } = await prisma.passwordResetToken.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PasswordResetTokenDeleteManyArgs>(args?: SelectSubset<T, PasswordResetTokenDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PasswordResetTokens.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PasswordResetTokenUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PasswordResetTokens
     * const passwordResetToken = await prisma.passwordResetToken.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PasswordResetTokenUpdateManyArgs>(args: SelectSubset<T, PasswordResetTokenUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one PasswordResetToken.
     * @param {PasswordResetTokenUpsertArgs} args - Arguments to update or create a PasswordResetToken.
     * @example
     * // Update or create a PasswordResetToken
     * const passwordResetToken = await prisma.passwordResetToken.upsert({
     *   create: {
     *     // ... data to create a PasswordResetToken
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PasswordResetToken we want to update
     *   }
     * })
     */
    upsert<T extends PasswordResetTokenUpsertArgs>(args: SelectSubset<T, PasswordResetTokenUpsertArgs<ExtArgs>>): Prisma__PasswordResetTokenClient<$Result.GetResult<Prisma.$PasswordResetTokenPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of PasswordResetTokens.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PasswordResetTokenCountArgs} args - Arguments to filter PasswordResetTokens to count.
     * @example
     * // Count the number of PasswordResetTokens
     * const count = await prisma.passwordResetToken.count({
     *   where: {
     *     // ... the filter for the PasswordResetTokens we want to count
     *   }
     * })
    **/
    count<T extends PasswordResetTokenCountArgs>(
      args?: Subset<T, PasswordResetTokenCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PasswordResetTokenCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PasswordResetToken.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PasswordResetTokenAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PasswordResetTokenAggregateArgs>(args: Subset<T, PasswordResetTokenAggregateArgs>): Prisma.PrismaPromise<GetPasswordResetTokenAggregateType<T>>

    /**
     * Group by PasswordResetToken.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PasswordResetTokenGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PasswordResetTokenGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PasswordResetTokenGroupByArgs['orderBy'] }
        : { orderBy?: PasswordResetTokenGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PasswordResetTokenGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPasswordResetTokenGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the PasswordResetToken model
   */
  readonly fields: PasswordResetTokenFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PasswordResetToken.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PasswordResetTokenClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the PasswordResetToken model
   */ 
  interface PasswordResetTokenFieldRefs {
    readonly id: FieldRef<"PasswordResetToken", 'String'>
    readonly userId: FieldRef<"PasswordResetToken", 'String'>
    readonly otp: FieldRef<"PasswordResetToken", 'String'>
    readonly expiresAt: FieldRef<"PasswordResetToken", 'DateTime'>
    readonly usedAt: FieldRef<"PasswordResetToken", 'DateTime'>
    readonly createdAt: FieldRef<"PasswordResetToken", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * PasswordResetToken findUnique
   */
  export type PasswordResetTokenFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PasswordResetToken
     */
    select?: PasswordResetTokenSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PasswordResetTokenInclude<ExtArgs> | null
    /**
     * Filter, which PasswordResetToken to fetch.
     */
    where: PasswordResetTokenWhereUniqueInput
  }

  /**
   * PasswordResetToken findUniqueOrThrow
   */
  export type PasswordResetTokenFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PasswordResetToken
     */
    select?: PasswordResetTokenSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PasswordResetTokenInclude<ExtArgs> | null
    /**
     * Filter, which PasswordResetToken to fetch.
     */
    where: PasswordResetTokenWhereUniqueInput
  }

  /**
   * PasswordResetToken findFirst
   */
  export type PasswordResetTokenFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PasswordResetToken
     */
    select?: PasswordResetTokenSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PasswordResetTokenInclude<ExtArgs> | null
    /**
     * Filter, which PasswordResetToken to fetch.
     */
    where?: PasswordResetTokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PasswordResetTokens to fetch.
     */
    orderBy?: PasswordResetTokenOrderByWithRelationInput | PasswordResetTokenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PasswordResetTokens.
     */
    cursor?: PasswordResetTokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PasswordResetTokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PasswordResetTokens.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PasswordResetTokens.
     */
    distinct?: PasswordResetTokenScalarFieldEnum | PasswordResetTokenScalarFieldEnum[]
  }

  /**
   * PasswordResetToken findFirstOrThrow
   */
  export type PasswordResetTokenFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PasswordResetToken
     */
    select?: PasswordResetTokenSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PasswordResetTokenInclude<ExtArgs> | null
    /**
     * Filter, which PasswordResetToken to fetch.
     */
    where?: PasswordResetTokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PasswordResetTokens to fetch.
     */
    orderBy?: PasswordResetTokenOrderByWithRelationInput | PasswordResetTokenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PasswordResetTokens.
     */
    cursor?: PasswordResetTokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PasswordResetTokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PasswordResetTokens.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PasswordResetTokens.
     */
    distinct?: PasswordResetTokenScalarFieldEnum | PasswordResetTokenScalarFieldEnum[]
  }

  /**
   * PasswordResetToken findMany
   */
  export type PasswordResetTokenFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PasswordResetToken
     */
    select?: PasswordResetTokenSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PasswordResetTokenInclude<ExtArgs> | null
    /**
     * Filter, which PasswordResetTokens to fetch.
     */
    where?: PasswordResetTokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PasswordResetTokens to fetch.
     */
    orderBy?: PasswordResetTokenOrderByWithRelationInput | PasswordResetTokenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PasswordResetTokens.
     */
    cursor?: PasswordResetTokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PasswordResetTokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PasswordResetTokens.
     */
    skip?: number
    distinct?: PasswordResetTokenScalarFieldEnum | PasswordResetTokenScalarFieldEnum[]
  }

  /**
   * PasswordResetToken create
   */
  export type PasswordResetTokenCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PasswordResetToken
     */
    select?: PasswordResetTokenSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PasswordResetTokenInclude<ExtArgs> | null
    /**
     * The data needed to create a PasswordResetToken.
     */
    data: XOR<PasswordResetTokenCreateInput, PasswordResetTokenUncheckedCreateInput>
  }

  /**
   * PasswordResetToken createMany
   */
  export type PasswordResetTokenCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many PasswordResetTokens.
     */
    data: PasswordResetTokenCreateManyInput | PasswordResetTokenCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * PasswordResetToken update
   */
  export type PasswordResetTokenUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PasswordResetToken
     */
    select?: PasswordResetTokenSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PasswordResetTokenInclude<ExtArgs> | null
    /**
     * The data needed to update a PasswordResetToken.
     */
    data: XOR<PasswordResetTokenUpdateInput, PasswordResetTokenUncheckedUpdateInput>
    /**
     * Choose, which PasswordResetToken to update.
     */
    where: PasswordResetTokenWhereUniqueInput
  }

  /**
   * PasswordResetToken updateMany
   */
  export type PasswordResetTokenUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update PasswordResetTokens.
     */
    data: XOR<PasswordResetTokenUpdateManyMutationInput, PasswordResetTokenUncheckedUpdateManyInput>
    /**
     * Filter which PasswordResetTokens to update
     */
    where?: PasswordResetTokenWhereInput
  }

  /**
   * PasswordResetToken upsert
   */
  export type PasswordResetTokenUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PasswordResetToken
     */
    select?: PasswordResetTokenSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PasswordResetTokenInclude<ExtArgs> | null
    /**
     * The filter to search for the PasswordResetToken to update in case it exists.
     */
    where: PasswordResetTokenWhereUniqueInput
    /**
     * In case the PasswordResetToken found by the `where` argument doesn't exist, create a new PasswordResetToken with this data.
     */
    create: XOR<PasswordResetTokenCreateInput, PasswordResetTokenUncheckedCreateInput>
    /**
     * In case the PasswordResetToken was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PasswordResetTokenUpdateInput, PasswordResetTokenUncheckedUpdateInput>
  }

  /**
   * PasswordResetToken delete
   */
  export type PasswordResetTokenDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PasswordResetToken
     */
    select?: PasswordResetTokenSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PasswordResetTokenInclude<ExtArgs> | null
    /**
     * Filter which PasswordResetToken to delete.
     */
    where: PasswordResetTokenWhereUniqueInput
  }

  /**
   * PasswordResetToken deleteMany
   */
  export type PasswordResetTokenDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PasswordResetTokens to delete
     */
    where?: PasswordResetTokenWhereInput
  }

  /**
   * PasswordResetToken without action
   */
  export type PasswordResetTokenDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PasswordResetToken
     */
    select?: PasswordResetTokenSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PasswordResetTokenInclude<ExtArgs> | null
  }


  /**
   * Model Movie
   */

  export type AggregateMovie = {
    _count: MovieCountAggregateOutputType | null
    _avg: MovieAvgAggregateOutputType | null
    _sum: MovieSumAggregateOutputType | null
    _min: MovieMinAggregateOutputType | null
    _max: MovieMaxAggregateOutputType | null
  }

  export type MovieAvgAggregateOutputType = {
    durationMinutes: number | null
    releaseYear: number | null
    rating: Decimal | null
  }

  export type MovieSumAggregateOutputType = {
    durationMinutes: number | null
    releaseYear: number | null
    rating: Decimal | null
  }

  export type MovieMinAggregateOutputType = {
    id: string | null
    title: string | null
    slug: string | null
    status: $Enums.MovieStatus | null
    durationMinutes: number | null
    synopsis: string | null
    tagline: string | null
    posterUrl: string | null
    backdropUrl: string | null
    releaseYear: number | null
    rating: Decimal | null
    isTrending: boolean | null
    isTopPick: boolean | null
    isUpcoming: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type MovieMaxAggregateOutputType = {
    id: string | null
    title: string | null
    slug: string | null
    status: $Enums.MovieStatus | null
    durationMinutes: number | null
    synopsis: string | null
    tagline: string | null
    posterUrl: string | null
    backdropUrl: string | null
    releaseYear: number | null
    rating: Decimal | null
    isTrending: boolean | null
    isTopPick: boolean | null
    isUpcoming: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type MovieCountAggregateOutputType = {
    id: number
    title: number
    slug: number
    status: number
    durationMinutes: number
    synopsis: number
    tagline: number
    posterUrl: number
    backdropUrl: number
    releaseYear: number
    rating: number
    isTrending: number
    isTopPick: number
    isUpcoming: number
    metadata: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type MovieAvgAggregateInputType = {
    durationMinutes?: true
    releaseYear?: true
    rating?: true
  }

  export type MovieSumAggregateInputType = {
    durationMinutes?: true
    releaseYear?: true
    rating?: true
  }

  export type MovieMinAggregateInputType = {
    id?: true
    title?: true
    slug?: true
    status?: true
    durationMinutes?: true
    synopsis?: true
    tagline?: true
    posterUrl?: true
    backdropUrl?: true
    releaseYear?: true
    rating?: true
    isTrending?: true
    isTopPick?: true
    isUpcoming?: true
    createdAt?: true
    updatedAt?: true
  }

  export type MovieMaxAggregateInputType = {
    id?: true
    title?: true
    slug?: true
    status?: true
    durationMinutes?: true
    synopsis?: true
    tagline?: true
    posterUrl?: true
    backdropUrl?: true
    releaseYear?: true
    rating?: true
    isTrending?: true
    isTopPick?: true
    isUpcoming?: true
    createdAt?: true
    updatedAt?: true
  }

  export type MovieCountAggregateInputType = {
    id?: true
    title?: true
    slug?: true
    status?: true
    durationMinutes?: true
    synopsis?: true
    tagline?: true
    posterUrl?: true
    backdropUrl?: true
    releaseYear?: true
    rating?: true
    isTrending?: true
    isTopPick?: true
    isUpcoming?: true
    metadata?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type MovieAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Movie to aggregate.
     */
    where?: MovieWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Movies to fetch.
     */
    orderBy?: MovieOrderByWithRelationInput | MovieOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: MovieWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Movies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Movies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Movies
    **/
    _count?: true | MovieCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: MovieAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: MovieSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MovieMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MovieMaxAggregateInputType
  }

  export type GetMovieAggregateType<T extends MovieAggregateArgs> = {
        [P in keyof T & keyof AggregateMovie]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMovie[P]>
      : GetScalarType<T[P], AggregateMovie[P]>
  }




  export type MovieGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MovieWhereInput
    orderBy?: MovieOrderByWithAggregationInput | MovieOrderByWithAggregationInput[]
    by: MovieScalarFieldEnum[] | MovieScalarFieldEnum
    having?: MovieScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MovieCountAggregateInputType | true
    _avg?: MovieAvgAggregateInputType
    _sum?: MovieSumAggregateInputType
    _min?: MovieMinAggregateInputType
    _max?: MovieMaxAggregateInputType
  }

  export type MovieGroupByOutputType = {
    id: string
    title: string
    slug: string
    status: $Enums.MovieStatus
    durationMinutes: number | null
    synopsis: string | null
    tagline: string | null
    posterUrl: string | null
    backdropUrl: string | null
    releaseYear: number | null
    rating: Decimal | null
    isTrending: boolean
    isTopPick: boolean
    isUpcoming: boolean
    metadata: JsonValue | null
    createdAt: Date
    updatedAt: Date
    _count: MovieCountAggregateOutputType | null
    _avg: MovieAvgAggregateOutputType | null
    _sum: MovieSumAggregateOutputType | null
    _min: MovieMinAggregateOutputType | null
    _max: MovieMaxAggregateOutputType | null
  }

  type GetMovieGroupByPayload<T extends MovieGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MovieGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MovieGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MovieGroupByOutputType[P]>
            : GetScalarType<T[P], MovieGroupByOutputType[P]>
        }
      >
    >


  export type MovieSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    slug?: boolean
    status?: boolean
    durationMinutes?: boolean
    synopsis?: boolean
    tagline?: boolean
    posterUrl?: boolean
    backdropUrl?: boolean
    releaseYear?: boolean
    rating?: boolean
    isTrending?: boolean
    isTopPick?: boolean
    isUpcoming?: boolean
    metadata?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    genres?: boolean | Movie$genresArgs<ExtArgs>
    languages?: boolean | Movie$languagesArgs<ExtArgs>
    showtimes?: boolean | Movie$showtimesArgs<ExtArgs>
    _count?: boolean | MovieCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["movie"]>


  export type MovieSelectScalar = {
    id?: boolean
    title?: boolean
    slug?: boolean
    status?: boolean
    durationMinutes?: boolean
    synopsis?: boolean
    tagline?: boolean
    posterUrl?: boolean
    backdropUrl?: boolean
    releaseYear?: boolean
    rating?: boolean
    isTrending?: boolean
    isTopPick?: boolean
    isUpcoming?: boolean
    metadata?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type MovieInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    genres?: boolean | Movie$genresArgs<ExtArgs>
    languages?: boolean | Movie$languagesArgs<ExtArgs>
    showtimes?: boolean | Movie$showtimesArgs<ExtArgs>
    _count?: boolean | MovieCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $MoviePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Movie"
    objects: {
      genres: Prisma.$MovieGenrePayload<ExtArgs>[]
      languages: Prisma.$MovieLanguagePayload<ExtArgs>[]
      showtimes: Prisma.$ShowtimePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      title: string
      slug: string
      status: $Enums.MovieStatus
      durationMinutes: number | null
      synopsis: string | null
      tagline: string | null
      posterUrl: string | null
      backdropUrl: string | null
      releaseYear: number | null
      rating: Prisma.Decimal | null
      isTrending: boolean
      isTopPick: boolean
      isUpcoming: boolean
      metadata: Prisma.JsonValue | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["movie"]>
    composites: {}
  }

  type MovieGetPayload<S extends boolean | null | undefined | MovieDefaultArgs> = $Result.GetResult<Prisma.$MoviePayload, S>

  type MovieCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<MovieFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: MovieCountAggregateInputType | true
    }

  export interface MovieDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Movie'], meta: { name: 'Movie' } }
    /**
     * Find zero or one Movie that matches the filter.
     * @param {MovieFindUniqueArgs} args - Arguments to find a Movie
     * @example
     * // Get one Movie
     * const movie = await prisma.movie.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends MovieFindUniqueArgs>(args: SelectSubset<T, MovieFindUniqueArgs<ExtArgs>>): Prisma__MovieClient<$Result.GetResult<Prisma.$MoviePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Movie that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {MovieFindUniqueOrThrowArgs} args - Arguments to find a Movie
     * @example
     * // Get one Movie
     * const movie = await prisma.movie.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends MovieFindUniqueOrThrowArgs>(args: SelectSubset<T, MovieFindUniqueOrThrowArgs<ExtArgs>>): Prisma__MovieClient<$Result.GetResult<Prisma.$MoviePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Movie that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MovieFindFirstArgs} args - Arguments to find a Movie
     * @example
     * // Get one Movie
     * const movie = await prisma.movie.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends MovieFindFirstArgs>(args?: SelectSubset<T, MovieFindFirstArgs<ExtArgs>>): Prisma__MovieClient<$Result.GetResult<Prisma.$MoviePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Movie that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MovieFindFirstOrThrowArgs} args - Arguments to find a Movie
     * @example
     * // Get one Movie
     * const movie = await prisma.movie.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends MovieFindFirstOrThrowArgs>(args?: SelectSubset<T, MovieFindFirstOrThrowArgs<ExtArgs>>): Prisma__MovieClient<$Result.GetResult<Prisma.$MoviePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Movies that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MovieFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Movies
     * const movies = await prisma.movie.findMany()
     * 
     * // Get first 10 Movies
     * const movies = await prisma.movie.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const movieWithIdOnly = await prisma.movie.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends MovieFindManyArgs>(args?: SelectSubset<T, MovieFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MoviePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Movie.
     * @param {MovieCreateArgs} args - Arguments to create a Movie.
     * @example
     * // Create one Movie
     * const Movie = await prisma.movie.create({
     *   data: {
     *     // ... data to create a Movie
     *   }
     * })
     * 
     */
    create<T extends MovieCreateArgs>(args: SelectSubset<T, MovieCreateArgs<ExtArgs>>): Prisma__MovieClient<$Result.GetResult<Prisma.$MoviePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Movies.
     * @param {MovieCreateManyArgs} args - Arguments to create many Movies.
     * @example
     * // Create many Movies
     * const movie = await prisma.movie.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends MovieCreateManyArgs>(args?: SelectSubset<T, MovieCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Movie.
     * @param {MovieDeleteArgs} args - Arguments to delete one Movie.
     * @example
     * // Delete one Movie
     * const Movie = await prisma.movie.delete({
     *   where: {
     *     // ... filter to delete one Movie
     *   }
     * })
     * 
     */
    delete<T extends MovieDeleteArgs>(args: SelectSubset<T, MovieDeleteArgs<ExtArgs>>): Prisma__MovieClient<$Result.GetResult<Prisma.$MoviePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Movie.
     * @param {MovieUpdateArgs} args - Arguments to update one Movie.
     * @example
     * // Update one Movie
     * const movie = await prisma.movie.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends MovieUpdateArgs>(args: SelectSubset<T, MovieUpdateArgs<ExtArgs>>): Prisma__MovieClient<$Result.GetResult<Prisma.$MoviePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Movies.
     * @param {MovieDeleteManyArgs} args - Arguments to filter Movies to delete.
     * @example
     * // Delete a few Movies
     * const { count } = await prisma.movie.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends MovieDeleteManyArgs>(args?: SelectSubset<T, MovieDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Movies.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MovieUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Movies
     * const movie = await prisma.movie.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends MovieUpdateManyArgs>(args: SelectSubset<T, MovieUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Movie.
     * @param {MovieUpsertArgs} args - Arguments to update or create a Movie.
     * @example
     * // Update or create a Movie
     * const movie = await prisma.movie.upsert({
     *   create: {
     *     // ... data to create a Movie
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Movie we want to update
     *   }
     * })
     */
    upsert<T extends MovieUpsertArgs>(args: SelectSubset<T, MovieUpsertArgs<ExtArgs>>): Prisma__MovieClient<$Result.GetResult<Prisma.$MoviePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Movies.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MovieCountArgs} args - Arguments to filter Movies to count.
     * @example
     * // Count the number of Movies
     * const count = await prisma.movie.count({
     *   where: {
     *     // ... the filter for the Movies we want to count
     *   }
     * })
    **/
    count<T extends MovieCountArgs>(
      args?: Subset<T, MovieCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MovieCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Movie.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MovieAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MovieAggregateArgs>(args: Subset<T, MovieAggregateArgs>): Prisma.PrismaPromise<GetMovieAggregateType<T>>

    /**
     * Group by Movie.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MovieGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MovieGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MovieGroupByArgs['orderBy'] }
        : { orderBy?: MovieGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MovieGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMovieGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Movie model
   */
  readonly fields: MovieFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Movie.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__MovieClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    genres<T extends Movie$genresArgs<ExtArgs> = {}>(args?: Subset<T, Movie$genresArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MovieGenrePayload<ExtArgs>, T, "findMany"> | Null>
    languages<T extends Movie$languagesArgs<ExtArgs> = {}>(args?: Subset<T, Movie$languagesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MovieLanguagePayload<ExtArgs>, T, "findMany"> | Null>
    showtimes<T extends Movie$showtimesArgs<ExtArgs> = {}>(args?: Subset<T, Movie$showtimesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ShowtimePayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Movie model
   */ 
  interface MovieFieldRefs {
    readonly id: FieldRef<"Movie", 'String'>
    readonly title: FieldRef<"Movie", 'String'>
    readonly slug: FieldRef<"Movie", 'String'>
    readonly status: FieldRef<"Movie", 'MovieStatus'>
    readonly durationMinutes: FieldRef<"Movie", 'Int'>
    readonly synopsis: FieldRef<"Movie", 'String'>
    readonly tagline: FieldRef<"Movie", 'String'>
    readonly posterUrl: FieldRef<"Movie", 'String'>
    readonly backdropUrl: FieldRef<"Movie", 'String'>
    readonly releaseYear: FieldRef<"Movie", 'Int'>
    readonly rating: FieldRef<"Movie", 'Decimal'>
    readonly isTrending: FieldRef<"Movie", 'Boolean'>
    readonly isTopPick: FieldRef<"Movie", 'Boolean'>
    readonly isUpcoming: FieldRef<"Movie", 'Boolean'>
    readonly metadata: FieldRef<"Movie", 'Json'>
    readonly createdAt: FieldRef<"Movie", 'DateTime'>
    readonly updatedAt: FieldRef<"Movie", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Movie findUnique
   */
  export type MovieFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Movie
     */
    select?: MovieSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MovieInclude<ExtArgs> | null
    /**
     * Filter, which Movie to fetch.
     */
    where: MovieWhereUniqueInput
  }

  /**
   * Movie findUniqueOrThrow
   */
  export type MovieFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Movie
     */
    select?: MovieSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MovieInclude<ExtArgs> | null
    /**
     * Filter, which Movie to fetch.
     */
    where: MovieWhereUniqueInput
  }

  /**
   * Movie findFirst
   */
  export type MovieFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Movie
     */
    select?: MovieSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MovieInclude<ExtArgs> | null
    /**
     * Filter, which Movie to fetch.
     */
    where?: MovieWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Movies to fetch.
     */
    orderBy?: MovieOrderByWithRelationInput | MovieOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Movies.
     */
    cursor?: MovieWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Movies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Movies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Movies.
     */
    distinct?: MovieScalarFieldEnum | MovieScalarFieldEnum[]
  }

  /**
   * Movie findFirstOrThrow
   */
  export type MovieFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Movie
     */
    select?: MovieSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MovieInclude<ExtArgs> | null
    /**
     * Filter, which Movie to fetch.
     */
    where?: MovieWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Movies to fetch.
     */
    orderBy?: MovieOrderByWithRelationInput | MovieOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Movies.
     */
    cursor?: MovieWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Movies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Movies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Movies.
     */
    distinct?: MovieScalarFieldEnum | MovieScalarFieldEnum[]
  }

  /**
   * Movie findMany
   */
  export type MovieFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Movie
     */
    select?: MovieSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MovieInclude<ExtArgs> | null
    /**
     * Filter, which Movies to fetch.
     */
    where?: MovieWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Movies to fetch.
     */
    orderBy?: MovieOrderByWithRelationInput | MovieOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Movies.
     */
    cursor?: MovieWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Movies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Movies.
     */
    skip?: number
    distinct?: MovieScalarFieldEnum | MovieScalarFieldEnum[]
  }

  /**
   * Movie create
   */
  export type MovieCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Movie
     */
    select?: MovieSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MovieInclude<ExtArgs> | null
    /**
     * The data needed to create a Movie.
     */
    data: XOR<MovieCreateInput, MovieUncheckedCreateInput>
  }

  /**
   * Movie createMany
   */
  export type MovieCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Movies.
     */
    data: MovieCreateManyInput | MovieCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Movie update
   */
  export type MovieUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Movie
     */
    select?: MovieSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MovieInclude<ExtArgs> | null
    /**
     * The data needed to update a Movie.
     */
    data: XOR<MovieUpdateInput, MovieUncheckedUpdateInput>
    /**
     * Choose, which Movie to update.
     */
    where: MovieWhereUniqueInput
  }

  /**
   * Movie updateMany
   */
  export type MovieUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Movies.
     */
    data: XOR<MovieUpdateManyMutationInput, MovieUncheckedUpdateManyInput>
    /**
     * Filter which Movies to update
     */
    where?: MovieWhereInput
  }

  /**
   * Movie upsert
   */
  export type MovieUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Movie
     */
    select?: MovieSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MovieInclude<ExtArgs> | null
    /**
     * The filter to search for the Movie to update in case it exists.
     */
    where: MovieWhereUniqueInput
    /**
     * In case the Movie found by the `where` argument doesn't exist, create a new Movie with this data.
     */
    create: XOR<MovieCreateInput, MovieUncheckedCreateInput>
    /**
     * In case the Movie was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MovieUpdateInput, MovieUncheckedUpdateInput>
  }

  /**
   * Movie delete
   */
  export type MovieDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Movie
     */
    select?: MovieSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MovieInclude<ExtArgs> | null
    /**
     * Filter which Movie to delete.
     */
    where: MovieWhereUniqueInput
  }

  /**
   * Movie deleteMany
   */
  export type MovieDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Movies to delete
     */
    where?: MovieWhereInput
  }

  /**
   * Movie.genres
   */
  export type Movie$genresArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MovieGenre
     */
    select?: MovieGenreSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MovieGenreInclude<ExtArgs> | null
    where?: MovieGenreWhereInput
    orderBy?: MovieGenreOrderByWithRelationInput | MovieGenreOrderByWithRelationInput[]
    cursor?: MovieGenreWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MovieGenreScalarFieldEnum | MovieGenreScalarFieldEnum[]
  }

  /**
   * Movie.languages
   */
  export type Movie$languagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MovieLanguage
     */
    select?: MovieLanguageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MovieLanguageInclude<ExtArgs> | null
    where?: MovieLanguageWhereInput
    orderBy?: MovieLanguageOrderByWithRelationInput | MovieLanguageOrderByWithRelationInput[]
    cursor?: MovieLanguageWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MovieLanguageScalarFieldEnum | MovieLanguageScalarFieldEnum[]
  }

  /**
   * Movie.showtimes
   */
  export type Movie$showtimesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Showtime
     */
    select?: ShowtimeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShowtimeInclude<ExtArgs> | null
    where?: ShowtimeWhereInput
    orderBy?: ShowtimeOrderByWithRelationInput | ShowtimeOrderByWithRelationInput[]
    cursor?: ShowtimeWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ShowtimeScalarFieldEnum | ShowtimeScalarFieldEnum[]
  }

  /**
   * Movie without action
   */
  export type MovieDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Movie
     */
    select?: MovieSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MovieInclude<ExtArgs> | null
  }


  /**
   * Model MovieGenre
   */

  export type AggregateMovieGenre = {
    _count: MovieGenreCountAggregateOutputType | null
    _avg: MovieGenreAvgAggregateOutputType | null
    _sum: MovieGenreSumAggregateOutputType | null
    _min: MovieGenreMinAggregateOutputType | null
    _max: MovieGenreMaxAggregateOutputType | null
  }

  export type MovieGenreAvgAggregateOutputType = {
    id: number | null
  }

  export type MovieGenreSumAggregateOutputType = {
    id: number | null
  }

  export type MovieGenreMinAggregateOutputType = {
    id: number | null
    movieId: string | null
    name: string | null
  }

  export type MovieGenreMaxAggregateOutputType = {
    id: number | null
    movieId: string | null
    name: string | null
  }

  export type MovieGenreCountAggregateOutputType = {
    id: number
    movieId: number
    name: number
    _all: number
  }


  export type MovieGenreAvgAggregateInputType = {
    id?: true
  }

  export type MovieGenreSumAggregateInputType = {
    id?: true
  }

  export type MovieGenreMinAggregateInputType = {
    id?: true
    movieId?: true
    name?: true
  }

  export type MovieGenreMaxAggregateInputType = {
    id?: true
    movieId?: true
    name?: true
  }

  export type MovieGenreCountAggregateInputType = {
    id?: true
    movieId?: true
    name?: true
    _all?: true
  }

  export type MovieGenreAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MovieGenre to aggregate.
     */
    where?: MovieGenreWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MovieGenres to fetch.
     */
    orderBy?: MovieGenreOrderByWithRelationInput | MovieGenreOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: MovieGenreWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MovieGenres from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MovieGenres.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned MovieGenres
    **/
    _count?: true | MovieGenreCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: MovieGenreAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: MovieGenreSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MovieGenreMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MovieGenreMaxAggregateInputType
  }

  export type GetMovieGenreAggregateType<T extends MovieGenreAggregateArgs> = {
        [P in keyof T & keyof AggregateMovieGenre]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMovieGenre[P]>
      : GetScalarType<T[P], AggregateMovieGenre[P]>
  }




  export type MovieGenreGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MovieGenreWhereInput
    orderBy?: MovieGenreOrderByWithAggregationInput | MovieGenreOrderByWithAggregationInput[]
    by: MovieGenreScalarFieldEnum[] | MovieGenreScalarFieldEnum
    having?: MovieGenreScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MovieGenreCountAggregateInputType | true
    _avg?: MovieGenreAvgAggregateInputType
    _sum?: MovieGenreSumAggregateInputType
    _min?: MovieGenreMinAggregateInputType
    _max?: MovieGenreMaxAggregateInputType
  }

  export type MovieGenreGroupByOutputType = {
    id: number
    movieId: string
    name: string
    _count: MovieGenreCountAggregateOutputType | null
    _avg: MovieGenreAvgAggregateOutputType | null
    _sum: MovieGenreSumAggregateOutputType | null
    _min: MovieGenreMinAggregateOutputType | null
    _max: MovieGenreMaxAggregateOutputType | null
  }

  type GetMovieGenreGroupByPayload<T extends MovieGenreGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MovieGenreGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MovieGenreGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MovieGenreGroupByOutputType[P]>
            : GetScalarType<T[P], MovieGenreGroupByOutputType[P]>
        }
      >
    >


  export type MovieGenreSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    movieId?: boolean
    name?: boolean
    movie?: boolean | MovieDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["movieGenre"]>


  export type MovieGenreSelectScalar = {
    id?: boolean
    movieId?: boolean
    name?: boolean
  }

  export type MovieGenreInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    movie?: boolean | MovieDefaultArgs<ExtArgs>
  }

  export type $MovieGenrePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "MovieGenre"
    objects: {
      movie: Prisma.$MoviePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      movieId: string
      name: string
    }, ExtArgs["result"]["movieGenre"]>
    composites: {}
  }

  type MovieGenreGetPayload<S extends boolean | null | undefined | MovieGenreDefaultArgs> = $Result.GetResult<Prisma.$MovieGenrePayload, S>

  type MovieGenreCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<MovieGenreFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: MovieGenreCountAggregateInputType | true
    }

  export interface MovieGenreDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['MovieGenre'], meta: { name: 'MovieGenre' } }
    /**
     * Find zero or one MovieGenre that matches the filter.
     * @param {MovieGenreFindUniqueArgs} args - Arguments to find a MovieGenre
     * @example
     * // Get one MovieGenre
     * const movieGenre = await prisma.movieGenre.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends MovieGenreFindUniqueArgs>(args: SelectSubset<T, MovieGenreFindUniqueArgs<ExtArgs>>): Prisma__MovieGenreClient<$Result.GetResult<Prisma.$MovieGenrePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one MovieGenre that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {MovieGenreFindUniqueOrThrowArgs} args - Arguments to find a MovieGenre
     * @example
     * // Get one MovieGenre
     * const movieGenre = await prisma.movieGenre.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends MovieGenreFindUniqueOrThrowArgs>(args: SelectSubset<T, MovieGenreFindUniqueOrThrowArgs<ExtArgs>>): Prisma__MovieGenreClient<$Result.GetResult<Prisma.$MovieGenrePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first MovieGenre that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MovieGenreFindFirstArgs} args - Arguments to find a MovieGenre
     * @example
     * // Get one MovieGenre
     * const movieGenre = await prisma.movieGenre.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends MovieGenreFindFirstArgs>(args?: SelectSubset<T, MovieGenreFindFirstArgs<ExtArgs>>): Prisma__MovieGenreClient<$Result.GetResult<Prisma.$MovieGenrePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first MovieGenre that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MovieGenreFindFirstOrThrowArgs} args - Arguments to find a MovieGenre
     * @example
     * // Get one MovieGenre
     * const movieGenre = await prisma.movieGenre.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends MovieGenreFindFirstOrThrowArgs>(args?: SelectSubset<T, MovieGenreFindFirstOrThrowArgs<ExtArgs>>): Prisma__MovieGenreClient<$Result.GetResult<Prisma.$MovieGenrePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more MovieGenres that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MovieGenreFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all MovieGenres
     * const movieGenres = await prisma.movieGenre.findMany()
     * 
     * // Get first 10 MovieGenres
     * const movieGenres = await prisma.movieGenre.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const movieGenreWithIdOnly = await prisma.movieGenre.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends MovieGenreFindManyArgs>(args?: SelectSubset<T, MovieGenreFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MovieGenrePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a MovieGenre.
     * @param {MovieGenreCreateArgs} args - Arguments to create a MovieGenre.
     * @example
     * // Create one MovieGenre
     * const MovieGenre = await prisma.movieGenre.create({
     *   data: {
     *     // ... data to create a MovieGenre
     *   }
     * })
     * 
     */
    create<T extends MovieGenreCreateArgs>(args: SelectSubset<T, MovieGenreCreateArgs<ExtArgs>>): Prisma__MovieGenreClient<$Result.GetResult<Prisma.$MovieGenrePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many MovieGenres.
     * @param {MovieGenreCreateManyArgs} args - Arguments to create many MovieGenres.
     * @example
     * // Create many MovieGenres
     * const movieGenre = await prisma.movieGenre.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends MovieGenreCreateManyArgs>(args?: SelectSubset<T, MovieGenreCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a MovieGenre.
     * @param {MovieGenreDeleteArgs} args - Arguments to delete one MovieGenre.
     * @example
     * // Delete one MovieGenre
     * const MovieGenre = await prisma.movieGenre.delete({
     *   where: {
     *     // ... filter to delete one MovieGenre
     *   }
     * })
     * 
     */
    delete<T extends MovieGenreDeleteArgs>(args: SelectSubset<T, MovieGenreDeleteArgs<ExtArgs>>): Prisma__MovieGenreClient<$Result.GetResult<Prisma.$MovieGenrePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one MovieGenre.
     * @param {MovieGenreUpdateArgs} args - Arguments to update one MovieGenre.
     * @example
     * // Update one MovieGenre
     * const movieGenre = await prisma.movieGenre.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends MovieGenreUpdateArgs>(args: SelectSubset<T, MovieGenreUpdateArgs<ExtArgs>>): Prisma__MovieGenreClient<$Result.GetResult<Prisma.$MovieGenrePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more MovieGenres.
     * @param {MovieGenreDeleteManyArgs} args - Arguments to filter MovieGenres to delete.
     * @example
     * // Delete a few MovieGenres
     * const { count } = await prisma.movieGenre.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends MovieGenreDeleteManyArgs>(args?: SelectSubset<T, MovieGenreDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more MovieGenres.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MovieGenreUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many MovieGenres
     * const movieGenre = await prisma.movieGenre.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends MovieGenreUpdateManyArgs>(args: SelectSubset<T, MovieGenreUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one MovieGenre.
     * @param {MovieGenreUpsertArgs} args - Arguments to update or create a MovieGenre.
     * @example
     * // Update or create a MovieGenre
     * const movieGenre = await prisma.movieGenre.upsert({
     *   create: {
     *     // ... data to create a MovieGenre
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the MovieGenre we want to update
     *   }
     * })
     */
    upsert<T extends MovieGenreUpsertArgs>(args: SelectSubset<T, MovieGenreUpsertArgs<ExtArgs>>): Prisma__MovieGenreClient<$Result.GetResult<Prisma.$MovieGenrePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of MovieGenres.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MovieGenreCountArgs} args - Arguments to filter MovieGenres to count.
     * @example
     * // Count the number of MovieGenres
     * const count = await prisma.movieGenre.count({
     *   where: {
     *     // ... the filter for the MovieGenres we want to count
     *   }
     * })
    **/
    count<T extends MovieGenreCountArgs>(
      args?: Subset<T, MovieGenreCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MovieGenreCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a MovieGenre.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MovieGenreAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MovieGenreAggregateArgs>(args: Subset<T, MovieGenreAggregateArgs>): Prisma.PrismaPromise<GetMovieGenreAggregateType<T>>

    /**
     * Group by MovieGenre.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MovieGenreGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MovieGenreGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MovieGenreGroupByArgs['orderBy'] }
        : { orderBy?: MovieGenreGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MovieGenreGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMovieGenreGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the MovieGenre model
   */
  readonly fields: MovieGenreFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for MovieGenre.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__MovieGenreClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    movie<T extends MovieDefaultArgs<ExtArgs> = {}>(args?: Subset<T, MovieDefaultArgs<ExtArgs>>): Prisma__MovieClient<$Result.GetResult<Prisma.$MoviePayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the MovieGenre model
   */ 
  interface MovieGenreFieldRefs {
    readonly id: FieldRef<"MovieGenre", 'Int'>
    readonly movieId: FieldRef<"MovieGenre", 'String'>
    readonly name: FieldRef<"MovieGenre", 'String'>
  }
    

  // Custom InputTypes
  /**
   * MovieGenre findUnique
   */
  export type MovieGenreFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MovieGenre
     */
    select?: MovieGenreSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MovieGenreInclude<ExtArgs> | null
    /**
     * Filter, which MovieGenre to fetch.
     */
    where: MovieGenreWhereUniqueInput
  }

  /**
   * MovieGenre findUniqueOrThrow
   */
  export type MovieGenreFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MovieGenre
     */
    select?: MovieGenreSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MovieGenreInclude<ExtArgs> | null
    /**
     * Filter, which MovieGenre to fetch.
     */
    where: MovieGenreWhereUniqueInput
  }

  /**
   * MovieGenre findFirst
   */
  export type MovieGenreFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MovieGenre
     */
    select?: MovieGenreSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MovieGenreInclude<ExtArgs> | null
    /**
     * Filter, which MovieGenre to fetch.
     */
    where?: MovieGenreWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MovieGenres to fetch.
     */
    orderBy?: MovieGenreOrderByWithRelationInput | MovieGenreOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MovieGenres.
     */
    cursor?: MovieGenreWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MovieGenres from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MovieGenres.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MovieGenres.
     */
    distinct?: MovieGenreScalarFieldEnum | MovieGenreScalarFieldEnum[]
  }

  /**
   * MovieGenre findFirstOrThrow
   */
  export type MovieGenreFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MovieGenre
     */
    select?: MovieGenreSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MovieGenreInclude<ExtArgs> | null
    /**
     * Filter, which MovieGenre to fetch.
     */
    where?: MovieGenreWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MovieGenres to fetch.
     */
    orderBy?: MovieGenreOrderByWithRelationInput | MovieGenreOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MovieGenres.
     */
    cursor?: MovieGenreWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MovieGenres from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MovieGenres.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MovieGenres.
     */
    distinct?: MovieGenreScalarFieldEnum | MovieGenreScalarFieldEnum[]
  }

  /**
   * MovieGenre findMany
   */
  export type MovieGenreFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MovieGenre
     */
    select?: MovieGenreSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MovieGenreInclude<ExtArgs> | null
    /**
     * Filter, which MovieGenres to fetch.
     */
    where?: MovieGenreWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MovieGenres to fetch.
     */
    orderBy?: MovieGenreOrderByWithRelationInput | MovieGenreOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing MovieGenres.
     */
    cursor?: MovieGenreWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MovieGenres from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MovieGenres.
     */
    skip?: number
    distinct?: MovieGenreScalarFieldEnum | MovieGenreScalarFieldEnum[]
  }

  /**
   * MovieGenre create
   */
  export type MovieGenreCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MovieGenre
     */
    select?: MovieGenreSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MovieGenreInclude<ExtArgs> | null
    /**
     * The data needed to create a MovieGenre.
     */
    data: XOR<MovieGenreCreateInput, MovieGenreUncheckedCreateInput>
  }

  /**
   * MovieGenre createMany
   */
  export type MovieGenreCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many MovieGenres.
     */
    data: MovieGenreCreateManyInput | MovieGenreCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * MovieGenre update
   */
  export type MovieGenreUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MovieGenre
     */
    select?: MovieGenreSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MovieGenreInclude<ExtArgs> | null
    /**
     * The data needed to update a MovieGenre.
     */
    data: XOR<MovieGenreUpdateInput, MovieGenreUncheckedUpdateInput>
    /**
     * Choose, which MovieGenre to update.
     */
    where: MovieGenreWhereUniqueInput
  }

  /**
   * MovieGenre updateMany
   */
  export type MovieGenreUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update MovieGenres.
     */
    data: XOR<MovieGenreUpdateManyMutationInput, MovieGenreUncheckedUpdateManyInput>
    /**
     * Filter which MovieGenres to update
     */
    where?: MovieGenreWhereInput
  }

  /**
   * MovieGenre upsert
   */
  export type MovieGenreUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MovieGenre
     */
    select?: MovieGenreSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MovieGenreInclude<ExtArgs> | null
    /**
     * The filter to search for the MovieGenre to update in case it exists.
     */
    where: MovieGenreWhereUniqueInput
    /**
     * In case the MovieGenre found by the `where` argument doesn't exist, create a new MovieGenre with this data.
     */
    create: XOR<MovieGenreCreateInput, MovieGenreUncheckedCreateInput>
    /**
     * In case the MovieGenre was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MovieGenreUpdateInput, MovieGenreUncheckedUpdateInput>
  }

  /**
   * MovieGenre delete
   */
  export type MovieGenreDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MovieGenre
     */
    select?: MovieGenreSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MovieGenreInclude<ExtArgs> | null
    /**
     * Filter which MovieGenre to delete.
     */
    where: MovieGenreWhereUniqueInput
  }

  /**
   * MovieGenre deleteMany
   */
  export type MovieGenreDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MovieGenres to delete
     */
    where?: MovieGenreWhereInput
  }

  /**
   * MovieGenre without action
   */
  export type MovieGenreDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MovieGenre
     */
    select?: MovieGenreSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MovieGenreInclude<ExtArgs> | null
  }


  /**
   * Model MovieLanguage
   */

  export type AggregateMovieLanguage = {
    _count: MovieLanguageCountAggregateOutputType | null
    _avg: MovieLanguageAvgAggregateOutputType | null
    _sum: MovieLanguageSumAggregateOutputType | null
    _min: MovieLanguageMinAggregateOutputType | null
    _max: MovieLanguageMaxAggregateOutputType | null
  }

  export type MovieLanguageAvgAggregateOutputType = {
    id: number | null
  }

  export type MovieLanguageSumAggregateOutputType = {
    id: number | null
  }

  export type MovieLanguageMinAggregateOutputType = {
    id: number | null
    movieId: string | null
    name: string | null
  }

  export type MovieLanguageMaxAggregateOutputType = {
    id: number | null
    movieId: string | null
    name: string | null
  }

  export type MovieLanguageCountAggregateOutputType = {
    id: number
    movieId: number
    name: number
    _all: number
  }


  export type MovieLanguageAvgAggregateInputType = {
    id?: true
  }

  export type MovieLanguageSumAggregateInputType = {
    id?: true
  }

  export type MovieLanguageMinAggregateInputType = {
    id?: true
    movieId?: true
    name?: true
  }

  export type MovieLanguageMaxAggregateInputType = {
    id?: true
    movieId?: true
    name?: true
  }

  export type MovieLanguageCountAggregateInputType = {
    id?: true
    movieId?: true
    name?: true
    _all?: true
  }

  export type MovieLanguageAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MovieLanguage to aggregate.
     */
    where?: MovieLanguageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MovieLanguages to fetch.
     */
    orderBy?: MovieLanguageOrderByWithRelationInput | MovieLanguageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: MovieLanguageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MovieLanguages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MovieLanguages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned MovieLanguages
    **/
    _count?: true | MovieLanguageCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: MovieLanguageAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: MovieLanguageSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MovieLanguageMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MovieLanguageMaxAggregateInputType
  }

  export type GetMovieLanguageAggregateType<T extends MovieLanguageAggregateArgs> = {
        [P in keyof T & keyof AggregateMovieLanguage]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMovieLanguage[P]>
      : GetScalarType<T[P], AggregateMovieLanguage[P]>
  }




  export type MovieLanguageGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MovieLanguageWhereInput
    orderBy?: MovieLanguageOrderByWithAggregationInput | MovieLanguageOrderByWithAggregationInput[]
    by: MovieLanguageScalarFieldEnum[] | MovieLanguageScalarFieldEnum
    having?: MovieLanguageScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MovieLanguageCountAggregateInputType | true
    _avg?: MovieLanguageAvgAggregateInputType
    _sum?: MovieLanguageSumAggregateInputType
    _min?: MovieLanguageMinAggregateInputType
    _max?: MovieLanguageMaxAggregateInputType
  }

  export type MovieLanguageGroupByOutputType = {
    id: number
    movieId: string
    name: string
    _count: MovieLanguageCountAggregateOutputType | null
    _avg: MovieLanguageAvgAggregateOutputType | null
    _sum: MovieLanguageSumAggregateOutputType | null
    _min: MovieLanguageMinAggregateOutputType | null
    _max: MovieLanguageMaxAggregateOutputType | null
  }

  type GetMovieLanguageGroupByPayload<T extends MovieLanguageGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MovieLanguageGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MovieLanguageGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MovieLanguageGroupByOutputType[P]>
            : GetScalarType<T[P], MovieLanguageGroupByOutputType[P]>
        }
      >
    >


  export type MovieLanguageSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    movieId?: boolean
    name?: boolean
    movie?: boolean | MovieDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["movieLanguage"]>


  export type MovieLanguageSelectScalar = {
    id?: boolean
    movieId?: boolean
    name?: boolean
  }

  export type MovieLanguageInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    movie?: boolean | MovieDefaultArgs<ExtArgs>
  }

  export type $MovieLanguagePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "MovieLanguage"
    objects: {
      movie: Prisma.$MoviePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      movieId: string
      name: string
    }, ExtArgs["result"]["movieLanguage"]>
    composites: {}
  }

  type MovieLanguageGetPayload<S extends boolean | null | undefined | MovieLanguageDefaultArgs> = $Result.GetResult<Prisma.$MovieLanguagePayload, S>

  type MovieLanguageCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<MovieLanguageFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: MovieLanguageCountAggregateInputType | true
    }

  export interface MovieLanguageDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['MovieLanguage'], meta: { name: 'MovieLanguage' } }
    /**
     * Find zero or one MovieLanguage that matches the filter.
     * @param {MovieLanguageFindUniqueArgs} args - Arguments to find a MovieLanguage
     * @example
     * // Get one MovieLanguage
     * const movieLanguage = await prisma.movieLanguage.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends MovieLanguageFindUniqueArgs>(args: SelectSubset<T, MovieLanguageFindUniqueArgs<ExtArgs>>): Prisma__MovieLanguageClient<$Result.GetResult<Prisma.$MovieLanguagePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one MovieLanguage that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {MovieLanguageFindUniqueOrThrowArgs} args - Arguments to find a MovieLanguage
     * @example
     * // Get one MovieLanguage
     * const movieLanguage = await prisma.movieLanguage.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends MovieLanguageFindUniqueOrThrowArgs>(args: SelectSubset<T, MovieLanguageFindUniqueOrThrowArgs<ExtArgs>>): Prisma__MovieLanguageClient<$Result.GetResult<Prisma.$MovieLanguagePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first MovieLanguage that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MovieLanguageFindFirstArgs} args - Arguments to find a MovieLanguage
     * @example
     * // Get one MovieLanguage
     * const movieLanguage = await prisma.movieLanguage.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends MovieLanguageFindFirstArgs>(args?: SelectSubset<T, MovieLanguageFindFirstArgs<ExtArgs>>): Prisma__MovieLanguageClient<$Result.GetResult<Prisma.$MovieLanguagePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first MovieLanguage that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MovieLanguageFindFirstOrThrowArgs} args - Arguments to find a MovieLanguage
     * @example
     * // Get one MovieLanguage
     * const movieLanguage = await prisma.movieLanguage.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends MovieLanguageFindFirstOrThrowArgs>(args?: SelectSubset<T, MovieLanguageFindFirstOrThrowArgs<ExtArgs>>): Prisma__MovieLanguageClient<$Result.GetResult<Prisma.$MovieLanguagePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more MovieLanguages that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MovieLanguageFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all MovieLanguages
     * const movieLanguages = await prisma.movieLanguage.findMany()
     * 
     * // Get first 10 MovieLanguages
     * const movieLanguages = await prisma.movieLanguage.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const movieLanguageWithIdOnly = await prisma.movieLanguage.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends MovieLanguageFindManyArgs>(args?: SelectSubset<T, MovieLanguageFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MovieLanguagePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a MovieLanguage.
     * @param {MovieLanguageCreateArgs} args - Arguments to create a MovieLanguage.
     * @example
     * // Create one MovieLanguage
     * const MovieLanguage = await prisma.movieLanguage.create({
     *   data: {
     *     // ... data to create a MovieLanguage
     *   }
     * })
     * 
     */
    create<T extends MovieLanguageCreateArgs>(args: SelectSubset<T, MovieLanguageCreateArgs<ExtArgs>>): Prisma__MovieLanguageClient<$Result.GetResult<Prisma.$MovieLanguagePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many MovieLanguages.
     * @param {MovieLanguageCreateManyArgs} args - Arguments to create many MovieLanguages.
     * @example
     * // Create many MovieLanguages
     * const movieLanguage = await prisma.movieLanguage.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends MovieLanguageCreateManyArgs>(args?: SelectSubset<T, MovieLanguageCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a MovieLanguage.
     * @param {MovieLanguageDeleteArgs} args - Arguments to delete one MovieLanguage.
     * @example
     * // Delete one MovieLanguage
     * const MovieLanguage = await prisma.movieLanguage.delete({
     *   where: {
     *     // ... filter to delete one MovieLanguage
     *   }
     * })
     * 
     */
    delete<T extends MovieLanguageDeleteArgs>(args: SelectSubset<T, MovieLanguageDeleteArgs<ExtArgs>>): Prisma__MovieLanguageClient<$Result.GetResult<Prisma.$MovieLanguagePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one MovieLanguage.
     * @param {MovieLanguageUpdateArgs} args - Arguments to update one MovieLanguage.
     * @example
     * // Update one MovieLanguage
     * const movieLanguage = await prisma.movieLanguage.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends MovieLanguageUpdateArgs>(args: SelectSubset<T, MovieLanguageUpdateArgs<ExtArgs>>): Prisma__MovieLanguageClient<$Result.GetResult<Prisma.$MovieLanguagePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more MovieLanguages.
     * @param {MovieLanguageDeleteManyArgs} args - Arguments to filter MovieLanguages to delete.
     * @example
     * // Delete a few MovieLanguages
     * const { count } = await prisma.movieLanguage.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends MovieLanguageDeleteManyArgs>(args?: SelectSubset<T, MovieLanguageDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more MovieLanguages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MovieLanguageUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many MovieLanguages
     * const movieLanguage = await prisma.movieLanguage.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends MovieLanguageUpdateManyArgs>(args: SelectSubset<T, MovieLanguageUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one MovieLanguage.
     * @param {MovieLanguageUpsertArgs} args - Arguments to update or create a MovieLanguage.
     * @example
     * // Update or create a MovieLanguage
     * const movieLanguage = await prisma.movieLanguage.upsert({
     *   create: {
     *     // ... data to create a MovieLanguage
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the MovieLanguage we want to update
     *   }
     * })
     */
    upsert<T extends MovieLanguageUpsertArgs>(args: SelectSubset<T, MovieLanguageUpsertArgs<ExtArgs>>): Prisma__MovieLanguageClient<$Result.GetResult<Prisma.$MovieLanguagePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of MovieLanguages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MovieLanguageCountArgs} args - Arguments to filter MovieLanguages to count.
     * @example
     * // Count the number of MovieLanguages
     * const count = await prisma.movieLanguage.count({
     *   where: {
     *     // ... the filter for the MovieLanguages we want to count
     *   }
     * })
    **/
    count<T extends MovieLanguageCountArgs>(
      args?: Subset<T, MovieLanguageCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MovieLanguageCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a MovieLanguage.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MovieLanguageAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MovieLanguageAggregateArgs>(args: Subset<T, MovieLanguageAggregateArgs>): Prisma.PrismaPromise<GetMovieLanguageAggregateType<T>>

    /**
     * Group by MovieLanguage.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MovieLanguageGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MovieLanguageGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MovieLanguageGroupByArgs['orderBy'] }
        : { orderBy?: MovieLanguageGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MovieLanguageGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMovieLanguageGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the MovieLanguage model
   */
  readonly fields: MovieLanguageFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for MovieLanguage.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__MovieLanguageClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    movie<T extends MovieDefaultArgs<ExtArgs> = {}>(args?: Subset<T, MovieDefaultArgs<ExtArgs>>): Prisma__MovieClient<$Result.GetResult<Prisma.$MoviePayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the MovieLanguage model
   */ 
  interface MovieLanguageFieldRefs {
    readonly id: FieldRef<"MovieLanguage", 'Int'>
    readonly movieId: FieldRef<"MovieLanguage", 'String'>
    readonly name: FieldRef<"MovieLanguage", 'String'>
  }
    

  // Custom InputTypes
  /**
   * MovieLanguage findUnique
   */
  export type MovieLanguageFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MovieLanguage
     */
    select?: MovieLanguageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MovieLanguageInclude<ExtArgs> | null
    /**
     * Filter, which MovieLanguage to fetch.
     */
    where: MovieLanguageWhereUniqueInput
  }

  /**
   * MovieLanguage findUniqueOrThrow
   */
  export type MovieLanguageFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MovieLanguage
     */
    select?: MovieLanguageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MovieLanguageInclude<ExtArgs> | null
    /**
     * Filter, which MovieLanguage to fetch.
     */
    where: MovieLanguageWhereUniqueInput
  }

  /**
   * MovieLanguage findFirst
   */
  export type MovieLanguageFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MovieLanguage
     */
    select?: MovieLanguageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MovieLanguageInclude<ExtArgs> | null
    /**
     * Filter, which MovieLanguage to fetch.
     */
    where?: MovieLanguageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MovieLanguages to fetch.
     */
    orderBy?: MovieLanguageOrderByWithRelationInput | MovieLanguageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MovieLanguages.
     */
    cursor?: MovieLanguageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MovieLanguages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MovieLanguages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MovieLanguages.
     */
    distinct?: MovieLanguageScalarFieldEnum | MovieLanguageScalarFieldEnum[]
  }

  /**
   * MovieLanguage findFirstOrThrow
   */
  export type MovieLanguageFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MovieLanguage
     */
    select?: MovieLanguageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MovieLanguageInclude<ExtArgs> | null
    /**
     * Filter, which MovieLanguage to fetch.
     */
    where?: MovieLanguageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MovieLanguages to fetch.
     */
    orderBy?: MovieLanguageOrderByWithRelationInput | MovieLanguageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MovieLanguages.
     */
    cursor?: MovieLanguageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MovieLanguages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MovieLanguages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MovieLanguages.
     */
    distinct?: MovieLanguageScalarFieldEnum | MovieLanguageScalarFieldEnum[]
  }

  /**
   * MovieLanguage findMany
   */
  export type MovieLanguageFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MovieLanguage
     */
    select?: MovieLanguageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MovieLanguageInclude<ExtArgs> | null
    /**
     * Filter, which MovieLanguages to fetch.
     */
    where?: MovieLanguageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MovieLanguages to fetch.
     */
    orderBy?: MovieLanguageOrderByWithRelationInput | MovieLanguageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing MovieLanguages.
     */
    cursor?: MovieLanguageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MovieLanguages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MovieLanguages.
     */
    skip?: number
    distinct?: MovieLanguageScalarFieldEnum | MovieLanguageScalarFieldEnum[]
  }

  /**
   * MovieLanguage create
   */
  export type MovieLanguageCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MovieLanguage
     */
    select?: MovieLanguageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MovieLanguageInclude<ExtArgs> | null
    /**
     * The data needed to create a MovieLanguage.
     */
    data: XOR<MovieLanguageCreateInput, MovieLanguageUncheckedCreateInput>
  }

  /**
   * MovieLanguage createMany
   */
  export type MovieLanguageCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many MovieLanguages.
     */
    data: MovieLanguageCreateManyInput | MovieLanguageCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * MovieLanguage update
   */
  export type MovieLanguageUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MovieLanguage
     */
    select?: MovieLanguageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MovieLanguageInclude<ExtArgs> | null
    /**
     * The data needed to update a MovieLanguage.
     */
    data: XOR<MovieLanguageUpdateInput, MovieLanguageUncheckedUpdateInput>
    /**
     * Choose, which MovieLanguage to update.
     */
    where: MovieLanguageWhereUniqueInput
  }

  /**
   * MovieLanguage updateMany
   */
  export type MovieLanguageUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update MovieLanguages.
     */
    data: XOR<MovieLanguageUpdateManyMutationInput, MovieLanguageUncheckedUpdateManyInput>
    /**
     * Filter which MovieLanguages to update
     */
    where?: MovieLanguageWhereInput
  }

  /**
   * MovieLanguage upsert
   */
  export type MovieLanguageUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MovieLanguage
     */
    select?: MovieLanguageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MovieLanguageInclude<ExtArgs> | null
    /**
     * The filter to search for the MovieLanguage to update in case it exists.
     */
    where: MovieLanguageWhereUniqueInput
    /**
     * In case the MovieLanguage found by the `where` argument doesn't exist, create a new MovieLanguage with this data.
     */
    create: XOR<MovieLanguageCreateInput, MovieLanguageUncheckedCreateInput>
    /**
     * In case the MovieLanguage was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MovieLanguageUpdateInput, MovieLanguageUncheckedUpdateInput>
  }

  /**
   * MovieLanguage delete
   */
  export type MovieLanguageDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MovieLanguage
     */
    select?: MovieLanguageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MovieLanguageInclude<ExtArgs> | null
    /**
     * Filter which MovieLanguage to delete.
     */
    where: MovieLanguageWhereUniqueInput
  }

  /**
   * MovieLanguage deleteMany
   */
  export type MovieLanguageDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MovieLanguages to delete
     */
    where?: MovieLanguageWhereInput
  }

  /**
   * MovieLanguage without action
   */
  export type MovieLanguageDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MovieLanguage
     */
    select?: MovieLanguageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MovieLanguageInclude<ExtArgs> | null
  }


  /**
   * Model Auditorium
   */

  export type AggregateAuditorium = {
    _count: AuditoriumCountAggregateOutputType | null
    _avg: AuditoriumAvgAggregateOutputType | null
    _sum: AuditoriumSumAggregateOutputType | null
    _min: AuditoriumMinAggregateOutputType | null
    _max: AuditoriumMaxAggregateOutputType | null
  }

  export type AuditoriumAvgAggregateOutputType = {
    capacity: number | null
    layoutVersion: number | null
  }

  export type AuditoriumSumAggregateOutputType = {
    capacity: number | null
    layoutVersion: number | null
  }

  export type AuditoriumMinAggregateOutputType = {
    id: string | null
    cinemaId: string | null
    cinemaName: string | null
    name: string | null
    capacity: number | null
    layoutVersion: number | null
    layoutUpdatedAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AuditoriumMaxAggregateOutputType = {
    id: string | null
    cinemaId: string | null
    cinemaName: string | null
    name: string | null
    capacity: number | null
    layoutVersion: number | null
    layoutUpdatedAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AuditoriumCountAggregateOutputType = {
    id: number
    cinemaId: number
    cinemaName: number
    name: number
    capacity: number
    layoutVersion: number
    layoutJson: number
    layoutUpdatedAt: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type AuditoriumAvgAggregateInputType = {
    capacity?: true
    layoutVersion?: true
  }

  export type AuditoriumSumAggregateInputType = {
    capacity?: true
    layoutVersion?: true
  }

  export type AuditoriumMinAggregateInputType = {
    id?: true
    cinemaId?: true
    cinemaName?: true
    name?: true
    capacity?: true
    layoutVersion?: true
    layoutUpdatedAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AuditoriumMaxAggregateInputType = {
    id?: true
    cinemaId?: true
    cinemaName?: true
    name?: true
    capacity?: true
    layoutVersion?: true
    layoutUpdatedAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AuditoriumCountAggregateInputType = {
    id?: true
    cinemaId?: true
    cinemaName?: true
    name?: true
    capacity?: true
    layoutVersion?: true
    layoutJson?: true
    layoutUpdatedAt?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type AuditoriumAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Auditorium to aggregate.
     */
    where?: AuditoriumWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Auditoriums to fetch.
     */
    orderBy?: AuditoriumOrderByWithRelationInput | AuditoriumOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AuditoriumWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Auditoriums from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Auditoriums.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Auditoriums
    **/
    _count?: true | AuditoriumCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AuditoriumAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AuditoriumSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AuditoriumMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AuditoriumMaxAggregateInputType
  }

  export type GetAuditoriumAggregateType<T extends AuditoriumAggregateArgs> = {
        [P in keyof T & keyof AggregateAuditorium]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAuditorium[P]>
      : GetScalarType<T[P], AggregateAuditorium[P]>
  }




  export type AuditoriumGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AuditoriumWhereInput
    orderBy?: AuditoriumOrderByWithAggregationInput | AuditoriumOrderByWithAggregationInput[]
    by: AuditoriumScalarFieldEnum[] | AuditoriumScalarFieldEnum
    having?: AuditoriumScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AuditoriumCountAggregateInputType | true
    _avg?: AuditoriumAvgAggregateInputType
    _sum?: AuditoriumSumAggregateInputType
    _min?: AuditoriumMinAggregateInputType
    _max?: AuditoriumMaxAggregateInputType
  }

  export type AuditoriumGroupByOutputType = {
    id: string
    cinemaId: string
    cinemaName: string
    name: string
    capacity: number
    layoutVersion: number
    layoutJson: JsonValue
    layoutUpdatedAt: Date
    createdAt: Date
    updatedAt: Date
    _count: AuditoriumCountAggregateOutputType | null
    _avg: AuditoriumAvgAggregateOutputType | null
    _sum: AuditoriumSumAggregateOutputType | null
    _min: AuditoriumMinAggregateOutputType | null
    _max: AuditoriumMaxAggregateOutputType | null
  }

  type GetAuditoriumGroupByPayload<T extends AuditoriumGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AuditoriumGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AuditoriumGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AuditoriumGroupByOutputType[P]>
            : GetScalarType<T[P], AuditoriumGroupByOutputType[P]>
        }
      >
    >


  export type AuditoriumSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    cinemaId?: boolean
    cinemaName?: boolean
    name?: boolean
    capacity?: boolean
    layoutVersion?: boolean
    layoutJson?: boolean
    layoutUpdatedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    showtimes?: boolean | Auditorium$showtimesArgs<ExtArgs>
    _count?: boolean | AuditoriumCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["auditorium"]>


  export type AuditoriumSelectScalar = {
    id?: boolean
    cinemaId?: boolean
    cinemaName?: boolean
    name?: boolean
    capacity?: boolean
    layoutVersion?: boolean
    layoutJson?: boolean
    layoutUpdatedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type AuditoriumInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    showtimes?: boolean | Auditorium$showtimesArgs<ExtArgs>
    _count?: boolean | AuditoriumCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $AuditoriumPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Auditorium"
    objects: {
      showtimes: Prisma.$ShowtimePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      cinemaId: string
      cinemaName: string
      name: string
      capacity: number
      layoutVersion: number
      layoutJson: Prisma.JsonValue
      layoutUpdatedAt: Date
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["auditorium"]>
    composites: {}
  }

  type AuditoriumGetPayload<S extends boolean | null | undefined | AuditoriumDefaultArgs> = $Result.GetResult<Prisma.$AuditoriumPayload, S>

  type AuditoriumCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<AuditoriumFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: AuditoriumCountAggregateInputType | true
    }

  export interface AuditoriumDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Auditorium'], meta: { name: 'Auditorium' } }
    /**
     * Find zero or one Auditorium that matches the filter.
     * @param {AuditoriumFindUniqueArgs} args - Arguments to find a Auditorium
     * @example
     * // Get one Auditorium
     * const auditorium = await prisma.auditorium.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AuditoriumFindUniqueArgs>(args: SelectSubset<T, AuditoriumFindUniqueArgs<ExtArgs>>): Prisma__AuditoriumClient<$Result.GetResult<Prisma.$AuditoriumPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Auditorium that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {AuditoriumFindUniqueOrThrowArgs} args - Arguments to find a Auditorium
     * @example
     * // Get one Auditorium
     * const auditorium = await prisma.auditorium.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AuditoriumFindUniqueOrThrowArgs>(args: SelectSubset<T, AuditoriumFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AuditoriumClient<$Result.GetResult<Prisma.$AuditoriumPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Auditorium that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditoriumFindFirstArgs} args - Arguments to find a Auditorium
     * @example
     * // Get one Auditorium
     * const auditorium = await prisma.auditorium.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AuditoriumFindFirstArgs>(args?: SelectSubset<T, AuditoriumFindFirstArgs<ExtArgs>>): Prisma__AuditoriumClient<$Result.GetResult<Prisma.$AuditoriumPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Auditorium that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditoriumFindFirstOrThrowArgs} args - Arguments to find a Auditorium
     * @example
     * // Get one Auditorium
     * const auditorium = await prisma.auditorium.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AuditoriumFindFirstOrThrowArgs>(args?: SelectSubset<T, AuditoriumFindFirstOrThrowArgs<ExtArgs>>): Prisma__AuditoriumClient<$Result.GetResult<Prisma.$AuditoriumPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Auditoriums that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditoriumFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Auditoriums
     * const auditoriums = await prisma.auditorium.findMany()
     * 
     * // Get first 10 Auditoriums
     * const auditoriums = await prisma.auditorium.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const auditoriumWithIdOnly = await prisma.auditorium.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AuditoriumFindManyArgs>(args?: SelectSubset<T, AuditoriumFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AuditoriumPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Auditorium.
     * @param {AuditoriumCreateArgs} args - Arguments to create a Auditorium.
     * @example
     * // Create one Auditorium
     * const Auditorium = await prisma.auditorium.create({
     *   data: {
     *     // ... data to create a Auditorium
     *   }
     * })
     * 
     */
    create<T extends AuditoriumCreateArgs>(args: SelectSubset<T, AuditoriumCreateArgs<ExtArgs>>): Prisma__AuditoriumClient<$Result.GetResult<Prisma.$AuditoriumPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Auditoriums.
     * @param {AuditoriumCreateManyArgs} args - Arguments to create many Auditoriums.
     * @example
     * // Create many Auditoriums
     * const auditorium = await prisma.auditorium.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AuditoriumCreateManyArgs>(args?: SelectSubset<T, AuditoriumCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Auditorium.
     * @param {AuditoriumDeleteArgs} args - Arguments to delete one Auditorium.
     * @example
     * // Delete one Auditorium
     * const Auditorium = await prisma.auditorium.delete({
     *   where: {
     *     // ... filter to delete one Auditorium
     *   }
     * })
     * 
     */
    delete<T extends AuditoriumDeleteArgs>(args: SelectSubset<T, AuditoriumDeleteArgs<ExtArgs>>): Prisma__AuditoriumClient<$Result.GetResult<Prisma.$AuditoriumPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Auditorium.
     * @param {AuditoriumUpdateArgs} args - Arguments to update one Auditorium.
     * @example
     * // Update one Auditorium
     * const auditorium = await prisma.auditorium.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AuditoriumUpdateArgs>(args: SelectSubset<T, AuditoriumUpdateArgs<ExtArgs>>): Prisma__AuditoriumClient<$Result.GetResult<Prisma.$AuditoriumPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Auditoriums.
     * @param {AuditoriumDeleteManyArgs} args - Arguments to filter Auditoriums to delete.
     * @example
     * // Delete a few Auditoriums
     * const { count } = await prisma.auditorium.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AuditoriumDeleteManyArgs>(args?: SelectSubset<T, AuditoriumDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Auditoriums.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditoriumUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Auditoriums
     * const auditorium = await prisma.auditorium.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AuditoriumUpdateManyArgs>(args: SelectSubset<T, AuditoriumUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Auditorium.
     * @param {AuditoriumUpsertArgs} args - Arguments to update or create a Auditorium.
     * @example
     * // Update or create a Auditorium
     * const auditorium = await prisma.auditorium.upsert({
     *   create: {
     *     // ... data to create a Auditorium
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Auditorium we want to update
     *   }
     * })
     */
    upsert<T extends AuditoriumUpsertArgs>(args: SelectSubset<T, AuditoriumUpsertArgs<ExtArgs>>): Prisma__AuditoriumClient<$Result.GetResult<Prisma.$AuditoriumPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Auditoriums.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditoriumCountArgs} args - Arguments to filter Auditoriums to count.
     * @example
     * // Count the number of Auditoriums
     * const count = await prisma.auditorium.count({
     *   where: {
     *     // ... the filter for the Auditoriums we want to count
     *   }
     * })
    **/
    count<T extends AuditoriumCountArgs>(
      args?: Subset<T, AuditoriumCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AuditoriumCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Auditorium.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditoriumAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AuditoriumAggregateArgs>(args: Subset<T, AuditoriumAggregateArgs>): Prisma.PrismaPromise<GetAuditoriumAggregateType<T>>

    /**
     * Group by Auditorium.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditoriumGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AuditoriumGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AuditoriumGroupByArgs['orderBy'] }
        : { orderBy?: AuditoriumGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AuditoriumGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAuditoriumGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Auditorium model
   */
  readonly fields: AuditoriumFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Auditorium.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AuditoriumClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    showtimes<T extends Auditorium$showtimesArgs<ExtArgs> = {}>(args?: Subset<T, Auditorium$showtimesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ShowtimePayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Auditorium model
   */ 
  interface AuditoriumFieldRefs {
    readonly id: FieldRef<"Auditorium", 'String'>
    readonly cinemaId: FieldRef<"Auditorium", 'String'>
    readonly cinemaName: FieldRef<"Auditorium", 'String'>
    readonly name: FieldRef<"Auditorium", 'String'>
    readonly capacity: FieldRef<"Auditorium", 'Int'>
    readonly layoutVersion: FieldRef<"Auditorium", 'Int'>
    readonly layoutJson: FieldRef<"Auditorium", 'Json'>
    readonly layoutUpdatedAt: FieldRef<"Auditorium", 'DateTime'>
    readonly createdAt: FieldRef<"Auditorium", 'DateTime'>
    readonly updatedAt: FieldRef<"Auditorium", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Auditorium findUnique
   */
  export type AuditoriumFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Auditorium
     */
    select?: AuditoriumSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditoriumInclude<ExtArgs> | null
    /**
     * Filter, which Auditorium to fetch.
     */
    where: AuditoriumWhereUniqueInput
  }

  /**
   * Auditorium findUniqueOrThrow
   */
  export type AuditoriumFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Auditorium
     */
    select?: AuditoriumSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditoriumInclude<ExtArgs> | null
    /**
     * Filter, which Auditorium to fetch.
     */
    where: AuditoriumWhereUniqueInput
  }

  /**
   * Auditorium findFirst
   */
  export type AuditoriumFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Auditorium
     */
    select?: AuditoriumSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditoriumInclude<ExtArgs> | null
    /**
     * Filter, which Auditorium to fetch.
     */
    where?: AuditoriumWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Auditoriums to fetch.
     */
    orderBy?: AuditoriumOrderByWithRelationInput | AuditoriumOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Auditoriums.
     */
    cursor?: AuditoriumWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Auditoriums from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Auditoriums.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Auditoriums.
     */
    distinct?: AuditoriumScalarFieldEnum | AuditoriumScalarFieldEnum[]
  }

  /**
   * Auditorium findFirstOrThrow
   */
  export type AuditoriumFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Auditorium
     */
    select?: AuditoriumSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditoriumInclude<ExtArgs> | null
    /**
     * Filter, which Auditorium to fetch.
     */
    where?: AuditoriumWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Auditoriums to fetch.
     */
    orderBy?: AuditoriumOrderByWithRelationInput | AuditoriumOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Auditoriums.
     */
    cursor?: AuditoriumWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Auditoriums from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Auditoriums.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Auditoriums.
     */
    distinct?: AuditoriumScalarFieldEnum | AuditoriumScalarFieldEnum[]
  }

  /**
   * Auditorium findMany
   */
  export type AuditoriumFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Auditorium
     */
    select?: AuditoriumSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditoriumInclude<ExtArgs> | null
    /**
     * Filter, which Auditoriums to fetch.
     */
    where?: AuditoriumWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Auditoriums to fetch.
     */
    orderBy?: AuditoriumOrderByWithRelationInput | AuditoriumOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Auditoriums.
     */
    cursor?: AuditoriumWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Auditoriums from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Auditoriums.
     */
    skip?: number
    distinct?: AuditoriumScalarFieldEnum | AuditoriumScalarFieldEnum[]
  }

  /**
   * Auditorium create
   */
  export type AuditoriumCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Auditorium
     */
    select?: AuditoriumSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditoriumInclude<ExtArgs> | null
    /**
     * The data needed to create a Auditorium.
     */
    data: XOR<AuditoriumCreateInput, AuditoriumUncheckedCreateInput>
  }

  /**
   * Auditorium createMany
   */
  export type AuditoriumCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Auditoriums.
     */
    data: AuditoriumCreateManyInput | AuditoriumCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Auditorium update
   */
  export type AuditoriumUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Auditorium
     */
    select?: AuditoriumSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditoriumInclude<ExtArgs> | null
    /**
     * The data needed to update a Auditorium.
     */
    data: XOR<AuditoriumUpdateInput, AuditoriumUncheckedUpdateInput>
    /**
     * Choose, which Auditorium to update.
     */
    where: AuditoriumWhereUniqueInput
  }

  /**
   * Auditorium updateMany
   */
  export type AuditoriumUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Auditoriums.
     */
    data: XOR<AuditoriumUpdateManyMutationInput, AuditoriumUncheckedUpdateManyInput>
    /**
     * Filter which Auditoriums to update
     */
    where?: AuditoriumWhereInput
  }

  /**
   * Auditorium upsert
   */
  export type AuditoriumUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Auditorium
     */
    select?: AuditoriumSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditoriumInclude<ExtArgs> | null
    /**
     * The filter to search for the Auditorium to update in case it exists.
     */
    where: AuditoriumWhereUniqueInput
    /**
     * In case the Auditorium found by the `where` argument doesn't exist, create a new Auditorium with this data.
     */
    create: XOR<AuditoriumCreateInput, AuditoriumUncheckedCreateInput>
    /**
     * In case the Auditorium was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AuditoriumUpdateInput, AuditoriumUncheckedUpdateInput>
  }

  /**
   * Auditorium delete
   */
  export type AuditoriumDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Auditorium
     */
    select?: AuditoriumSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditoriumInclude<ExtArgs> | null
    /**
     * Filter which Auditorium to delete.
     */
    where: AuditoriumWhereUniqueInput
  }

  /**
   * Auditorium deleteMany
   */
  export type AuditoriumDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Auditoriums to delete
     */
    where?: AuditoriumWhereInput
  }

  /**
   * Auditorium.showtimes
   */
  export type Auditorium$showtimesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Showtime
     */
    select?: ShowtimeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShowtimeInclude<ExtArgs> | null
    where?: ShowtimeWhereInput
    orderBy?: ShowtimeOrderByWithRelationInput | ShowtimeOrderByWithRelationInput[]
    cursor?: ShowtimeWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ShowtimeScalarFieldEnum | ShowtimeScalarFieldEnum[]
  }

  /**
   * Auditorium without action
   */
  export type AuditoriumDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Auditorium
     */
    select?: AuditoriumSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditoriumInclude<ExtArgs> | null
  }


  /**
   * Model Showtime
   */

  export type AggregateShowtime = {
    _count: ShowtimeCountAggregateOutputType | null
    _avg: ShowtimeAvgAggregateOutputType | null
    _sum: ShowtimeSumAggregateOutputType | null
    _min: ShowtimeMinAggregateOutputType | null
    _max: ShowtimeMaxAggregateOutputType | null
  }

  export type ShowtimeAvgAggregateOutputType = {
    basePrice: Decimal | null
    seatLayoutVersion: number | null
  }

  export type ShowtimeSumAggregateOutputType = {
    basePrice: Decimal | null
    seatLayoutVersion: number | null
  }

  export type ShowtimeMinAggregateOutputType = {
    id: string | null
    movieId: string | null
    auditoriumId: string | null
    startsAt: Date | null
    endsAt: Date | null
    basePrice: Decimal | null
    status: $Enums.ShowtimeStatus | null
    seatLayoutVersion: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ShowtimeMaxAggregateOutputType = {
    id: string | null
    movieId: string | null
    auditoriumId: string | null
    startsAt: Date | null
    endsAt: Date | null
    basePrice: Decimal | null
    status: $Enums.ShowtimeStatus | null
    seatLayoutVersion: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ShowtimeCountAggregateOutputType = {
    id: number
    movieId: number
    auditoriumId: number
    startsAt: number
    endsAt: number
    basePrice: number
    status: number
    seatLayoutVersion: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ShowtimeAvgAggregateInputType = {
    basePrice?: true
    seatLayoutVersion?: true
  }

  export type ShowtimeSumAggregateInputType = {
    basePrice?: true
    seatLayoutVersion?: true
  }

  export type ShowtimeMinAggregateInputType = {
    id?: true
    movieId?: true
    auditoriumId?: true
    startsAt?: true
    endsAt?: true
    basePrice?: true
    status?: true
    seatLayoutVersion?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ShowtimeMaxAggregateInputType = {
    id?: true
    movieId?: true
    auditoriumId?: true
    startsAt?: true
    endsAt?: true
    basePrice?: true
    status?: true
    seatLayoutVersion?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ShowtimeCountAggregateInputType = {
    id?: true
    movieId?: true
    auditoriumId?: true
    startsAt?: true
    endsAt?: true
    basePrice?: true
    status?: true
    seatLayoutVersion?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ShowtimeAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Showtime to aggregate.
     */
    where?: ShowtimeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Showtimes to fetch.
     */
    orderBy?: ShowtimeOrderByWithRelationInput | ShowtimeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ShowtimeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Showtimes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Showtimes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Showtimes
    **/
    _count?: true | ShowtimeCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ShowtimeAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ShowtimeSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ShowtimeMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ShowtimeMaxAggregateInputType
  }

  export type GetShowtimeAggregateType<T extends ShowtimeAggregateArgs> = {
        [P in keyof T & keyof AggregateShowtime]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateShowtime[P]>
      : GetScalarType<T[P], AggregateShowtime[P]>
  }




  export type ShowtimeGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ShowtimeWhereInput
    orderBy?: ShowtimeOrderByWithAggregationInput | ShowtimeOrderByWithAggregationInput[]
    by: ShowtimeScalarFieldEnum[] | ShowtimeScalarFieldEnum
    having?: ShowtimeScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ShowtimeCountAggregateInputType | true
    _avg?: ShowtimeAvgAggregateInputType
    _sum?: ShowtimeSumAggregateInputType
    _min?: ShowtimeMinAggregateInputType
    _max?: ShowtimeMaxAggregateInputType
  }

  export type ShowtimeGroupByOutputType = {
    id: string
    movieId: string
    auditoriumId: string
    startsAt: Date
    endsAt: Date
    basePrice: Decimal
    status: $Enums.ShowtimeStatus
    seatLayoutVersion: number
    createdAt: Date
    updatedAt: Date
    _count: ShowtimeCountAggregateOutputType | null
    _avg: ShowtimeAvgAggregateOutputType | null
    _sum: ShowtimeSumAggregateOutputType | null
    _min: ShowtimeMinAggregateOutputType | null
    _max: ShowtimeMaxAggregateOutputType | null
  }

  type GetShowtimeGroupByPayload<T extends ShowtimeGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ShowtimeGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ShowtimeGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ShowtimeGroupByOutputType[P]>
            : GetScalarType<T[P], ShowtimeGroupByOutputType[P]>
        }
      >
    >


  export type ShowtimeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    movieId?: boolean
    auditoriumId?: boolean
    startsAt?: boolean
    endsAt?: boolean
    basePrice?: boolean
    status?: boolean
    seatLayoutVersion?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    movie?: boolean | MovieDefaultArgs<ExtArgs>
    auditorium?: boolean | AuditoriumDefaultArgs<ExtArgs>
    pricingTiers?: boolean | Showtime$pricingTiersArgs<ExtArgs>
    bookings?: boolean | Showtime$bookingsArgs<ExtArgs>
    _count?: boolean | ShowtimeCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["showtime"]>


  export type ShowtimeSelectScalar = {
    id?: boolean
    movieId?: boolean
    auditoriumId?: boolean
    startsAt?: boolean
    endsAt?: boolean
    basePrice?: boolean
    status?: boolean
    seatLayoutVersion?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ShowtimeInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    movie?: boolean | MovieDefaultArgs<ExtArgs>
    auditorium?: boolean | AuditoriumDefaultArgs<ExtArgs>
    pricingTiers?: boolean | Showtime$pricingTiersArgs<ExtArgs>
    bookings?: boolean | Showtime$bookingsArgs<ExtArgs>
    _count?: boolean | ShowtimeCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $ShowtimePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Showtime"
    objects: {
      movie: Prisma.$MoviePayload<ExtArgs>
      auditorium: Prisma.$AuditoriumPayload<ExtArgs>
      pricingTiers: Prisma.$ShowtimePricingTierPayload<ExtArgs>[]
      bookings: Prisma.$BookingPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      movieId: string
      auditoriumId: string
      startsAt: Date
      endsAt: Date
      basePrice: Prisma.Decimal
      status: $Enums.ShowtimeStatus
      seatLayoutVersion: number
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["showtime"]>
    composites: {}
  }

  type ShowtimeGetPayload<S extends boolean | null | undefined | ShowtimeDefaultArgs> = $Result.GetResult<Prisma.$ShowtimePayload, S>

  type ShowtimeCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ShowtimeFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ShowtimeCountAggregateInputType | true
    }

  export interface ShowtimeDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Showtime'], meta: { name: 'Showtime' } }
    /**
     * Find zero or one Showtime that matches the filter.
     * @param {ShowtimeFindUniqueArgs} args - Arguments to find a Showtime
     * @example
     * // Get one Showtime
     * const showtime = await prisma.showtime.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ShowtimeFindUniqueArgs>(args: SelectSubset<T, ShowtimeFindUniqueArgs<ExtArgs>>): Prisma__ShowtimeClient<$Result.GetResult<Prisma.$ShowtimePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Showtime that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ShowtimeFindUniqueOrThrowArgs} args - Arguments to find a Showtime
     * @example
     * // Get one Showtime
     * const showtime = await prisma.showtime.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ShowtimeFindUniqueOrThrowArgs>(args: SelectSubset<T, ShowtimeFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ShowtimeClient<$Result.GetResult<Prisma.$ShowtimePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Showtime that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ShowtimeFindFirstArgs} args - Arguments to find a Showtime
     * @example
     * // Get one Showtime
     * const showtime = await prisma.showtime.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ShowtimeFindFirstArgs>(args?: SelectSubset<T, ShowtimeFindFirstArgs<ExtArgs>>): Prisma__ShowtimeClient<$Result.GetResult<Prisma.$ShowtimePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Showtime that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ShowtimeFindFirstOrThrowArgs} args - Arguments to find a Showtime
     * @example
     * // Get one Showtime
     * const showtime = await prisma.showtime.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ShowtimeFindFirstOrThrowArgs>(args?: SelectSubset<T, ShowtimeFindFirstOrThrowArgs<ExtArgs>>): Prisma__ShowtimeClient<$Result.GetResult<Prisma.$ShowtimePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Showtimes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ShowtimeFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Showtimes
     * const showtimes = await prisma.showtime.findMany()
     * 
     * // Get first 10 Showtimes
     * const showtimes = await prisma.showtime.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const showtimeWithIdOnly = await prisma.showtime.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ShowtimeFindManyArgs>(args?: SelectSubset<T, ShowtimeFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ShowtimePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Showtime.
     * @param {ShowtimeCreateArgs} args - Arguments to create a Showtime.
     * @example
     * // Create one Showtime
     * const Showtime = await prisma.showtime.create({
     *   data: {
     *     // ... data to create a Showtime
     *   }
     * })
     * 
     */
    create<T extends ShowtimeCreateArgs>(args: SelectSubset<T, ShowtimeCreateArgs<ExtArgs>>): Prisma__ShowtimeClient<$Result.GetResult<Prisma.$ShowtimePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Showtimes.
     * @param {ShowtimeCreateManyArgs} args - Arguments to create many Showtimes.
     * @example
     * // Create many Showtimes
     * const showtime = await prisma.showtime.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ShowtimeCreateManyArgs>(args?: SelectSubset<T, ShowtimeCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Showtime.
     * @param {ShowtimeDeleteArgs} args - Arguments to delete one Showtime.
     * @example
     * // Delete one Showtime
     * const Showtime = await prisma.showtime.delete({
     *   where: {
     *     // ... filter to delete one Showtime
     *   }
     * })
     * 
     */
    delete<T extends ShowtimeDeleteArgs>(args: SelectSubset<T, ShowtimeDeleteArgs<ExtArgs>>): Prisma__ShowtimeClient<$Result.GetResult<Prisma.$ShowtimePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Showtime.
     * @param {ShowtimeUpdateArgs} args - Arguments to update one Showtime.
     * @example
     * // Update one Showtime
     * const showtime = await prisma.showtime.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ShowtimeUpdateArgs>(args: SelectSubset<T, ShowtimeUpdateArgs<ExtArgs>>): Prisma__ShowtimeClient<$Result.GetResult<Prisma.$ShowtimePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Showtimes.
     * @param {ShowtimeDeleteManyArgs} args - Arguments to filter Showtimes to delete.
     * @example
     * // Delete a few Showtimes
     * const { count } = await prisma.showtime.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ShowtimeDeleteManyArgs>(args?: SelectSubset<T, ShowtimeDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Showtimes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ShowtimeUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Showtimes
     * const showtime = await prisma.showtime.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ShowtimeUpdateManyArgs>(args: SelectSubset<T, ShowtimeUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Showtime.
     * @param {ShowtimeUpsertArgs} args - Arguments to update or create a Showtime.
     * @example
     * // Update or create a Showtime
     * const showtime = await prisma.showtime.upsert({
     *   create: {
     *     // ... data to create a Showtime
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Showtime we want to update
     *   }
     * })
     */
    upsert<T extends ShowtimeUpsertArgs>(args: SelectSubset<T, ShowtimeUpsertArgs<ExtArgs>>): Prisma__ShowtimeClient<$Result.GetResult<Prisma.$ShowtimePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Showtimes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ShowtimeCountArgs} args - Arguments to filter Showtimes to count.
     * @example
     * // Count the number of Showtimes
     * const count = await prisma.showtime.count({
     *   where: {
     *     // ... the filter for the Showtimes we want to count
     *   }
     * })
    **/
    count<T extends ShowtimeCountArgs>(
      args?: Subset<T, ShowtimeCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ShowtimeCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Showtime.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ShowtimeAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ShowtimeAggregateArgs>(args: Subset<T, ShowtimeAggregateArgs>): Prisma.PrismaPromise<GetShowtimeAggregateType<T>>

    /**
     * Group by Showtime.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ShowtimeGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ShowtimeGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ShowtimeGroupByArgs['orderBy'] }
        : { orderBy?: ShowtimeGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ShowtimeGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetShowtimeGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Showtime model
   */
  readonly fields: ShowtimeFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Showtime.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ShowtimeClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    movie<T extends MovieDefaultArgs<ExtArgs> = {}>(args?: Subset<T, MovieDefaultArgs<ExtArgs>>): Prisma__MovieClient<$Result.GetResult<Prisma.$MoviePayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    auditorium<T extends AuditoriumDefaultArgs<ExtArgs> = {}>(args?: Subset<T, AuditoriumDefaultArgs<ExtArgs>>): Prisma__AuditoriumClient<$Result.GetResult<Prisma.$AuditoriumPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    pricingTiers<T extends Showtime$pricingTiersArgs<ExtArgs> = {}>(args?: Subset<T, Showtime$pricingTiersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ShowtimePricingTierPayload<ExtArgs>, T, "findMany"> | Null>
    bookings<T extends Showtime$bookingsArgs<ExtArgs> = {}>(args?: Subset<T, Showtime$bookingsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BookingPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Showtime model
   */ 
  interface ShowtimeFieldRefs {
    readonly id: FieldRef<"Showtime", 'String'>
    readonly movieId: FieldRef<"Showtime", 'String'>
    readonly auditoriumId: FieldRef<"Showtime", 'String'>
    readonly startsAt: FieldRef<"Showtime", 'DateTime'>
    readonly endsAt: FieldRef<"Showtime", 'DateTime'>
    readonly basePrice: FieldRef<"Showtime", 'Decimal'>
    readonly status: FieldRef<"Showtime", 'ShowtimeStatus'>
    readonly seatLayoutVersion: FieldRef<"Showtime", 'Int'>
    readonly createdAt: FieldRef<"Showtime", 'DateTime'>
    readonly updatedAt: FieldRef<"Showtime", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Showtime findUnique
   */
  export type ShowtimeFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Showtime
     */
    select?: ShowtimeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShowtimeInclude<ExtArgs> | null
    /**
     * Filter, which Showtime to fetch.
     */
    where: ShowtimeWhereUniqueInput
  }

  /**
   * Showtime findUniqueOrThrow
   */
  export type ShowtimeFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Showtime
     */
    select?: ShowtimeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShowtimeInclude<ExtArgs> | null
    /**
     * Filter, which Showtime to fetch.
     */
    where: ShowtimeWhereUniqueInput
  }

  /**
   * Showtime findFirst
   */
  export type ShowtimeFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Showtime
     */
    select?: ShowtimeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShowtimeInclude<ExtArgs> | null
    /**
     * Filter, which Showtime to fetch.
     */
    where?: ShowtimeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Showtimes to fetch.
     */
    orderBy?: ShowtimeOrderByWithRelationInput | ShowtimeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Showtimes.
     */
    cursor?: ShowtimeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Showtimes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Showtimes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Showtimes.
     */
    distinct?: ShowtimeScalarFieldEnum | ShowtimeScalarFieldEnum[]
  }

  /**
   * Showtime findFirstOrThrow
   */
  export type ShowtimeFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Showtime
     */
    select?: ShowtimeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShowtimeInclude<ExtArgs> | null
    /**
     * Filter, which Showtime to fetch.
     */
    where?: ShowtimeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Showtimes to fetch.
     */
    orderBy?: ShowtimeOrderByWithRelationInput | ShowtimeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Showtimes.
     */
    cursor?: ShowtimeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Showtimes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Showtimes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Showtimes.
     */
    distinct?: ShowtimeScalarFieldEnum | ShowtimeScalarFieldEnum[]
  }

  /**
   * Showtime findMany
   */
  export type ShowtimeFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Showtime
     */
    select?: ShowtimeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShowtimeInclude<ExtArgs> | null
    /**
     * Filter, which Showtimes to fetch.
     */
    where?: ShowtimeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Showtimes to fetch.
     */
    orderBy?: ShowtimeOrderByWithRelationInput | ShowtimeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Showtimes.
     */
    cursor?: ShowtimeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Showtimes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Showtimes.
     */
    skip?: number
    distinct?: ShowtimeScalarFieldEnum | ShowtimeScalarFieldEnum[]
  }

  /**
   * Showtime create
   */
  export type ShowtimeCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Showtime
     */
    select?: ShowtimeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShowtimeInclude<ExtArgs> | null
    /**
     * The data needed to create a Showtime.
     */
    data: XOR<ShowtimeCreateInput, ShowtimeUncheckedCreateInput>
  }

  /**
   * Showtime createMany
   */
  export type ShowtimeCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Showtimes.
     */
    data: ShowtimeCreateManyInput | ShowtimeCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Showtime update
   */
  export type ShowtimeUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Showtime
     */
    select?: ShowtimeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShowtimeInclude<ExtArgs> | null
    /**
     * The data needed to update a Showtime.
     */
    data: XOR<ShowtimeUpdateInput, ShowtimeUncheckedUpdateInput>
    /**
     * Choose, which Showtime to update.
     */
    where: ShowtimeWhereUniqueInput
  }

  /**
   * Showtime updateMany
   */
  export type ShowtimeUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Showtimes.
     */
    data: XOR<ShowtimeUpdateManyMutationInput, ShowtimeUncheckedUpdateManyInput>
    /**
     * Filter which Showtimes to update
     */
    where?: ShowtimeWhereInput
  }

  /**
   * Showtime upsert
   */
  export type ShowtimeUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Showtime
     */
    select?: ShowtimeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShowtimeInclude<ExtArgs> | null
    /**
     * The filter to search for the Showtime to update in case it exists.
     */
    where: ShowtimeWhereUniqueInput
    /**
     * In case the Showtime found by the `where` argument doesn't exist, create a new Showtime with this data.
     */
    create: XOR<ShowtimeCreateInput, ShowtimeUncheckedCreateInput>
    /**
     * In case the Showtime was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ShowtimeUpdateInput, ShowtimeUncheckedUpdateInput>
  }

  /**
   * Showtime delete
   */
  export type ShowtimeDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Showtime
     */
    select?: ShowtimeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShowtimeInclude<ExtArgs> | null
    /**
     * Filter which Showtime to delete.
     */
    where: ShowtimeWhereUniqueInput
  }

  /**
   * Showtime deleteMany
   */
  export type ShowtimeDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Showtimes to delete
     */
    where?: ShowtimeWhereInput
  }

  /**
   * Showtime.pricingTiers
   */
  export type Showtime$pricingTiersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ShowtimePricingTier
     */
    select?: ShowtimePricingTierSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShowtimePricingTierInclude<ExtArgs> | null
    where?: ShowtimePricingTierWhereInput
    orderBy?: ShowtimePricingTierOrderByWithRelationInput | ShowtimePricingTierOrderByWithRelationInput[]
    cursor?: ShowtimePricingTierWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ShowtimePricingTierScalarFieldEnum | ShowtimePricingTierScalarFieldEnum[]
  }

  /**
   * Showtime.bookings
   */
  export type Showtime$bookingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Booking
     */
    select?: BookingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingInclude<ExtArgs> | null
    where?: BookingWhereInput
    orderBy?: BookingOrderByWithRelationInput | BookingOrderByWithRelationInput[]
    cursor?: BookingWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BookingScalarFieldEnum | BookingScalarFieldEnum[]
  }

  /**
   * Showtime without action
   */
  export type ShowtimeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Showtime
     */
    select?: ShowtimeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShowtimeInclude<ExtArgs> | null
  }


  /**
   * Model ShowtimePricingTier
   */

  export type AggregateShowtimePricingTier = {
    _count: ShowtimePricingTierCountAggregateOutputType | null
    _avg: ShowtimePricingTierAvgAggregateOutputType | null
    _sum: ShowtimePricingTierSumAggregateOutputType | null
    _min: ShowtimePricingTierMinAggregateOutputType | null
    _max: ShowtimePricingTierMaxAggregateOutputType | null
  }

  export type ShowtimePricingTierAvgAggregateOutputType = {
    price: Decimal | null
  }

  export type ShowtimePricingTierSumAggregateOutputType = {
    price: Decimal | null
  }

  export type ShowtimePricingTierMinAggregateOutputType = {
    id: string | null
    showtimeId: string | null
    label: string | null
    price: Decimal | null
    createdAt: Date | null
  }

  export type ShowtimePricingTierMaxAggregateOutputType = {
    id: string | null
    showtimeId: string | null
    label: string | null
    price: Decimal | null
    createdAt: Date | null
  }

  export type ShowtimePricingTierCountAggregateOutputType = {
    id: number
    showtimeId: number
    label: number
    price: number
    seatTypes: number
    createdAt: number
    _all: number
  }


  export type ShowtimePricingTierAvgAggregateInputType = {
    price?: true
  }

  export type ShowtimePricingTierSumAggregateInputType = {
    price?: true
  }

  export type ShowtimePricingTierMinAggregateInputType = {
    id?: true
    showtimeId?: true
    label?: true
    price?: true
    createdAt?: true
  }

  export type ShowtimePricingTierMaxAggregateInputType = {
    id?: true
    showtimeId?: true
    label?: true
    price?: true
    createdAt?: true
  }

  export type ShowtimePricingTierCountAggregateInputType = {
    id?: true
    showtimeId?: true
    label?: true
    price?: true
    seatTypes?: true
    createdAt?: true
    _all?: true
  }

  export type ShowtimePricingTierAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ShowtimePricingTier to aggregate.
     */
    where?: ShowtimePricingTierWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ShowtimePricingTiers to fetch.
     */
    orderBy?: ShowtimePricingTierOrderByWithRelationInput | ShowtimePricingTierOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ShowtimePricingTierWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ShowtimePricingTiers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ShowtimePricingTiers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ShowtimePricingTiers
    **/
    _count?: true | ShowtimePricingTierCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ShowtimePricingTierAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ShowtimePricingTierSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ShowtimePricingTierMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ShowtimePricingTierMaxAggregateInputType
  }

  export type GetShowtimePricingTierAggregateType<T extends ShowtimePricingTierAggregateArgs> = {
        [P in keyof T & keyof AggregateShowtimePricingTier]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateShowtimePricingTier[P]>
      : GetScalarType<T[P], AggregateShowtimePricingTier[P]>
  }




  export type ShowtimePricingTierGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ShowtimePricingTierWhereInput
    orderBy?: ShowtimePricingTierOrderByWithAggregationInput | ShowtimePricingTierOrderByWithAggregationInput[]
    by: ShowtimePricingTierScalarFieldEnum[] | ShowtimePricingTierScalarFieldEnum
    having?: ShowtimePricingTierScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ShowtimePricingTierCountAggregateInputType | true
    _avg?: ShowtimePricingTierAvgAggregateInputType
    _sum?: ShowtimePricingTierSumAggregateInputType
    _min?: ShowtimePricingTierMinAggregateInputType
    _max?: ShowtimePricingTierMaxAggregateInputType
  }

  export type ShowtimePricingTierGroupByOutputType = {
    id: string
    showtimeId: string
    label: string
    price: Decimal
    seatTypes: JsonValue
    createdAt: Date
    _count: ShowtimePricingTierCountAggregateOutputType | null
    _avg: ShowtimePricingTierAvgAggregateOutputType | null
    _sum: ShowtimePricingTierSumAggregateOutputType | null
    _min: ShowtimePricingTierMinAggregateOutputType | null
    _max: ShowtimePricingTierMaxAggregateOutputType | null
  }

  type GetShowtimePricingTierGroupByPayload<T extends ShowtimePricingTierGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ShowtimePricingTierGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ShowtimePricingTierGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ShowtimePricingTierGroupByOutputType[P]>
            : GetScalarType<T[P], ShowtimePricingTierGroupByOutputType[P]>
        }
      >
    >


  export type ShowtimePricingTierSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    showtimeId?: boolean
    label?: boolean
    price?: boolean
    seatTypes?: boolean
    createdAt?: boolean
    showtime?: boolean | ShowtimeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["showtimePricingTier"]>


  export type ShowtimePricingTierSelectScalar = {
    id?: boolean
    showtimeId?: boolean
    label?: boolean
    price?: boolean
    seatTypes?: boolean
    createdAt?: boolean
  }

  export type ShowtimePricingTierInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    showtime?: boolean | ShowtimeDefaultArgs<ExtArgs>
  }

  export type $ShowtimePricingTierPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ShowtimePricingTier"
    objects: {
      showtime: Prisma.$ShowtimePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      showtimeId: string
      label: string
      price: Prisma.Decimal
      seatTypes: Prisma.JsonValue
      createdAt: Date
    }, ExtArgs["result"]["showtimePricingTier"]>
    composites: {}
  }

  type ShowtimePricingTierGetPayload<S extends boolean | null | undefined | ShowtimePricingTierDefaultArgs> = $Result.GetResult<Prisma.$ShowtimePricingTierPayload, S>

  type ShowtimePricingTierCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ShowtimePricingTierFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ShowtimePricingTierCountAggregateInputType | true
    }

  export interface ShowtimePricingTierDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ShowtimePricingTier'], meta: { name: 'ShowtimePricingTier' } }
    /**
     * Find zero or one ShowtimePricingTier that matches the filter.
     * @param {ShowtimePricingTierFindUniqueArgs} args - Arguments to find a ShowtimePricingTier
     * @example
     * // Get one ShowtimePricingTier
     * const showtimePricingTier = await prisma.showtimePricingTier.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ShowtimePricingTierFindUniqueArgs>(args: SelectSubset<T, ShowtimePricingTierFindUniqueArgs<ExtArgs>>): Prisma__ShowtimePricingTierClient<$Result.GetResult<Prisma.$ShowtimePricingTierPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one ShowtimePricingTier that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ShowtimePricingTierFindUniqueOrThrowArgs} args - Arguments to find a ShowtimePricingTier
     * @example
     * // Get one ShowtimePricingTier
     * const showtimePricingTier = await prisma.showtimePricingTier.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ShowtimePricingTierFindUniqueOrThrowArgs>(args: SelectSubset<T, ShowtimePricingTierFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ShowtimePricingTierClient<$Result.GetResult<Prisma.$ShowtimePricingTierPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first ShowtimePricingTier that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ShowtimePricingTierFindFirstArgs} args - Arguments to find a ShowtimePricingTier
     * @example
     * // Get one ShowtimePricingTier
     * const showtimePricingTier = await prisma.showtimePricingTier.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ShowtimePricingTierFindFirstArgs>(args?: SelectSubset<T, ShowtimePricingTierFindFirstArgs<ExtArgs>>): Prisma__ShowtimePricingTierClient<$Result.GetResult<Prisma.$ShowtimePricingTierPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first ShowtimePricingTier that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ShowtimePricingTierFindFirstOrThrowArgs} args - Arguments to find a ShowtimePricingTier
     * @example
     * // Get one ShowtimePricingTier
     * const showtimePricingTier = await prisma.showtimePricingTier.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ShowtimePricingTierFindFirstOrThrowArgs>(args?: SelectSubset<T, ShowtimePricingTierFindFirstOrThrowArgs<ExtArgs>>): Prisma__ShowtimePricingTierClient<$Result.GetResult<Prisma.$ShowtimePricingTierPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more ShowtimePricingTiers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ShowtimePricingTierFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ShowtimePricingTiers
     * const showtimePricingTiers = await prisma.showtimePricingTier.findMany()
     * 
     * // Get first 10 ShowtimePricingTiers
     * const showtimePricingTiers = await prisma.showtimePricingTier.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const showtimePricingTierWithIdOnly = await prisma.showtimePricingTier.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ShowtimePricingTierFindManyArgs>(args?: SelectSubset<T, ShowtimePricingTierFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ShowtimePricingTierPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a ShowtimePricingTier.
     * @param {ShowtimePricingTierCreateArgs} args - Arguments to create a ShowtimePricingTier.
     * @example
     * // Create one ShowtimePricingTier
     * const ShowtimePricingTier = await prisma.showtimePricingTier.create({
     *   data: {
     *     // ... data to create a ShowtimePricingTier
     *   }
     * })
     * 
     */
    create<T extends ShowtimePricingTierCreateArgs>(args: SelectSubset<T, ShowtimePricingTierCreateArgs<ExtArgs>>): Prisma__ShowtimePricingTierClient<$Result.GetResult<Prisma.$ShowtimePricingTierPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many ShowtimePricingTiers.
     * @param {ShowtimePricingTierCreateManyArgs} args - Arguments to create many ShowtimePricingTiers.
     * @example
     * // Create many ShowtimePricingTiers
     * const showtimePricingTier = await prisma.showtimePricingTier.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ShowtimePricingTierCreateManyArgs>(args?: SelectSubset<T, ShowtimePricingTierCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a ShowtimePricingTier.
     * @param {ShowtimePricingTierDeleteArgs} args - Arguments to delete one ShowtimePricingTier.
     * @example
     * // Delete one ShowtimePricingTier
     * const ShowtimePricingTier = await prisma.showtimePricingTier.delete({
     *   where: {
     *     // ... filter to delete one ShowtimePricingTier
     *   }
     * })
     * 
     */
    delete<T extends ShowtimePricingTierDeleteArgs>(args: SelectSubset<T, ShowtimePricingTierDeleteArgs<ExtArgs>>): Prisma__ShowtimePricingTierClient<$Result.GetResult<Prisma.$ShowtimePricingTierPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one ShowtimePricingTier.
     * @param {ShowtimePricingTierUpdateArgs} args - Arguments to update one ShowtimePricingTier.
     * @example
     * // Update one ShowtimePricingTier
     * const showtimePricingTier = await prisma.showtimePricingTier.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ShowtimePricingTierUpdateArgs>(args: SelectSubset<T, ShowtimePricingTierUpdateArgs<ExtArgs>>): Prisma__ShowtimePricingTierClient<$Result.GetResult<Prisma.$ShowtimePricingTierPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more ShowtimePricingTiers.
     * @param {ShowtimePricingTierDeleteManyArgs} args - Arguments to filter ShowtimePricingTiers to delete.
     * @example
     * // Delete a few ShowtimePricingTiers
     * const { count } = await prisma.showtimePricingTier.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ShowtimePricingTierDeleteManyArgs>(args?: SelectSubset<T, ShowtimePricingTierDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ShowtimePricingTiers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ShowtimePricingTierUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ShowtimePricingTiers
     * const showtimePricingTier = await prisma.showtimePricingTier.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ShowtimePricingTierUpdateManyArgs>(args: SelectSubset<T, ShowtimePricingTierUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ShowtimePricingTier.
     * @param {ShowtimePricingTierUpsertArgs} args - Arguments to update or create a ShowtimePricingTier.
     * @example
     * // Update or create a ShowtimePricingTier
     * const showtimePricingTier = await prisma.showtimePricingTier.upsert({
     *   create: {
     *     // ... data to create a ShowtimePricingTier
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ShowtimePricingTier we want to update
     *   }
     * })
     */
    upsert<T extends ShowtimePricingTierUpsertArgs>(args: SelectSubset<T, ShowtimePricingTierUpsertArgs<ExtArgs>>): Prisma__ShowtimePricingTierClient<$Result.GetResult<Prisma.$ShowtimePricingTierPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of ShowtimePricingTiers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ShowtimePricingTierCountArgs} args - Arguments to filter ShowtimePricingTiers to count.
     * @example
     * // Count the number of ShowtimePricingTiers
     * const count = await prisma.showtimePricingTier.count({
     *   where: {
     *     // ... the filter for the ShowtimePricingTiers we want to count
     *   }
     * })
    **/
    count<T extends ShowtimePricingTierCountArgs>(
      args?: Subset<T, ShowtimePricingTierCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ShowtimePricingTierCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ShowtimePricingTier.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ShowtimePricingTierAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ShowtimePricingTierAggregateArgs>(args: Subset<T, ShowtimePricingTierAggregateArgs>): Prisma.PrismaPromise<GetShowtimePricingTierAggregateType<T>>

    /**
     * Group by ShowtimePricingTier.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ShowtimePricingTierGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ShowtimePricingTierGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ShowtimePricingTierGroupByArgs['orderBy'] }
        : { orderBy?: ShowtimePricingTierGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ShowtimePricingTierGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetShowtimePricingTierGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ShowtimePricingTier model
   */
  readonly fields: ShowtimePricingTierFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ShowtimePricingTier.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ShowtimePricingTierClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    showtime<T extends ShowtimeDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ShowtimeDefaultArgs<ExtArgs>>): Prisma__ShowtimeClient<$Result.GetResult<Prisma.$ShowtimePayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ShowtimePricingTier model
   */ 
  interface ShowtimePricingTierFieldRefs {
    readonly id: FieldRef<"ShowtimePricingTier", 'String'>
    readonly showtimeId: FieldRef<"ShowtimePricingTier", 'String'>
    readonly label: FieldRef<"ShowtimePricingTier", 'String'>
    readonly price: FieldRef<"ShowtimePricingTier", 'Decimal'>
    readonly seatTypes: FieldRef<"ShowtimePricingTier", 'Json'>
    readonly createdAt: FieldRef<"ShowtimePricingTier", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ShowtimePricingTier findUnique
   */
  export type ShowtimePricingTierFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ShowtimePricingTier
     */
    select?: ShowtimePricingTierSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShowtimePricingTierInclude<ExtArgs> | null
    /**
     * Filter, which ShowtimePricingTier to fetch.
     */
    where: ShowtimePricingTierWhereUniqueInput
  }

  /**
   * ShowtimePricingTier findUniqueOrThrow
   */
  export type ShowtimePricingTierFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ShowtimePricingTier
     */
    select?: ShowtimePricingTierSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShowtimePricingTierInclude<ExtArgs> | null
    /**
     * Filter, which ShowtimePricingTier to fetch.
     */
    where: ShowtimePricingTierWhereUniqueInput
  }

  /**
   * ShowtimePricingTier findFirst
   */
  export type ShowtimePricingTierFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ShowtimePricingTier
     */
    select?: ShowtimePricingTierSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShowtimePricingTierInclude<ExtArgs> | null
    /**
     * Filter, which ShowtimePricingTier to fetch.
     */
    where?: ShowtimePricingTierWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ShowtimePricingTiers to fetch.
     */
    orderBy?: ShowtimePricingTierOrderByWithRelationInput | ShowtimePricingTierOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ShowtimePricingTiers.
     */
    cursor?: ShowtimePricingTierWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ShowtimePricingTiers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ShowtimePricingTiers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ShowtimePricingTiers.
     */
    distinct?: ShowtimePricingTierScalarFieldEnum | ShowtimePricingTierScalarFieldEnum[]
  }

  /**
   * ShowtimePricingTier findFirstOrThrow
   */
  export type ShowtimePricingTierFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ShowtimePricingTier
     */
    select?: ShowtimePricingTierSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShowtimePricingTierInclude<ExtArgs> | null
    /**
     * Filter, which ShowtimePricingTier to fetch.
     */
    where?: ShowtimePricingTierWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ShowtimePricingTiers to fetch.
     */
    orderBy?: ShowtimePricingTierOrderByWithRelationInput | ShowtimePricingTierOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ShowtimePricingTiers.
     */
    cursor?: ShowtimePricingTierWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ShowtimePricingTiers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ShowtimePricingTiers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ShowtimePricingTiers.
     */
    distinct?: ShowtimePricingTierScalarFieldEnum | ShowtimePricingTierScalarFieldEnum[]
  }

  /**
   * ShowtimePricingTier findMany
   */
  export type ShowtimePricingTierFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ShowtimePricingTier
     */
    select?: ShowtimePricingTierSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShowtimePricingTierInclude<ExtArgs> | null
    /**
     * Filter, which ShowtimePricingTiers to fetch.
     */
    where?: ShowtimePricingTierWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ShowtimePricingTiers to fetch.
     */
    orderBy?: ShowtimePricingTierOrderByWithRelationInput | ShowtimePricingTierOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ShowtimePricingTiers.
     */
    cursor?: ShowtimePricingTierWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ShowtimePricingTiers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ShowtimePricingTiers.
     */
    skip?: number
    distinct?: ShowtimePricingTierScalarFieldEnum | ShowtimePricingTierScalarFieldEnum[]
  }

  /**
   * ShowtimePricingTier create
   */
  export type ShowtimePricingTierCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ShowtimePricingTier
     */
    select?: ShowtimePricingTierSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShowtimePricingTierInclude<ExtArgs> | null
    /**
     * The data needed to create a ShowtimePricingTier.
     */
    data: XOR<ShowtimePricingTierCreateInput, ShowtimePricingTierUncheckedCreateInput>
  }

  /**
   * ShowtimePricingTier createMany
   */
  export type ShowtimePricingTierCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ShowtimePricingTiers.
     */
    data: ShowtimePricingTierCreateManyInput | ShowtimePricingTierCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ShowtimePricingTier update
   */
  export type ShowtimePricingTierUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ShowtimePricingTier
     */
    select?: ShowtimePricingTierSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShowtimePricingTierInclude<ExtArgs> | null
    /**
     * The data needed to update a ShowtimePricingTier.
     */
    data: XOR<ShowtimePricingTierUpdateInput, ShowtimePricingTierUncheckedUpdateInput>
    /**
     * Choose, which ShowtimePricingTier to update.
     */
    where: ShowtimePricingTierWhereUniqueInput
  }

  /**
   * ShowtimePricingTier updateMany
   */
  export type ShowtimePricingTierUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ShowtimePricingTiers.
     */
    data: XOR<ShowtimePricingTierUpdateManyMutationInput, ShowtimePricingTierUncheckedUpdateManyInput>
    /**
     * Filter which ShowtimePricingTiers to update
     */
    where?: ShowtimePricingTierWhereInput
  }

  /**
   * ShowtimePricingTier upsert
   */
  export type ShowtimePricingTierUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ShowtimePricingTier
     */
    select?: ShowtimePricingTierSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShowtimePricingTierInclude<ExtArgs> | null
    /**
     * The filter to search for the ShowtimePricingTier to update in case it exists.
     */
    where: ShowtimePricingTierWhereUniqueInput
    /**
     * In case the ShowtimePricingTier found by the `where` argument doesn't exist, create a new ShowtimePricingTier with this data.
     */
    create: XOR<ShowtimePricingTierCreateInput, ShowtimePricingTierUncheckedCreateInput>
    /**
     * In case the ShowtimePricingTier was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ShowtimePricingTierUpdateInput, ShowtimePricingTierUncheckedUpdateInput>
  }

  /**
   * ShowtimePricingTier delete
   */
  export type ShowtimePricingTierDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ShowtimePricingTier
     */
    select?: ShowtimePricingTierSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShowtimePricingTierInclude<ExtArgs> | null
    /**
     * Filter which ShowtimePricingTier to delete.
     */
    where: ShowtimePricingTierWhereUniqueInput
  }

  /**
   * ShowtimePricingTier deleteMany
   */
  export type ShowtimePricingTierDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ShowtimePricingTiers to delete
     */
    where?: ShowtimePricingTierWhereInput
  }

  /**
   * ShowtimePricingTier without action
   */
  export type ShowtimePricingTierDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ShowtimePricingTier
     */
    select?: ShowtimePricingTierSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShowtimePricingTierInclude<ExtArgs> | null
  }


  /**
   * Model Booking
   */

  export type AggregateBooking = {
    _count: BookingCountAggregateOutputType | null
    _avg: BookingAvgAggregateOutputType | null
    _sum: BookingSumAggregateOutputType | null
    _min: BookingMinAggregateOutputType | null
    _max: BookingMaxAggregateOutputType | null
  }

  export type BookingAvgAggregateOutputType = {
    totalAmount: Decimal | null
  }

  export type BookingSumAggregateOutputType = {
    totalAmount: Decimal | null
  }

  export type BookingMinAggregateOutputType = {
    id: string | null
    reference: string | null
    showtimeId: string | null
    userId: string | null
    purchaserEmail: string | null
    purchaserName: string | null
    status: $Enums.BookingStatus | null
    totalAmount: Decimal | null
    currency: string | null
    purchasedAt: Date | null
    movieTitle: string | null
  }

  export type BookingMaxAggregateOutputType = {
    id: string | null
    reference: string | null
    showtimeId: string | null
    userId: string | null
    purchaserEmail: string | null
    purchaserName: string | null
    status: $Enums.BookingStatus | null
    totalAmount: Decimal | null
    currency: string | null
    purchasedAt: Date | null
    movieTitle: string | null
  }

  export type BookingCountAggregateOutputType = {
    id: number
    reference: number
    showtimeId: number
    userId: number
    purchaserEmail: number
    purchaserName: number
    status: number
    totalAmount: number
    currency: number
    purchasedAt: number
    movieTitle: number
    _all: number
  }


  export type BookingAvgAggregateInputType = {
    totalAmount?: true
  }

  export type BookingSumAggregateInputType = {
    totalAmount?: true
  }

  export type BookingMinAggregateInputType = {
    id?: true
    reference?: true
    showtimeId?: true
    userId?: true
    purchaserEmail?: true
    purchaserName?: true
    status?: true
    totalAmount?: true
    currency?: true
    purchasedAt?: true
    movieTitle?: true
  }

  export type BookingMaxAggregateInputType = {
    id?: true
    reference?: true
    showtimeId?: true
    userId?: true
    purchaserEmail?: true
    purchaserName?: true
    status?: true
    totalAmount?: true
    currency?: true
    purchasedAt?: true
    movieTitle?: true
  }

  export type BookingCountAggregateInputType = {
    id?: true
    reference?: true
    showtimeId?: true
    userId?: true
    purchaserEmail?: true
    purchaserName?: true
    status?: true
    totalAmount?: true
    currency?: true
    purchasedAt?: true
    movieTitle?: true
    _all?: true
  }

  export type BookingAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Booking to aggregate.
     */
    where?: BookingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Bookings to fetch.
     */
    orderBy?: BookingOrderByWithRelationInput | BookingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: BookingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Bookings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Bookings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Bookings
    **/
    _count?: true | BookingCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: BookingAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: BookingSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BookingMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BookingMaxAggregateInputType
  }

  export type GetBookingAggregateType<T extends BookingAggregateArgs> = {
        [P in keyof T & keyof AggregateBooking]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBooking[P]>
      : GetScalarType<T[P], AggregateBooking[P]>
  }




  export type BookingGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BookingWhereInput
    orderBy?: BookingOrderByWithAggregationInput | BookingOrderByWithAggregationInput[]
    by: BookingScalarFieldEnum[] | BookingScalarFieldEnum
    having?: BookingScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BookingCountAggregateInputType | true
    _avg?: BookingAvgAggregateInputType
    _sum?: BookingSumAggregateInputType
    _min?: BookingMinAggregateInputType
    _max?: BookingMaxAggregateInputType
  }

  export type BookingGroupByOutputType = {
    id: string
    reference: string
    showtimeId: string
    userId: string | null
    purchaserEmail: string
    purchaserName: string
    status: $Enums.BookingStatus
    totalAmount: Decimal
    currency: string
    purchasedAt: Date
    movieTitle: string
    _count: BookingCountAggregateOutputType | null
    _avg: BookingAvgAggregateOutputType | null
    _sum: BookingSumAggregateOutputType | null
    _min: BookingMinAggregateOutputType | null
    _max: BookingMaxAggregateOutputType | null
  }

  type GetBookingGroupByPayload<T extends BookingGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<BookingGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BookingGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BookingGroupByOutputType[P]>
            : GetScalarType<T[P], BookingGroupByOutputType[P]>
        }
      >
    >


  export type BookingSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    reference?: boolean
    showtimeId?: boolean
    userId?: boolean
    purchaserEmail?: boolean
    purchaserName?: boolean
    status?: boolean
    totalAmount?: boolean
    currency?: boolean
    purchasedAt?: boolean
    movieTitle?: boolean
    user?: boolean | Booking$userArgs<ExtArgs>
    showtime?: boolean | ShowtimeDefaultArgs<ExtArgs>
    tickets?: boolean | Booking$ticketsArgs<ExtArgs>
    auditLog?: boolean | Booking$auditLogArgs<ExtArgs>
    settlements?: boolean | Booking$settlementsArgs<ExtArgs>
    _count?: boolean | BookingCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["booking"]>


  export type BookingSelectScalar = {
    id?: boolean
    reference?: boolean
    showtimeId?: boolean
    userId?: boolean
    purchaserEmail?: boolean
    purchaserName?: boolean
    status?: boolean
    totalAmount?: boolean
    currency?: boolean
    purchasedAt?: boolean
    movieTitle?: boolean
  }

  export type BookingInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | Booking$userArgs<ExtArgs>
    showtime?: boolean | ShowtimeDefaultArgs<ExtArgs>
    tickets?: boolean | Booking$ticketsArgs<ExtArgs>
    auditLog?: boolean | Booking$auditLogArgs<ExtArgs>
    settlements?: boolean | Booking$settlementsArgs<ExtArgs>
    _count?: boolean | BookingCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $BookingPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Booking"
    objects: {
      user: Prisma.$UserPayload<ExtArgs> | null
      showtime: Prisma.$ShowtimePayload<ExtArgs>
      tickets: Prisma.$BookingTicketPayload<ExtArgs>[]
      auditLog: Prisma.$BookingAuditPayload<ExtArgs>[]
      settlements: Prisma.$SettlementTransactionPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      reference: string
      showtimeId: string
      userId: string | null
      purchaserEmail: string
      purchaserName: string
      status: $Enums.BookingStatus
      totalAmount: Prisma.Decimal
      currency: string
      purchasedAt: Date
      movieTitle: string
    }, ExtArgs["result"]["booking"]>
    composites: {}
  }

  type BookingGetPayload<S extends boolean | null | undefined | BookingDefaultArgs> = $Result.GetResult<Prisma.$BookingPayload, S>

  type BookingCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<BookingFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: BookingCountAggregateInputType | true
    }

  export interface BookingDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Booking'], meta: { name: 'Booking' } }
    /**
     * Find zero or one Booking that matches the filter.
     * @param {BookingFindUniqueArgs} args - Arguments to find a Booking
     * @example
     * // Get one Booking
     * const booking = await prisma.booking.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends BookingFindUniqueArgs>(args: SelectSubset<T, BookingFindUniqueArgs<ExtArgs>>): Prisma__BookingClient<$Result.GetResult<Prisma.$BookingPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Booking that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {BookingFindUniqueOrThrowArgs} args - Arguments to find a Booking
     * @example
     * // Get one Booking
     * const booking = await prisma.booking.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends BookingFindUniqueOrThrowArgs>(args: SelectSubset<T, BookingFindUniqueOrThrowArgs<ExtArgs>>): Prisma__BookingClient<$Result.GetResult<Prisma.$BookingPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Booking that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BookingFindFirstArgs} args - Arguments to find a Booking
     * @example
     * // Get one Booking
     * const booking = await prisma.booking.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends BookingFindFirstArgs>(args?: SelectSubset<T, BookingFindFirstArgs<ExtArgs>>): Prisma__BookingClient<$Result.GetResult<Prisma.$BookingPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Booking that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BookingFindFirstOrThrowArgs} args - Arguments to find a Booking
     * @example
     * // Get one Booking
     * const booking = await prisma.booking.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends BookingFindFirstOrThrowArgs>(args?: SelectSubset<T, BookingFindFirstOrThrowArgs<ExtArgs>>): Prisma__BookingClient<$Result.GetResult<Prisma.$BookingPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Bookings that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BookingFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Bookings
     * const bookings = await prisma.booking.findMany()
     * 
     * // Get first 10 Bookings
     * const bookings = await prisma.booking.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const bookingWithIdOnly = await prisma.booking.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends BookingFindManyArgs>(args?: SelectSubset<T, BookingFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BookingPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Booking.
     * @param {BookingCreateArgs} args - Arguments to create a Booking.
     * @example
     * // Create one Booking
     * const Booking = await prisma.booking.create({
     *   data: {
     *     // ... data to create a Booking
     *   }
     * })
     * 
     */
    create<T extends BookingCreateArgs>(args: SelectSubset<T, BookingCreateArgs<ExtArgs>>): Prisma__BookingClient<$Result.GetResult<Prisma.$BookingPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Bookings.
     * @param {BookingCreateManyArgs} args - Arguments to create many Bookings.
     * @example
     * // Create many Bookings
     * const booking = await prisma.booking.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends BookingCreateManyArgs>(args?: SelectSubset<T, BookingCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Booking.
     * @param {BookingDeleteArgs} args - Arguments to delete one Booking.
     * @example
     * // Delete one Booking
     * const Booking = await prisma.booking.delete({
     *   where: {
     *     // ... filter to delete one Booking
     *   }
     * })
     * 
     */
    delete<T extends BookingDeleteArgs>(args: SelectSubset<T, BookingDeleteArgs<ExtArgs>>): Prisma__BookingClient<$Result.GetResult<Prisma.$BookingPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Booking.
     * @param {BookingUpdateArgs} args - Arguments to update one Booking.
     * @example
     * // Update one Booking
     * const booking = await prisma.booking.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends BookingUpdateArgs>(args: SelectSubset<T, BookingUpdateArgs<ExtArgs>>): Prisma__BookingClient<$Result.GetResult<Prisma.$BookingPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Bookings.
     * @param {BookingDeleteManyArgs} args - Arguments to filter Bookings to delete.
     * @example
     * // Delete a few Bookings
     * const { count } = await prisma.booking.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends BookingDeleteManyArgs>(args?: SelectSubset<T, BookingDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Bookings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BookingUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Bookings
     * const booking = await prisma.booking.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends BookingUpdateManyArgs>(args: SelectSubset<T, BookingUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Booking.
     * @param {BookingUpsertArgs} args - Arguments to update or create a Booking.
     * @example
     * // Update or create a Booking
     * const booking = await prisma.booking.upsert({
     *   create: {
     *     // ... data to create a Booking
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Booking we want to update
     *   }
     * })
     */
    upsert<T extends BookingUpsertArgs>(args: SelectSubset<T, BookingUpsertArgs<ExtArgs>>): Prisma__BookingClient<$Result.GetResult<Prisma.$BookingPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Bookings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BookingCountArgs} args - Arguments to filter Bookings to count.
     * @example
     * // Count the number of Bookings
     * const count = await prisma.booking.count({
     *   where: {
     *     // ... the filter for the Bookings we want to count
     *   }
     * })
    **/
    count<T extends BookingCountArgs>(
      args?: Subset<T, BookingCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BookingCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Booking.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BookingAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BookingAggregateArgs>(args: Subset<T, BookingAggregateArgs>): Prisma.PrismaPromise<GetBookingAggregateType<T>>

    /**
     * Group by Booking.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BookingGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends BookingGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: BookingGroupByArgs['orderBy'] }
        : { orderBy?: BookingGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, BookingGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBookingGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Booking model
   */
  readonly fields: BookingFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Booking.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__BookingClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends Booking$userArgs<ExtArgs> = {}>(args?: Subset<T, Booking$userArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    showtime<T extends ShowtimeDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ShowtimeDefaultArgs<ExtArgs>>): Prisma__ShowtimeClient<$Result.GetResult<Prisma.$ShowtimePayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    tickets<T extends Booking$ticketsArgs<ExtArgs> = {}>(args?: Subset<T, Booking$ticketsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BookingTicketPayload<ExtArgs>, T, "findMany"> | Null>
    auditLog<T extends Booking$auditLogArgs<ExtArgs> = {}>(args?: Subset<T, Booking$auditLogArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BookingAuditPayload<ExtArgs>, T, "findMany"> | Null>
    settlements<T extends Booking$settlementsArgs<ExtArgs> = {}>(args?: Subset<T, Booking$settlementsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SettlementTransactionPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Booking model
   */ 
  interface BookingFieldRefs {
    readonly id: FieldRef<"Booking", 'String'>
    readonly reference: FieldRef<"Booking", 'String'>
    readonly showtimeId: FieldRef<"Booking", 'String'>
    readonly userId: FieldRef<"Booking", 'String'>
    readonly purchaserEmail: FieldRef<"Booking", 'String'>
    readonly purchaserName: FieldRef<"Booking", 'String'>
    readonly status: FieldRef<"Booking", 'BookingStatus'>
    readonly totalAmount: FieldRef<"Booking", 'Decimal'>
    readonly currency: FieldRef<"Booking", 'String'>
    readonly purchasedAt: FieldRef<"Booking", 'DateTime'>
    readonly movieTitle: FieldRef<"Booking", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Booking findUnique
   */
  export type BookingFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Booking
     */
    select?: BookingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingInclude<ExtArgs> | null
    /**
     * Filter, which Booking to fetch.
     */
    where: BookingWhereUniqueInput
  }

  /**
   * Booking findUniqueOrThrow
   */
  export type BookingFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Booking
     */
    select?: BookingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingInclude<ExtArgs> | null
    /**
     * Filter, which Booking to fetch.
     */
    where: BookingWhereUniqueInput
  }

  /**
   * Booking findFirst
   */
  export type BookingFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Booking
     */
    select?: BookingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingInclude<ExtArgs> | null
    /**
     * Filter, which Booking to fetch.
     */
    where?: BookingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Bookings to fetch.
     */
    orderBy?: BookingOrderByWithRelationInput | BookingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Bookings.
     */
    cursor?: BookingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Bookings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Bookings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Bookings.
     */
    distinct?: BookingScalarFieldEnum | BookingScalarFieldEnum[]
  }

  /**
   * Booking findFirstOrThrow
   */
  export type BookingFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Booking
     */
    select?: BookingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingInclude<ExtArgs> | null
    /**
     * Filter, which Booking to fetch.
     */
    where?: BookingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Bookings to fetch.
     */
    orderBy?: BookingOrderByWithRelationInput | BookingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Bookings.
     */
    cursor?: BookingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Bookings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Bookings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Bookings.
     */
    distinct?: BookingScalarFieldEnum | BookingScalarFieldEnum[]
  }

  /**
   * Booking findMany
   */
  export type BookingFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Booking
     */
    select?: BookingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingInclude<ExtArgs> | null
    /**
     * Filter, which Bookings to fetch.
     */
    where?: BookingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Bookings to fetch.
     */
    orderBy?: BookingOrderByWithRelationInput | BookingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Bookings.
     */
    cursor?: BookingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Bookings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Bookings.
     */
    skip?: number
    distinct?: BookingScalarFieldEnum | BookingScalarFieldEnum[]
  }

  /**
   * Booking create
   */
  export type BookingCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Booking
     */
    select?: BookingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingInclude<ExtArgs> | null
    /**
     * The data needed to create a Booking.
     */
    data: XOR<BookingCreateInput, BookingUncheckedCreateInput>
  }

  /**
   * Booking createMany
   */
  export type BookingCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Bookings.
     */
    data: BookingCreateManyInput | BookingCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Booking update
   */
  export type BookingUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Booking
     */
    select?: BookingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingInclude<ExtArgs> | null
    /**
     * The data needed to update a Booking.
     */
    data: XOR<BookingUpdateInput, BookingUncheckedUpdateInput>
    /**
     * Choose, which Booking to update.
     */
    where: BookingWhereUniqueInput
  }

  /**
   * Booking updateMany
   */
  export type BookingUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Bookings.
     */
    data: XOR<BookingUpdateManyMutationInput, BookingUncheckedUpdateManyInput>
    /**
     * Filter which Bookings to update
     */
    where?: BookingWhereInput
  }

  /**
   * Booking upsert
   */
  export type BookingUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Booking
     */
    select?: BookingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingInclude<ExtArgs> | null
    /**
     * The filter to search for the Booking to update in case it exists.
     */
    where: BookingWhereUniqueInput
    /**
     * In case the Booking found by the `where` argument doesn't exist, create a new Booking with this data.
     */
    create: XOR<BookingCreateInput, BookingUncheckedCreateInput>
    /**
     * In case the Booking was found with the provided `where` argument, update it with this data.
     */
    update: XOR<BookingUpdateInput, BookingUncheckedUpdateInput>
  }

  /**
   * Booking delete
   */
  export type BookingDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Booking
     */
    select?: BookingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingInclude<ExtArgs> | null
    /**
     * Filter which Booking to delete.
     */
    where: BookingWhereUniqueInput
  }

  /**
   * Booking deleteMany
   */
  export type BookingDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Bookings to delete
     */
    where?: BookingWhereInput
  }

  /**
   * Booking.user
   */
  export type Booking$userArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * Booking.tickets
   */
  export type Booking$ticketsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BookingTicket
     */
    select?: BookingTicketSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingTicketInclude<ExtArgs> | null
    where?: BookingTicketWhereInput
    orderBy?: BookingTicketOrderByWithRelationInput | BookingTicketOrderByWithRelationInput[]
    cursor?: BookingTicketWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BookingTicketScalarFieldEnum | BookingTicketScalarFieldEnum[]
  }

  /**
   * Booking.auditLog
   */
  export type Booking$auditLogArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BookingAudit
     */
    select?: BookingAuditSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingAuditInclude<ExtArgs> | null
    where?: BookingAuditWhereInput
    orderBy?: BookingAuditOrderByWithRelationInput | BookingAuditOrderByWithRelationInput[]
    cursor?: BookingAuditWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BookingAuditScalarFieldEnum | BookingAuditScalarFieldEnum[]
  }

  /**
   * Booking.settlements
   */
  export type Booking$settlementsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SettlementTransaction
     */
    select?: SettlementTransactionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SettlementTransactionInclude<ExtArgs> | null
    where?: SettlementTransactionWhereInput
    orderBy?: SettlementTransactionOrderByWithRelationInput | SettlementTransactionOrderByWithRelationInput[]
    cursor?: SettlementTransactionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SettlementTransactionScalarFieldEnum | SettlementTransactionScalarFieldEnum[]
  }

  /**
   * Booking without action
   */
  export type BookingDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Booking
     */
    select?: BookingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingInclude<ExtArgs> | null
  }


  /**
   * Model BookingTicket
   */

  export type AggregateBookingTicket = {
    _count: BookingTicketCountAggregateOutputType | null
    _avg: BookingTicketAvgAggregateOutputType | null
    _sum: BookingTicketSumAggregateOutputType | null
    _min: BookingTicketMinAggregateOutputType | null
    _max: BookingTicketMaxAggregateOutputType | null
  }

  export type BookingTicketAvgAggregateOutputType = {
    price: Decimal | null
  }

  export type BookingTicketSumAggregateOutputType = {
    price: Decimal | null
  }

  export type BookingTicketMinAggregateOutputType = {
    id: string | null
    bookingId: string | null
    seatId: string | null
    seatLabel: string | null
    price: Decimal | null
    tierLabel: string | null
    tierId: string | null
  }

  export type BookingTicketMaxAggregateOutputType = {
    id: string | null
    bookingId: string | null
    seatId: string | null
    seatLabel: string | null
    price: Decimal | null
    tierLabel: string | null
    tierId: string | null
  }

  export type BookingTicketCountAggregateOutputType = {
    id: number
    bookingId: number
    seatId: number
    seatLabel: number
    price: number
    tierLabel: number
    tierId: number
    _all: number
  }


  export type BookingTicketAvgAggregateInputType = {
    price?: true
  }

  export type BookingTicketSumAggregateInputType = {
    price?: true
  }

  export type BookingTicketMinAggregateInputType = {
    id?: true
    bookingId?: true
    seatId?: true
    seatLabel?: true
    price?: true
    tierLabel?: true
    tierId?: true
  }

  export type BookingTicketMaxAggregateInputType = {
    id?: true
    bookingId?: true
    seatId?: true
    seatLabel?: true
    price?: true
    tierLabel?: true
    tierId?: true
  }

  export type BookingTicketCountAggregateInputType = {
    id?: true
    bookingId?: true
    seatId?: true
    seatLabel?: true
    price?: true
    tierLabel?: true
    tierId?: true
    _all?: true
  }

  export type BookingTicketAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BookingTicket to aggregate.
     */
    where?: BookingTicketWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BookingTickets to fetch.
     */
    orderBy?: BookingTicketOrderByWithRelationInput | BookingTicketOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: BookingTicketWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BookingTickets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BookingTickets.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned BookingTickets
    **/
    _count?: true | BookingTicketCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: BookingTicketAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: BookingTicketSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BookingTicketMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BookingTicketMaxAggregateInputType
  }

  export type GetBookingTicketAggregateType<T extends BookingTicketAggregateArgs> = {
        [P in keyof T & keyof AggregateBookingTicket]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBookingTicket[P]>
      : GetScalarType<T[P], AggregateBookingTicket[P]>
  }




  export type BookingTicketGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BookingTicketWhereInput
    orderBy?: BookingTicketOrderByWithAggregationInput | BookingTicketOrderByWithAggregationInput[]
    by: BookingTicketScalarFieldEnum[] | BookingTicketScalarFieldEnum
    having?: BookingTicketScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BookingTicketCountAggregateInputType | true
    _avg?: BookingTicketAvgAggregateInputType
    _sum?: BookingTicketSumAggregateInputType
    _min?: BookingTicketMinAggregateInputType
    _max?: BookingTicketMaxAggregateInputType
  }

  export type BookingTicketGroupByOutputType = {
    id: string
    bookingId: string
    seatId: string
    seatLabel: string
    price: Decimal
    tierLabel: string | null
    tierId: string | null
    _count: BookingTicketCountAggregateOutputType | null
    _avg: BookingTicketAvgAggregateOutputType | null
    _sum: BookingTicketSumAggregateOutputType | null
    _min: BookingTicketMinAggregateOutputType | null
    _max: BookingTicketMaxAggregateOutputType | null
  }

  type GetBookingTicketGroupByPayload<T extends BookingTicketGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<BookingTicketGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BookingTicketGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BookingTicketGroupByOutputType[P]>
            : GetScalarType<T[P], BookingTicketGroupByOutputType[P]>
        }
      >
    >


  export type BookingTicketSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    bookingId?: boolean
    seatId?: boolean
    seatLabel?: boolean
    price?: boolean
    tierLabel?: boolean
    tierId?: boolean
    booking?: boolean | BookingDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["bookingTicket"]>


  export type BookingTicketSelectScalar = {
    id?: boolean
    bookingId?: boolean
    seatId?: boolean
    seatLabel?: boolean
    price?: boolean
    tierLabel?: boolean
    tierId?: boolean
  }

  export type BookingTicketInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    booking?: boolean | BookingDefaultArgs<ExtArgs>
  }

  export type $BookingTicketPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "BookingTicket"
    objects: {
      booking: Prisma.$BookingPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      bookingId: string
      seatId: string
      seatLabel: string
      price: Prisma.Decimal
      tierLabel: string | null
      tierId: string | null
    }, ExtArgs["result"]["bookingTicket"]>
    composites: {}
  }

  type BookingTicketGetPayload<S extends boolean | null | undefined | BookingTicketDefaultArgs> = $Result.GetResult<Prisma.$BookingTicketPayload, S>

  type BookingTicketCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<BookingTicketFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: BookingTicketCountAggregateInputType | true
    }

  export interface BookingTicketDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['BookingTicket'], meta: { name: 'BookingTicket' } }
    /**
     * Find zero or one BookingTicket that matches the filter.
     * @param {BookingTicketFindUniqueArgs} args - Arguments to find a BookingTicket
     * @example
     * // Get one BookingTicket
     * const bookingTicket = await prisma.bookingTicket.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends BookingTicketFindUniqueArgs>(args: SelectSubset<T, BookingTicketFindUniqueArgs<ExtArgs>>): Prisma__BookingTicketClient<$Result.GetResult<Prisma.$BookingTicketPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one BookingTicket that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {BookingTicketFindUniqueOrThrowArgs} args - Arguments to find a BookingTicket
     * @example
     * // Get one BookingTicket
     * const bookingTicket = await prisma.bookingTicket.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends BookingTicketFindUniqueOrThrowArgs>(args: SelectSubset<T, BookingTicketFindUniqueOrThrowArgs<ExtArgs>>): Prisma__BookingTicketClient<$Result.GetResult<Prisma.$BookingTicketPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first BookingTicket that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BookingTicketFindFirstArgs} args - Arguments to find a BookingTicket
     * @example
     * // Get one BookingTicket
     * const bookingTicket = await prisma.bookingTicket.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends BookingTicketFindFirstArgs>(args?: SelectSubset<T, BookingTicketFindFirstArgs<ExtArgs>>): Prisma__BookingTicketClient<$Result.GetResult<Prisma.$BookingTicketPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first BookingTicket that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BookingTicketFindFirstOrThrowArgs} args - Arguments to find a BookingTicket
     * @example
     * // Get one BookingTicket
     * const bookingTicket = await prisma.bookingTicket.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends BookingTicketFindFirstOrThrowArgs>(args?: SelectSubset<T, BookingTicketFindFirstOrThrowArgs<ExtArgs>>): Prisma__BookingTicketClient<$Result.GetResult<Prisma.$BookingTicketPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more BookingTickets that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BookingTicketFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all BookingTickets
     * const bookingTickets = await prisma.bookingTicket.findMany()
     * 
     * // Get first 10 BookingTickets
     * const bookingTickets = await prisma.bookingTicket.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const bookingTicketWithIdOnly = await prisma.bookingTicket.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends BookingTicketFindManyArgs>(args?: SelectSubset<T, BookingTicketFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BookingTicketPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a BookingTicket.
     * @param {BookingTicketCreateArgs} args - Arguments to create a BookingTicket.
     * @example
     * // Create one BookingTicket
     * const BookingTicket = await prisma.bookingTicket.create({
     *   data: {
     *     // ... data to create a BookingTicket
     *   }
     * })
     * 
     */
    create<T extends BookingTicketCreateArgs>(args: SelectSubset<T, BookingTicketCreateArgs<ExtArgs>>): Prisma__BookingTicketClient<$Result.GetResult<Prisma.$BookingTicketPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many BookingTickets.
     * @param {BookingTicketCreateManyArgs} args - Arguments to create many BookingTickets.
     * @example
     * // Create many BookingTickets
     * const bookingTicket = await prisma.bookingTicket.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends BookingTicketCreateManyArgs>(args?: SelectSubset<T, BookingTicketCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a BookingTicket.
     * @param {BookingTicketDeleteArgs} args - Arguments to delete one BookingTicket.
     * @example
     * // Delete one BookingTicket
     * const BookingTicket = await prisma.bookingTicket.delete({
     *   where: {
     *     // ... filter to delete one BookingTicket
     *   }
     * })
     * 
     */
    delete<T extends BookingTicketDeleteArgs>(args: SelectSubset<T, BookingTicketDeleteArgs<ExtArgs>>): Prisma__BookingTicketClient<$Result.GetResult<Prisma.$BookingTicketPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one BookingTicket.
     * @param {BookingTicketUpdateArgs} args - Arguments to update one BookingTicket.
     * @example
     * // Update one BookingTicket
     * const bookingTicket = await prisma.bookingTicket.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends BookingTicketUpdateArgs>(args: SelectSubset<T, BookingTicketUpdateArgs<ExtArgs>>): Prisma__BookingTicketClient<$Result.GetResult<Prisma.$BookingTicketPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more BookingTickets.
     * @param {BookingTicketDeleteManyArgs} args - Arguments to filter BookingTickets to delete.
     * @example
     * // Delete a few BookingTickets
     * const { count } = await prisma.bookingTicket.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends BookingTicketDeleteManyArgs>(args?: SelectSubset<T, BookingTicketDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more BookingTickets.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BookingTicketUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many BookingTickets
     * const bookingTicket = await prisma.bookingTicket.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends BookingTicketUpdateManyArgs>(args: SelectSubset<T, BookingTicketUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one BookingTicket.
     * @param {BookingTicketUpsertArgs} args - Arguments to update or create a BookingTicket.
     * @example
     * // Update or create a BookingTicket
     * const bookingTicket = await prisma.bookingTicket.upsert({
     *   create: {
     *     // ... data to create a BookingTicket
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the BookingTicket we want to update
     *   }
     * })
     */
    upsert<T extends BookingTicketUpsertArgs>(args: SelectSubset<T, BookingTicketUpsertArgs<ExtArgs>>): Prisma__BookingTicketClient<$Result.GetResult<Prisma.$BookingTicketPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of BookingTickets.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BookingTicketCountArgs} args - Arguments to filter BookingTickets to count.
     * @example
     * // Count the number of BookingTickets
     * const count = await prisma.bookingTicket.count({
     *   where: {
     *     // ... the filter for the BookingTickets we want to count
     *   }
     * })
    **/
    count<T extends BookingTicketCountArgs>(
      args?: Subset<T, BookingTicketCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BookingTicketCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a BookingTicket.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BookingTicketAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BookingTicketAggregateArgs>(args: Subset<T, BookingTicketAggregateArgs>): Prisma.PrismaPromise<GetBookingTicketAggregateType<T>>

    /**
     * Group by BookingTicket.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BookingTicketGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends BookingTicketGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: BookingTicketGroupByArgs['orderBy'] }
        : { orderBy?: BookingTicketGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, BookingTicketGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBookingTicketGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the BookingTicket model
   */
  readonly fields: BookingTicketFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for BookingTicket.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__BookingTicketClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    booking<T extends BookingDefaultArgs<ExtArgs> = {}>(args?: Subset<T, BookingDefaultArgs<ExtArgs>>): Prisma__BookingClient<$Result.GetResult<Prisma.$BookingPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the BookingTicket model
   */ 
  interface BookingTicketFieldRefs {
    readonly id: FieldRef<"BookingTicket", 'String'>
    readonly bookingId: FieldRef<"BookingTicket", 'String'>
    readonly seatId: FieldRef<"BookingTicket", 'String'>
    readonly seatLabel: FieldRef<"BookingTicket", 'String'>
    readonly price: FieldRef<"BookingTicket", 'Decimal'>
    readonly tierLabel: FieldRef<"BookingTicket", 'String'>
    readonly tierId: FieldRef<"BookingTicket", 'String'>
  }
    

  // Custom InputTypes
  /**
   * BookingTicket findUnique
   */
  export type BookingTicketFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BookingTicket
     */
    select?: BookingTicketSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingTicketInclude<ExtArgs> | null
    /**
     * Filter, which BookingTicket to fetch.
     */
    where: BookingTicketWhereUniqueInput
  }

  /**
   * BookingTicket findUniqueOrThrow
   */
  export type BookingTicketFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BookingTicket
     */
    select?: BookingTicketSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingTicketInclude<ExtArgs> | null
    /**
     * Filter, which BookingTicket to fetch.
     */
    where: BookingTicketWhereUniqueInput
  }

  /**
   * BookingTicket findFirst
   */
  export type BookingTicketFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BookingTicket
     */
    select?: BookingTicketSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingTicketInclude<ExtArgs> | null
    /**
     * Filter, which BookingTicket to fetch.
     */
    where?: BookingTicketWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BookingTickets to fetch.
     */
    orderBy?: BookingTicketOrderByWithRelationInput | BookingTicketOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BookingTickets.
     */
    cursor?: BookingTicketWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BookingTickets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BookingTickets.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BookingTickets.
     */
    distinct?: BookingTicketScalarFieldEnum | BookingTicketScalarFieldEnum[]
  }

  /**
   * BookingTicket findFirstOrThrow
   */
  export type BookingTicketFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BookingTicket
     */
    select?: BookingTicketSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingTicketInclude<ExtArgs> | null
    /**
     * Filter, which BookingTicket to fetch.
     */
    where?: BookingTicketWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BookingTickets to fetch.
     */
    orderBy?: BookingTicketOrderByWithRelationInput | BookingTicketOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BookingTickets.
     */
    cursor?: BookingTicketWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BookingTickets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BookingTickets.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BookingTickets.
     */
    distinct?: BookingTicketScalarFieldEnum | BookingTicketScalarFieldEnum[]
  }

  /**
   * BookingTicket findMany
   */
  export type BookingTicketFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BookingTicket
     */
    select?: BookingTicketSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingTicketInclude<ExtArgs> | null
    /**
     * Filter, which BookingTickets to fetch.
     */
    where?: BookingTicketWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BookingTickets to fetch.
     */
    orderBy?: BookingTicketOrderByWithRelationInput | BookingTicketOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing BookingTickets.
     */
    cursor?: BookingTicketWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BookingTickets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BookingTickets.
     */
    skip?: number
    distinct?: BookingTicketScalarFieldEnum | BookingTicketScalarFieldEnum[]
  }

  /**
   * BookingTicket create
   */
  export type BookingTicketCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BookingTicket
     */
    select?: BookingTicketSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingTicketInclude<ExtArgs> | null
    /**
     * The data needed to create a BookingTicket.
     */
    data: XOR<BookingTicketCreateInput, BookingTicketUncheckedCreateInput>
  }

  /**
   * BookingTicket createMany
   */
  export type BookingTicketCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many BookingTickets.
     */
    data: BookingTicketCreateManyInput | BookingTicketCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * BookingTicket update
   */
  export type BookingTicketUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BookingTicket
     */
    select?: BookingTicketSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingTicketInclude<ExtArgs> | null
    /**
     * The data needed to update a BookingTicket.
     */
    data: XOR<BookingTicketUpdateInput, BookingTicketUncheckedUpdateInput>
    /**
     * Choose, which BookingTicket to update.
     */
    where: BookingTicketWhereUniqueInput
  }

  /**
   * BookingTicket updateMany
   */
  export type BookingTicketUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update BookingTickets.
     */
    data: XOR<BookingTicketUpdateManyMutationInput, BookingTicketUncheckedUpdateManyInput>
    /**
     * Filter which BookingTickets to update
     */
    where?: BookingTicketWhereInput
  }

  /**
   * BookingTicket upsert
   */
  export type BookingTicketUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BookingTicket
     */
    select?: BookingTicketSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingTicketInclude<ExtArgs> | null
    /**
     * The filter to search for the BookingTicket to update in case it exists.
     */
    where: BookingTicketWhereUniqueInput
    /**
     * In case the BookingTicket found by the `where` argument doesn't exist, create a new BookingTicket with this data.
     */
    create: XOR<BookingTicketCreateInput, BookingTicketUncheckedCreateInput>
    /**
     * In case the BookingTicket was found with the provided `where` argument, update it with this data.
     */
    update: XOR<BookingTicketUpdateInput, BookingTicketUncheckedUpdateInput>
  }

  /**
   * BookingTicket delete
   */
  export type BookingTicketDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BookingTicket
     */
    select?: BookingTicketSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingTicketInclude<ExtArgs> | null
    /**
     * Filter which BookingTicket to delete.
     */
    where: BookingTicketWhereUniqueInput
  }

  /**
   * BookingTicket deleteMany
   */
  export type BookingTicketDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BookingTickets to delete
     */
    where?: BookingTicketWhereInput
  }

  /**
   * BookingTicket without action
   */
  export type BookingTicketDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BookingTicket
     */
    select?: BookingTicketSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingTicketInclude<ExtArgs> | null
  }


  /**
   * Model BookingAudit
   */

  export type AggregateBookingAudit = {
    _count: BookingAuditCountAggregateOutputType | null
    _min: BookingAuditMinAggregateOutputType | null
    _max: BookingAuditMaxAggregateOutputType | null
  }

  export type BookingAuditMinAggregateOutputType = {
    id: string | null
    bookingId: string | null
    type: string | null
    message: string | null
    actor: string | null
    createdAt: Date | null
  }

  export type BookingAuditMaxAggregateOutputType = {
    id: string | null
    bookingId: string | null
    type: string | null
    message: string | null
    actor: string | null
    createdAt: Date | null
  }

  export type BookingAuditCountAggregateOutputType = {
    id: number
    bookingId: number
    type: number
    message: number
    actor: number
    createdAt: number
    _all: number
  }


  export type BookingAuditMinAggregateInputType = {
    id?: true
    bookingId?: true
    type?: true
    message?: true
    actor?: true
    createdAt?: true
  }

  export type BookingAuditMaxAggregateInputType = {
    id?: true
    bookingId?: true
    type?: true
    message?: true
    actor?: true
    createdAt?: true
  }

  export type BookingAuditCountAggregateInputType = {
    id?: true
    bookingId?: true
    type?: true
    message?: true
    actor?: true
    createdAt?: true
    _all?: true
  }

  export type BookingAuditAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BookingAudit to aggregate.
     */
    where?: BookingAuditWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BookingAudits to fetch.
     */
    orderBy?: BookingAuditOrderByWithRelationInput | BookingAuditOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: BookingAuditWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BookingAudits from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BookingAudits.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned BookingAudits
    **/
    _count?: true | BookingAuditCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BookingAuditMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BookingAuditMaxAggregateInputType
  }

  export type GetBookingAuditAggregateType<T extends BookingAuditAggregateArgs> = {
        [P in keyof T & keyof AggregateBookingAudit]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBookingAudit[P]>
      : GetScalarType<T[P], AggregateBookingAudit[P]>
  }




  export type BookingAuditGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BookingAuditWhereInput
    orderBy?: BookingAuditOrderByWithAggregationInput | BookingAuditOrderByWithAggregationInput[]
    by: BookingAuditScalarFieldEnum[] | BookingAuditScalarFieldEnum
    having?: BookingAuditScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BookingAuditCountAggregateInputType | true
    _min?: BookingAuditMinAggregateInputType
    _max?: BookingAuditMaxAggregateInputType
  }

  export type BookingAuditGroupByOutputType = {
    id: string
    bookingId: string
    type: string
    message: string
    actor: string
    createdAt: Date
    _count: BookingAuditCountAggregateOutputType | null
    _min: BookingAuditMinAggregateOutputType | null
    _max: BookingAuditMaxAggregateOutputType | null
  }

  type GetBookingAuditGroupByPayload<T extends BookingAuditGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<BookingAuditGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BookingAuditGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BookingAuditGroupByOutputType[P]>
            : GetScalarType<T[P], BookingAuditGroupByOutputType[P]>
        }
      >
    >


  export type BookingAuditSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    bookingId?: boolean
    type?: boolean
    message?: boolean
    actor?: boolean
    createdAt?: boolean
    booking?: boolean | BookingDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["bookingAudit"]>


  export type BookingAuditSelectScalar = {
    id?: boolean
    bookingId?: boolean
    type?: boolean
    message?: boolean
    actor?: boolean
    createdAt?: boolean
  }

  export type BookingAuditInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    booking?: boolean | BookingDefaultArgs<ExtArgs>
  }

  export type $BookingAuditPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "BookingAudit"
    objects: {
      booking: Prisma.$BookingPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      bookingId: string
      type: string
      message: string
      actor: string
      createdAt: Date
    }, ExtArgs["result"]["bookingAudit"]>
    composites: {}
  }

  type BookingAuditGetPayload<S extends boolean | null | undefined | BookingAuditDefaultArgs> = $Result.GetResult<Prisma.$BookingAuditPayload, S>

  type BookingAuditCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<BookingAuditFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: BookingAuditCountAggregateInputType | true
    }

  export interface BookingAuditDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['BookingAudit'], meta: { name: 'BookingAudit' } }
    /**
     * Find zero or one BookingAudit that matches the filter.
     * @param {BookingAuditFindUniqueArgs} args - Arguments to find a BookingAudit
     * @example
     * // Get one BookingAudit
     * const bookingAudit = await prisma.bookingAudit.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends BookingAuditFindUniqueArgs>(args: SelectSubset<T, BookingAuditFindUniqueArgs<ExtArgs>>): Prisma__BookingAuditClient<$Result.GetResult<Prisma.$BookingAuditPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one BookingAudit that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {BookingAuditFindUniqueOrThrowArgs} args - Arguments to find a BookingAudit
     * @example
     * // Get one BookingAudit
     * const bookingAudit = await prisma.bookingAudit.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends BookingAuditFindUniqueOrThrowArgs>(args: SelectSubset<T, BookingAuditFindUniqueOrThrowArgs<ExtArgs>>): Prisma__BookingAuditClient<$Result.GetResult<Prisma.$BookingAuditPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first BookingAudit that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BookingAuditFindFirstArgs} args - Arguments to find a BookingAudit
     * @example
     * // Get one BookingAudit
     * const bookingAudit = await prisma.bookingAudit.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends BookingAuditFindFirstArgs>(args?: SelectSubset<T, BookingAuditFindFirstArgs<ExtArgs>>): Prisma__BookingAuditClient<$Result.GetResult<Prisma.$BookingAuditPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first BookingAudit that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BookingAuditFindFirstOrThrowArgs} args - Arguments to find a BookingAudit
     * @example
     * // Get one BookingAudit
     * const bookingAudit = await prisma.bookingAudit.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends BookingAuditFindFirstOrThrowArgs>(args?: SelectSubset<T, BookingAuditFindFirstOrThrowArgs<ExtArgs>>): Prisma__BookingAuditClient<$Result.GetResult<Prisma.$BookingAuditPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more BookingAudits that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BookingAuditFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all BookingAudits
     * const bookingAudits = await prisma.bookingAudit.findMany()
     * 
     * // Get first 10 BookingAudits
     * const bookingAudits = await prisma.bookingAudit.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const bookingAuditWithIdOnly = await prisma.bookingAudit.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends BookingAuditFindManyArgs>(args?: SelectSubset<T, BookingAuditFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BookingAuditPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a BookingAudit.
     * @param {BookingAuditCreateArgs} args - Arguments to create a BookingAudit.
     * @example
     * // Create one BookingAudit
     * const BookingAudit = await prisma.bookingAudit.create({
     *   data: {
     *     // ... data to create a BookingAudit
     *   }
     * })
     * 
     */
    create<T extends BookingAuditCreateArgs>(args: SelectSubset<T, BookingAuditCreateArgs<ExtArgs>>): Prisma__BookingAuditClient<$Result.GetResult<Prisma.$BookingAuditPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many BookingAudits.
     * @param {BookingAuditCreateManyArgs} args - Arguments to create many BookingAudits.
     * @example
     * // Create many BookingAudits
     * const bookingAudit = await prisma.bookingAudit.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends BookingAuditCreateManyArgs>(args?: SelectSubset<T, BookingAuditCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a BookingAudit.
     * @param {BookingAuditDeleteArgs} args - Arguments to delete one BookingAudit.
     * @example
     * // Delete one BookingAudit
     * const BookingAudit = await prisma.bookingAudit.delete({
     *   where: {
     *     // ... filter to delete one BookingAudit
     *   }
     * })
     * 
     */
    delete<T extends BookingAuditDeleteArgs>(args: SelectSubset<T, BookingAuditDeleteArgs<ExtArgs>>): Prisma__BookingAuditClient<$Result.GetResult<Prisma.$BookingAuditPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one BookingAudit.
     * @param {BookingAuditUpdateArgs} args - Arguments to update one BookingAudit.
     * @example
     * // Update one BookingAudit
     * const bookingAudit = await prisma.bookingAudit.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends BookingAuditUpdateArgs>(args: SelectSubset<T, BookingAuditUpdateArgs<ExtArgs>>): Prisma__BookingAuditClient<$Result.GetResult<Prisma.$BookingAuditPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more BookingAudits.
     * @param {BookingAuditDeleteManyArgs} args - Arguments to filter BookingAudits to delete.
     * @example
     * // Delete a few BookingAudits
     * const { count } = await prisma.bookingAudit.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends BookingAuditDeleteManyArgs>(args?: SelectSubset<T, BookingAuditDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more BookingAudits.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BookingAuditUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many BookingAudits
     * const bookingAudit = await prisma.bookingAudit.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends BookingAuditUpdateManyArgs>(args: SelectSubset<T, BookingAuditUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one BookingAudit.
     * @param {BookingAuditUpsertArgs} args - Arguments to update or create a BookingAudit.
     * @example
     * // Update or create a BookingAudit
     * const bookingAudit = await prisma.bookingAudit.upsert({
     *   create: {
     *     // ... data to create a BookingAudit
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the BookingAudit we want to update
     *   }
     * })
     */
    upsert<T extends BookingAuditUpsertArgs>(args: SelectSubset<T, BookingAuditUpsertArgs<ExtArgs>>): Prisma__BookingAuditClient<$Result.GetResult<Prisma.$BookingAuditPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of BookingAudits.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BookingAuditCountArgs} args - Arguments to filter BookingAudits to count.
     * @example
     * // Count the number of BookingAudits
     * const count = await prisma.bookingAudit.count({
     *   where: {
     *     // ... the filter for the BookingAudits we want to count
     *   }
     * })
    **/
    count<T extends BookingAuditCountArgs>(
      args?: Subset<T, BookingAuditCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BookingAuditCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a BookingAudit.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BookingAuditAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BookingAuditAggregateArgs>(args: Subset<T, BookingAuditAggregateArgs>): Prisma.PrismaPromise<GetBookingAuditAggregateType<T>>

    /**
     * Group by BookingAudit.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BookingAuditGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends BookingAuditGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: BookingAuditGroupByArgs['orderBy'] }
        : { orderBy?: BookingAuditGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, BookingAuditGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBookingAuditGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the BookingAudit model
   */
  readonly fields: BookingAuditFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for BookingAudit.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__BookingAuditClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    booking<T extends BookingDefaultArgs<ExtArgs> = {}>(args?: Subset<T, BookingDefaultArgs<ExtArgs>>): Prisma__BookingClient<$Result.GetResult<Prisma.$BookingPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the BookingAudit model
   */ 
  interface BookingAuditFieldRefs {
    readonly id: FieldRef<"BookingAudit", 'String'>
    readonly bookingId: FieldRef<"BookingAudit", 'String'>
    readonly type: FieldRef<"BookingAudit", 'String'>
    readonly message: FieldRef<"BookingAudit", 'String'>
    readonly actor: FieldRef<"BookingAudit", 'String'>
    readonly createdAt: FieldRef<"BookingAudit", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * BookingAudit findUnique
   */
  export type BookingAuditFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BookingAudit
     */
    select?: BookingAuditSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingAuditInclude<ExtArgs> | null
    /**
     * Filter, which BookingAudit to fetch.
     */
    where: BookingAuditWhereUniqueInput
  }

  /**
   * BookingAudit findUniqueOrThrow
   */
  export type BookingAuditFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BookingAudit
     */
    select?: BookingAuditSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingAuditInclude<ExtArgs> | null
    /**
     * Filter, which BookingAudit to fetch.
     */
    where: BookingAuditWhereUniqueInput
  }

  /**
   * BookingAudit findFirst
   */
  export type BookingAuditFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BookingAudit
     */
    select?: BookingAuditSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingAuditInclude<ExtArgs> | null
    /**
     * Filter, which BookingAudit to fetch.
     */
    where?: BookingAuditWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BookingAudits to fetch.
     */
    orderBy?: BookingAuditOrderByWithRelationInput | BookingAuditOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BookingAudits.
     */
    cursor?: BookingAuditWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BookingAudits from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BookingAudits.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BookingAudits.
     */
    distinct?: BookingAuditScalarFieldEnum | BookingAuditScalarFieldEnum[]
  }

  /**
   * BookingAudit findFirstOrThrow
   */
  export type BookingAuditFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BookingAudit
     */
    select?: BookingAuditSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingAuditInclude<ExtArgs> | null
    /**
     * Filter, which BookingAudit to fetch.
     */
    where?: BookingAuditWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BookingAudits to fetch.
     */
    orderBy?: BookingAuditOrderByWithRelationInput | BookingAuditOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BookingAudits.
     */
    cursor?: BookingAuditWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BookingAudits from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BookingAudits.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BookingAudits.
     */
    distinct?: BookingAuditScalarFieldEnum | BookingAuditScalarFieldEnum[]
  }

  /**
   * BookingAudit findMany
   */
  export type BookingAuditFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BookingAudit
     */
    select?: BookingAuditSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingAuditInclude<ExtArgs> | null
    /**
     * Filter, which BookingAudits to fetch.
     */
    where?: BookingAuditWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BookingAudits to fetch.
     */
    orderBy?: BookingAuditOrderByWithRelationInput | BookingAuditOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing BookingAudits.
     */
    cursor?: BookingAuditWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BookingAudits from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BookingAudits.
     */
    skip?: number
    distinct?: BookingAuditScalarFieldEnum | BookingAuditScalarFieldEnum[]
  }

  /**
   * BookingAudit create
   */
  export type BookingAuditCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BookingAudit
     */
    select?: BookingAuditSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingAuditInclude<ExtArgs> | null
    /**
     * The data needed to create a BookingAudit.
     */
    data: XOR<BookingAuditCreateInput, BookingAuditUncheckedCreateInput>
  }

  /**
   * BookingAudit createMany
   */
  export type BookingAuditCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many BookingAudits.
     */
    data: BookingAuditCreateManyInput | BookingAuditCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * BookingAudit update
   */
  export type BookingAuditUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BookingAudit
     */
    select?: BookingAuditSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingAuditInclude<ExtArgs> | null
    /**
     * The data needed to update a BookingAudit.
     */
    data: XOR<BookingAuditUpdateInput, BookingAuditUncheckedUpdateInput>
    /**
     * Choose, which BookingAudit to update.
     */
    where: BookingAuditWhereUniqueInput
  }

  /**
   * BookingAudit updateMany
   */
  export type BookingAuditUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update BookingAudits.
     */
    data: XOR<BookingAuditUpdateManyMutationInput, BookingAuditUncheckedUpdateManyInput>
    /**
     * Filter which BookingAudits to update
     */
    where?: BookingAuditWhereInput
  }

  /**
   * BookingAudit upsert
   */
  export type BookingAuditUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BookingAudit
     */
    select?: BookingAuditSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingAuditInclude<ExtArgs> | null
    /**
     * The filter to search for the BookingAudit to update in case it exists.
     */
    where: BookingAuditWhereUniqueInput
    /**
     * In case the BookingAudit found by the `where` argument doesn't exist, create a new BookingAudit with this data.
     */
    create: XOR<BookingAuditCreateInput, BookingAuditUncheckedCreateInput>
    /**
     * In case the BookingAudit was found with the provided `where` argument, update it with this data.
     */
    update: XOR<BookingAuditUpdateInput, BookingAuditUncheckedUpdateInput>
  }

  /**
   * BookingAudit delete
   */
  export type BookingAuditDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BookingAudit
     */
    select?: BookingAuditSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingAuditInclude<ExtArgs> | null
    /**
     * Filter which BookingAudit to delete.
     */
    where: BookingAuditWhereUniqueInput
  }

  /**
   * BookingAudit deleteMany
   */
  export type BookingAuditDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BookingAudits to delete
     */
    where?: BookingAuditWhereInput
  }

  /**
   * BookingAudit without action
   */
  export type BookingAuditDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BookingAudit
     */
    select?: BookingAuditSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingAuditInclude<ExtArgs> | null
  }


  /**
   * Model SettlementTransaction
   */

  export type AggregateSettlementTransaction = {
    _count: SettlementTransactionCountAggregateOutputType | null
    _avg: SettlementTransactionAvgAggregateOutputType | null
    _sum: SettlementTransactionSumAggregateOutputType | null
    _min: SettlementTransactionMinAggregateOutputType | null
    _max: SettlementTransactionMaxAggregateOutputType | null
  }

  export type SettlementTransactionAvgAggregateOutputType = {
    amount: Decimal | null
    fees: Decimal | null
    netPayout: Decimal | null
  }

  export type SettlementTransactionSumAggregateOutputType = {
    amount: Decimal | null
    fees: Decimal | null
    netPayout: Decimal | null
  }

  export type SettlementTransactionMinAggregateOutputType = {
    id: string | null
    gateway: string | null
    transactionId: string | null
    amount: Decimal | null
    currency: string | null
    status: $Enums.SettlementStatus | null
    fees: Decimal | null
    netPayout: Decimal | null
    settledAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
    bookingId: string | null
  }

  export type SettlementTransactionMaxAggregateOutputType = {
    id: string | null
    gateway: string | null
    transactionId: string | null
    amount: Decimal | null
    currency: string | null
    status: $Enums.SettlementStatus | null
    fees: Decimal | null
    netPayout: Decimal | null
    settledAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
    bookingId: string | null
  }

  export type SettlementTransactionCountAggregateOutputType = {
    id: number
    gateway: number
    transactionId: number
    amount: number
    currency: number
    status: number
    fees: number
    netPayout: number
    settledAt: number
    createdAt: number
    updatedAt: number
    bookingId: number
    _all: number
  }


  export type SettlementTransactionAvgAggregateInputType = {
    amount?: true
    fees?: true
    netPayout?: true
  }

  export type SettlementTransactionSumAggregateInputType = {
    amount?: true
    fees?: true
    netPayout?: true
  }

  export type SettlementTransactionMinAggregateInputType = {
    id?: true
    gateway?: true
    transactionId?: true
    amount?: true
    currency?: true
    status?: true
    fees?: true
    netPayout?: true
    settledAt?: true
    createdAt?: true
    updatedAt?: true
    bookingId?: true
  }

  export type SettlementTransactionMaxAggregateInputType = {
    id?: true
    gateway?: true
    transactionId?: true
    amount?: true
    currency?: true
    status?: true
    fees?: true
    netPayout?: true
    settledAt?: true
    createdAt?: true
    updatedAt?: true
    bookingId?: true
  }

  export type SettlementTransactionCountAggregateInputType = {
    id?: true
    gateway?: true
    transactionId?: true
    amount?: true
    currency?: true
    status?: true
    fees?: true
    netPayout?: true
    settledAt?: true
    createdAt?: true
    updatedAt?: true
    bookingId?: true
    _all?: true
  }

  export type SettlementTransactionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SettlementTransaction to aggregate.
     */
    where?: SettlementTransactionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SettlementTransactions to fetch.
     */
    orderBy?: SettlementTransactionOrderByWithRelationInput | SettlementTransactionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SettlementTransactionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SettlementTransactions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SettlementTransactions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned SettlementTransactions
    **/
    _count?: true | SettlementTransactionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SettlementTransactionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SettlementTransactionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SettlementTransactionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SettlementTransactionMaxAggregateInputType
  }

  export type GetSettlementTransactionAggregateType<T extends SettlementTransactionAggregateArgs> = {
        [P in keyof T & keyof AggregateSettlementTransaction]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSettlementTransaction[P]>
      : GetScalarType<T[P], AggregateSettlementTransaction[P]>
  }




  export type SettlementTransactionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SettlementTransactionWhereInput
    orderBy?: SettlementTransactionOrderByWithAggregationInput | SettlementTransactionOrderByWithAggregationInput[]
    by: SettlementTransactionScalarFieldEnum[] | SettlementTransactionScalarFieldEnum
    having?: SettlementTransactionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SettlementTransactionCountAggregateInputType | true
    _avg?: SettlementTransactionAvgAggregateInputType
    _sum?: SettlementTransactionSumAggregateInputType
    _min?: SettlementTransactionMinAggregateInputType
    _max?: SettlementTransactionMaxAggregateInputType
  }

  export type SettlementTransactionGroupByOutputType = {
    id: string
    gateway: string
    transactionId: string
    amount: Decimal
    currency: string
    status: $Enums.SettlementStatus
    fees: Decimal
    netPayout: Decimal
    settledAt: Date | null
    createdAt: Date
    updatedAt: Date
    bookingId: string | null
    _count: SettlementTransactionCountAggregateOutputType | null
    _avg: SettlementTransactionAvgAggregateOutputType | null
    _sum: SettlementTransactionSumAggregateOutputType | null
    _min: SettlementTransactionMinAggregateOutputType | null
    _max: SettlementTransactionMaxAggregateOutputType | null
  }

  type GetSettlementTransactionGroupByPayload<T extends SettlementTransactionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SettlementTransactionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SettlementTransactionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SettlementTransactionGroupByOutputType[P]>
            : GetScalarType<T[P], SettlementTransactionGroupByOutputType[P]>
        }
      >
    >


  export type SettlementTransactionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    gateway?: boolean
    transactionId?: boolean
    amount?: boolean
    currency?: boolean
    status?: boolean
    fees?: boolean
    netPayout?: boolean
    settledAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    bookingId?: boolean
    booking?: boolean | SettlementTransaction$bookingArgs<ExtArgs>
  }, ExtArgs["result"]["settlementTransaction"]>


  export type SettlementTransactionSelectScalar = {
    id?: boolean
    gateway?: boolean
    transactionId?: boolean
    amount?: boolean
    currency?: boolean
    status?: boolean
    fees?: boolean
    netPayout?: boolean
    settledAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    bookingId?: boolean
  }

  export type SettlementTransactionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    booking?: boolean | SettlementTransaction$bookingArgs<ExtArgs>
  }

  export type $SettlementTransactionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "SettlementTransaction"
    objects: {
      booking: Prisma.$BookingPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      gateway: string
      transactionId: string
      amount: Prisma.Decimal
      currency: string
      status: $Enums.SettlementStatus
      fees: Prisma.Decimal
      netPayout: Prisma.Decimal
      settledAt: Date | null
      createdAt: Date
      updatedAt: Date
      bookingId: string | null
    }, ExtArgs["result"]["settlementTransaction"]>
    composites: {}
  }

  type SettlementTransactionGetPayload<S extends boolean | null | undefined | SettlementTransactionDefaultArgs> = $Result.GetResult<Prisma.$SettlementTransactionPayload, S>

  type SettlementTransactionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<SettlementTransactionFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: SettlementTransactionCountAggregateInputType | true
    }

  export interface SettlementTransactionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['SettlementTransaction'], meta: { name: 'SettlementTransaction' } }
    /**
     * Find zero or one SettlementTransaction that matches the filter.
     * @param {SettlementTransactionFindUniqueArgs} args - Arguments to find a SettlementTransaction
     * @example
     * // Get one SettlementTransaction
     * const settlementTransaction = await prisma.settlementTransaction.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SettlementTransactionFindUniqueArgs>(args: SelectSubset<T, SettlementTransactionFindUniqueArgs<ExtArgs>>): Prisma__SettlementTransactionClient<$Result.GetResult<Prisma.$SettlementTransactionPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one SettlementTransaction that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {SettlementTransactionFindUniqueOrThrowArgs} args - Arguments to find a SettlementTransaction
     * @example
     * // Get one SettlementTransaction
     * const settlementTransaction = await prisma.settlementTransaction.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SettlementTransactionFindUniqueOrThrowArgs>(args: SelectSubset<T, SettlementTransactionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SettlementTransactionClient<$Result.GetResult<Prisma.$SettlementTransactionPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first SettlementTransaction that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SettlementTransactionFindFirstArgs} args - Arguments to find a SettlementTransaction
     * @example
     * // Get one SettlementTransaction
     * const settlementTransaction = await prisma.settlementTransaction.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SettlementTransactionFindFirstArgs>(args?: SelectSubset<T, SettlementTransactionFindFirstArgs<ExtArgs>>): Prisma__SettlementTransactionClient<$Result.GetResult<Prisma.$SettlementTransactionPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first SettlementTransaction that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SettlementTransactionFindFirstOrThrowArgs} args - Arguments to find a SettlementTransaction
     * @example
     * // Get one SettlementTransaction
     * const settlementTransaction = await prisma.settlementTransaction.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SettlementTransactionFindFirstOrThrowArgs>(args?: SelectSubset<T, SettlementTransactionFindFirstOrThrowArgs<ExtArgs>>): Prisma__SettlementTransactionClient<$Result.GetResult<Prisma.$SettlementTransactionPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more SettlementTransactions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SettlementTransactionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SettlementTransactions
     * const settlementTransactions = await prisma.settlementTransaction.findMany()
     * 
     * // Get first 10 SettlementTransactions
     * const settlementTransactions = await prisma.settlementTransaction.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const settlementTransactionWithIdOnly = await prisma.settlementTransaction.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SettlementTransactionFindManyArgs>(args?: SelectSubset<T, SettlementTransactionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SettlementTransactionPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a SettlementTransaction.
     * @param {SettlementTransactionCreateArgs} args - Arguments to create a SettlementTransaction.
     * @example
     * // Create one SettlementTransaction
     * const SettlementTransaction = await prisma.settlementTransaction.create({
     *   data: {
     *     // ... data to create a SettlementTransaction
     *   }
     * })
     * 
     */
    create<T extends SettlementTransactionCreateArgs>(args: SelectSubset<T, SettlementTransactionCreateArgs<ExtArgs>>): Prisma__SettlementTransactionClient<$Result.GetResult<Prisma.$SettlementTransactionPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many SettlementTransactions.
     * @param {SettlementTransactionCreateManyArgs} args - Arguments to create many SettlementTransactions.
     * @example
     * // Create many SettlementTransactions
     * const settlementTransaction = await prisma.settlementTransaction.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SettlementTransactionCreateManyArgs>(args?: SelectSubset<T, SettlementTransactionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a SettlementTransaction.
     * @param {SettlementTransactionDeleteArgs} args - Arguments to delete one SettlementTransaction.
     * @example
     * // Delete one SettlementTransaction
     * const SettlementTransaction = await prisma.settlementTransaction.delete({
     *   where: {
     *     // ... filter to delete one SettlementTransaction
     *   }
     * })
     * 
     */
    delete<T extends SettlementTransactionDeleteArgs>(args: SelectSubset<T, SettlementTransactionDeleteArgs<ExtArgs>>): Prisma__SettlementTransactionClient<$Result.GetResult<Prisma.$SettlementTransactionPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one SettlementTransaction.
     * @param {SettlementTransactionUpdateArgs} args - Arguments to update one SettlementTransaction.
     * @example
     * // Update one SettlementTransaction
     * const settlementTransaction = await prisma.settlementTransaction.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SettlementTransactionUpdateArgs>(args: SelectSubset<T, SettlementTransactionUpdateArgs<ExtArgs>>): Prisma__SettlementTransactionClient<$Result.GetResult<Prisma.$SettlementTransactionPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more SettlementTransactions.
     * @param {SettlementTransactionDeleteManyArgs} args - Arguments to filter SettlementTransactions to delete.
     * @example
     * // Delete a few SettlementTransactions
     * const { count } = await prisma.settlementTransaction.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SettlementTransactionDeleteManyArgs>(args?: SelectSubset<T, SettlementTransactionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SettlementTransactions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SettlementTransactionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SettlementTransactions
     * const settlementTransaction = await prisma.settlementTransaction.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SettlementTransactionUpdateManyArgs>(args: SelectSubset<T, SettlementTransactionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one SettlementTransaction.
     * @param {SettlementTransactionUpsertArgs} args - Arguments to update or create a SettlementTransaction.
     * @example
     * // Update or create a SettlementTransaction
     * const settlementTransaction = await prisma.settlementTransaction.upsert({
     *   create: {
     *     // ... data to create a SettlementTransaction
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SettlementTransaction we want to update
     *   }
     * })
     */
    upsert<T extends SettlementTransactionUpsertArgs>(args: SelectSubset<T, SettlementTransactionUpsertArgs<ExtArgs>>): Prisma__SettlementTransactionClient<$Result.GetResult<Prisma.$SettlementTransactionPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of SettlementTransactions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SettlementTransactionCountArgs} args - Arguments to filter SettlementTransactions to count.
     * @example
     * // Count the number of SettlementTransactions
     * const count = await prisma.settlementTransaction.count({
     *   where: {
     *     // ... the filter for the SettlementTransactions we want to count
     *   }
     * })
    **/
    count<T extends SettlementTransactionCountArgs>(
      args?: Subset<T, SettlementTransactionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SettlementTransactionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SettlementTransaction.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SettlementTransactionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SettlementTransactionAggregateArgs>(args: Subset<T, SettlementTransactionAggregateArgs>): Prisma.PrismaPromise<GetSettlementTransactionAggregateType<T>>

    /**
     * Group by SettlementTransaction.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SettlementTransactionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SettlementTransactionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SettlementTransactionGroupByArgs['orderBy'] }
        : { orderBy?: SettlementTransactionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SettlementTransactionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSettlementTransactionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the SettlementTransaction model
   */
  readonly fields: SettlementTransactionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for SettlementTransaction.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SettlementTransactionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    booking<T extends SettlementTransaction$bookingArgs<ExtArgs> = {}>(args?: Subset<T, SettlementTransaction$bookingArgs<ExtArgs>>): Prisma__BookingClient<$Result.GetResult<Prisma.$BookingPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the SettlementTransaction model
   */ 
  interface SettlementTransactionFieldRefs {
    readonly id: FieldRef<"SettlementTransaction", 'String'>
    readonly gateway: FieldRef<"SettlementTransaction", 'String'>
    readonly transactionId: FieldRef<"SettlementTransaction", 'String'>
    readonly amount: FieldRef<"SettlementTransaction", 'Decimal'>
    readonly currency: FieldRef<"SettlementTransaction", 'String'>
    readonly status: FieldRef<"SettlementTransaction", 'SettlementStatus'>
    readonly fees: FieldRef<"SettlementTransaction", 'Decimal'>
    readonly netPayout: FieldRef<"SettlementTransaction", 'Decimal'>
    readonly settledAt: FieldRef<"SettlementTransaction", 'DateTime'>
    readonly createdAt: FieldRef<"SettlementTransaction", 'DateTime'>
    readonly updatedAt: FieldRef<"SettlementTransaction", 'DateTime'>
    readonly bookingId: FieldRef<"SettlementTransaction", 'String'>
  }
    

  // Custom InputTypes
  /**
   * SettlementTransaction findUnique
   */
  export type SettlementTransactionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SettlementTransaction
     */
    select?: SettlementTransactionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SettlementTransactionInclude<ExtArgs> | null
    /**
     * Filter, which SettlementTransaction to fetch.
     */
    where: SettlementTransactionWhereUniqueInput
  }

  /**
   * SettlementTransaction findUniqueOrThrow
   */
  export type SettlementTransactionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SettlementTransaction
     */
    select?: SettlementTransactionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SettlementTransactionInclude<ExtArgs> | null
    /**
     * Filter, which SettlementTransaction to fetch.
     */
    where: SettlementTransactionWhereUniqueInput
  }

  /**
   * SettlementTransaction findFirst
   */
  export type SettlementTransactionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SettlementTransaction
     */
    select?: SettlementTransactionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SettlementTransactionInclude<ExtArgs> | null
    /**
     * Filter, which SettlementTransaction to fetch.
     */
    where?: SettlementTransactionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SettlementTransactions to fetch.
     */
    orderBy?: SettlementTransactionOrderByWithRelationInput | SettlementTransactionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SettlementTransactions.
     */
    cursor?: SettlementTransactionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SettlementTransactions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SettlementTransactions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SettlementTransactions.
     */
    distinct?: SettlementTransactionScalarFieldEnum | SettlementTransactionScalarFieldEnum[]
  }

  /**
   * SettlementTransaction findFirstOrThrow
   */
  export type SettlementTransactionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SettlementTransaction
     */
    select?: SettlementTransactionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SettlementTransactionInclude<ExtArgs> | null
    /**
     * Filter, which SettlementTransaction to fetch.
     */
    where?: SettlementTransactionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SettlementTransactions to fetch.
     */
    orderBy?: SettlementTransactionOrderByWithRelationInput | SettlementTransactionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SettlementTransactions.
     */
    cursor?: SettlementTransactionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SettlementTransactions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SettlementTransactions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SettlementTransactions.
     */
    distinct?: SettlementTransactionScalarFieldEnum | SettlementTransactionScalarFieldEnum[]
  }

  /**
   * SettlementTransaction findMany
   */
  export type SettlementTransactionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SettlementTransaction
     */
    select?: SettlementTransactionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SettlementTransactionInclude<ExtArgs> | null
    /**
     * Filter, which SettlementTransactions to fetch.
     */
    where?: SettlementTransactionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SettlementTransactions to fetch.
     */
    orderBy?: SettlementTransactionOrderByWithRelationInput | SettlementTransactionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing SettlementTransactions.
     */
    cursor?: SettlementTransactionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SettlementTransactions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SettlementTransactions.
     */
    skip?: number
    distinct?: SettlementTransactionScalarFieldEnum | SettlementTransactionScalarFieldEnum[]
  }

  /**
   * SettlementTransaction create
   */
  export type SettlementTransactionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SettlementTransaction
     */
    select?: SettlementTransactionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SettlementTransactionInclude<ExtArgs> | null
    /**
     * The data needed to create a SettlementTransaction.
     */
    data: XOR<SettlementTransactionCreateInput, SettlementTransactionUncheckedCreateInput>
  }

  /**
   * SettlementTransaction createMany
   */
  export type SettlementTransactionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many SettlementTransactions.
     */
    data: SettlementTransactionCreateManyInput | SettlementTransactionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * SettlementTransaction update
   */
  export type SettlementTransactionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SettlementTransaction
     */
    select?: SettlementTransactionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SettlementTransactionInclude<ExtArgs> | null
    /**
     * The data needed to update a SettlementTransaction.
     */
    data: XOR<SettlementTransactionUpdateInput, SettlementTransactionUncheckedUpdateInput>
    /**
     * Choose, which SettlementTransaction to update.
     */
    where: SettlementTransactionWhereUniqueInput
  }

  /**
   * SettlementTransaction updateMany
   */
  export type SettlementTransactionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update SettlementTransactions.
     */
    data: XOR<SettlementTransactionUpdateManyMutationInput, SettlementTransactionUncheckedUpdateManyInput>
    /**
     * Filter which SettlementTransactions to update
     */
    where?: SettlementTransactionWhereInput
  }

  /**
   * SettlementTransaction upsert
   */
  export type SettlementTransactionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SettlementTransaction
     */
    select?: SettlementTransactionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SettlementTransactionInclude<ExtArgs> | null
    /**
     * The filter to search for the SettlementTransaction to update in case it exists.
     */
    where: SettlementTransactionWhereUniqueInput
    /**
     * In case the SettlementTransaction found by the `where` argument doesn't exist, create a new SettlementTransaction with this data.
     */
    create: XOR<SettlementTransactionCreateInput, SettlementTransactionUncheckedCreateInput>
    /**
     * In case the SettlementTransaction was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SettlementTransactionUpdateInput, SettlementTransactionUncheckedUpdateInput>
  }

  /**
   * SettlementTransaction delete
   */
  export type SettlementTransactionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SettlementTransaction
     */
    select?: SettlementTransactionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SettlementTransactionInclude<ExtArgs> | null
    /**
     * Filter which SettlementTransaction to delete.
     */
    where: SettlementTransactionWhereUniqueInput
  }

  /**
   * SettlementTransaction deleteMany
   */
  export type SettlementTransactionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SettlementTransactions to delete
     */
    where?: SettlementTransactionWhereInput
  }

  /**
   * SettlementTransaction.booking
   */
  export type SettlementTransaction$bookingArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Booking
     */
    select?: BookingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingInclude<ExtArgs> | null
    where?: BookingWhereInput
  }

  /**
   * SettlementTransaction without action
   */
  export type SettlementTransactionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SettlementTransaction
     */
    select?: SettlementTransactionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SettlementTransactionInclude<ExtArgs> | null
  }


  /**
   * Model NotificationSegment
   */

  export type AggregateNotificationSegment = {
    _count: NotificationSegmentCountAggregateOutputType | null
    _min: NotificationSegmentMinAggregateOutputType | null
    _max: NotificationSegmentMaxAggregateOutputType | null
  }

  export type NotificationSegmentMinAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type NotificationSegmentMaxAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type NotificationSegmentCountAggregateOutputType = {
    id: number
    name: number
    description: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type NotificationSegmentMinAggregateInputType = {
    id?: true
    name?: true
    description?: true
    createdAt?: true
    updatedAt?: true
  }

  export type NotificationSegmentMaxAggregateInputType = {
    id?: true
    name?: true
    description?: true
    createdAt?: true
    updatedAt?: true
  }

  export type NotificationSegmentCountAggregateInputType = {
    id?: true
    name?: true
    description?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type NotificationSegmentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which NotificationSegment to aggregate.
     */
    where?: NotificationSegmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of NotificationSegments to fetch.
     */
    orderBy?: NotificationSegmentOrderByWithRelationInput | NotificationSegmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: NotificationSegmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` NotificationSegments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` NotificationSegments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned NotificationSegments
    **/
    _count?: true | NotificationSegmentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: NotificationSegmentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: NotificationSegmentMaxAggregateInputType
  }

  export type GetNotificationSegmentAggregateType<T extends NotificationSegmentAggregateArgs> = {
        [P in keyof T & keyof AggregateNotificationSegment]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateNotificationSegment[P]>
      : GetScalarType<T[P], AggregateNotificationSegment[P]>
  }




  export type NotificationSegmentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NotificationSegmentWhereInput
    orderBy?: NotificationSegmentOrderByWithAggregationInput | NotificationSegmentOrderByWithAggregationInput[]
    by: NotificationSegmentScalarFieldEnum[] | NotificationSegmentScalarFieldEnum
    having?: NotificationSegmentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: NotificationSegmentCountAggregateInputType | true
    _min?: NotificationSegmentMinAggregateInputType
    _max?: NotificationSegmentMaxAggregateInputType
  }

  export type NotificationSegmentGroupByOutputType = {
    id: string
    name: string
    description: string | null
    createdAt: Date
    updatedAt: Date
    _count: NotificationSegmentCountAggregateOutputType | null
    _min: NotificationSegmentMinAggregateOutputType | null
    _max: NotificationSegmentMaxAggregateOutputType | null
  }

  type GetNotificationSegmentGroupByPayload<T extends NotificationSegmentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<NotificationSegmentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof NotificationSegmentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], NotificationSegmentGroupByOutputType[P]>
            : GetScalarType<T[P], NotificationSegmentGroupByOutputType[P]>
        }
      >
    >


  export type NotificationSegmentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    campaigns?: boolean | NotificationSegment$campaignsArgs<ExtArgs>
    _count?: boolean | NotificationSegmentCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["notificationSegment"]>


  export type NotificationSegmentSelectScalar = {
    id?: boolean
    name?: boolean
    description?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type NotificationSegmentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    campaigns?: boolean | NotificationSegment$campaignsArgs<ExtArgs>
    _count?: boolean | NotificationSegmentCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $NotificationSegmentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "NotificationSegment"
    objects: {
      campaigns: Prisma.$NotificationCampaignPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      description: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["notificationSegment"]>
    composites: {}
  }

  type NotificationSegmentGetPayload<S extends boolean | null | undefined | NotificationSegmentDefaultArgs> = $Result.GetResult<Prisma.$NotificationSegmentPayload, S>

  type NotificationSegmentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<NotificationSegmentFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: NotificationSegmentCountAggregateInputType | true
    }

  export interface NotificationSegmentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['NotificationSegment'], meta: { name: 'NotificationSegment' } }
    /**
     * Find zero or one NotificationSegment that matches the filter.
     * @param {NotificationSegmentFindUniqueArgs} args - Arguments to find a NotificationSegment
     * @example
     * // Get one NotificationSegment
     * const notificationSegment = await prisma.notificationSegment.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends NotificationSegmentFindUniqueArgs>(args: SelectSubset<T, NotificationSegmentFindUniqueArgs<ExtArgs>>): Prisma__NotificationSegmentClient<$Result.GetResult<Prisma.$NotificationSegmentPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one NotificationSegment that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {NotificationSegmentFindUniqueOrThrowArgs} args - Arguments to find a NotificationSegment
     * @example
     * // Get one NotificationSegment
     * const notificationSegment = await prisma.notificationSegment.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends NotificationSegmentFindUniqueOrThrowArgs>(args: SelectSubset<T, NotificationSegmentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__NotificationSegmentClient<$Result.GetResult<Prisma.$NotificationSegmentPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first NotificationSegment that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationSegmentFindFirstArgs} args - Arguments to find a NotificationSegment
     * @example
     * // Get one NotificationSegment
     * const notificationSegment = await prisma.notificationSegment.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends NotificationSegmentFindFirstArgs>(args?: SelectSubset<T, NotificationSegmentFindFirstArgs<ExtArgs>>): Prisma__NotificationSegmentClient<$Result.GetResult<Prisma.$NotificationSegmentPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first NotificationSegment that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationSegmentFindFirstOrThrowArgs} args - Arguments to find a NotificationSegment
     * @example
     * // Get one NotificationSegment
     * const notificationSegment = await prisma.notificationSegment.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends NotificationSegmentFindFirstOrThrowArgs>(args?: SelectSubset<T, NotificationSegmentFindFirstOrThrowArgs<ExtArgs>>): Prisma__NotificationSegmentClient<$Result.GetResult<Prisma.$NotificationSegmentPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more NotificationSegments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationSegmentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all NotificationSegments
     * const notificationSegments = await prisma.notificationSegment.findMany()
     * 
     * // Get first 10 NotificationSegments
     * const notificationSegments = await prisma.notificationSegment.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const notificationSegmentWithIdOnly = await prisma.notificationSegment.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends NotificationSegmentFindManyArgs>(args?: SelectSubset<T, NotificationSegmentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationSegmentPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a NotificationSegment.
     * @param {NotificationSegmentCreateArgs} args - Arguments to create a NotificationSegment.
     * @example
     * // Create one NotificationSegment
     * const NotificationSegment = await prisma.notificationSegment.create({
     *   data: {
     *     // ... data to create a NotificationSegment
     *   }
     * })
     * 
     */
    create<T extends NotificationSegmentCreateArgs>(args: SelectSubset<T, NotificationSegmentCreateArgs<ExtArgs>>): Prisma__NotificationSegmentClient<$Result.GetResult<Prisma.$NotificationSegmentPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many NotificationSegments.
     * @param {NotificationSegmentCreateManyArgs} args - Arguments to create many NotificationSegments.
     * @example
     * // Create many NotificationSegments
     * const notificationSegment = await prisma.notificationSegment.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends NotificationSegmentCreateManyArgs>(args?: SelectSubset<T, NotificationSegmentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a NotificationSegment.
     * @param {NotificationSegmentDeleteArgs} args - Arguments to delete one NotificationSegment.
     * @example
     * // Delete one NotificationSegment
     * const NotificationSegment = await prisma.notificationSegment.delete({
     *   where: {
     *     // ... filter to delete one NotificationSegment
     *   }
     * })
     * 
     */
    delete<T extends NotificationSegmentDeleteArgs>(args: SelectSubset<T, NotificationSegmentDeleteArgs<ExtArgs>>): Prisma__NotificationSegmentClient<$Result.GetResult<Prisma.$NotificationSegmentPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one NotificationSegment.
     * @param {NotificationSegmentUpdateArgs} args - Arguments to update one NotificationSegment.
     * @example
     * // Update one NotificationSegment
     * const notificationSegment = await prisma.notificationSegment.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends NotificationSegmentUpdateArgs>(args: SelectSubset<T, NotificationSegmentUpdateArgs<ExtArgs>>): Prisma__NotificationSegmentClient<$Result.GetResult<Prisma.$NotificationSegmentPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more NotificationSegments.
     * @param {NotificationSegmentDeleteManyArgs} args - Arguments to filter NotificationSegments to delete.
     * @example
     * // Delete a few NotificationSegments
     * const { count } = await prisma.notificationSegment.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends NotificationSegmentDeleteManyArgs>(args?: SelectSubset<T, NotificationSegmentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more NotificationSegments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationSegmentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many NotificationSegments
     * const notificationSegment = await prisma.notificationSegment.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends NotificationSegmentUpdateManyArgs>(args: SelectSubset<T, NotificationSegmentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one NotificationSegment.
     * @param {NotificationSegmentUpsertArgs} args - Arguments to update or create a NotificationSegment.
     * @example
     * // Update or create a NotificationSegment
     * const notificationSegment = await prisma.notificationSegment.upsert({
     *   create: {
     *     // ... data to create a NotificationSegment
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the NotificationSegment we want to update
     *   }
     * })
     */
    upsert<T extends NotificationSegmentUpsertArgs>(args: SelectSubset<T, NotificationSegmentUpsertArgs<ExtArgs>>): Prisma__NotificationSegmentClient<$Result.GetResult<Prisma.$NotificationSegmentPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of NotificationSegments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationSegmentCountArgs} args - Arguments to filter NotificationSegments to count.
     * @example
     * // Count the number of NotificationSegments
     * const count = await prisma.notificationSegment.count({
     *   where: {
     *     // ... the filter for the NotificationSegments we want to count
     *   }
     * })
    **/
    count<T extends NotificationSegmentCountArgs>(
      args?: Subset<T, NotificationSegmentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], NotificationSegmentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a NotificationSegment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationSegmentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends NotificationSegmentAggregateArgs>(args: Subset<T, NotificationSegmentAggregateArgs>): Prisma.PrismaPromise<GetNotificationSegmentAggregateType<T>>

    /**
     * Group by NotificationSegment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationSegmentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends NotificationSegmentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: NotificationSegmentGroupByArgs['orderBy'] }
        : { orderBy?: NotificationSegmentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, NotificationSegmentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetNotificationSegmentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the NotificationSegment model
   */
  readonly fields: NotificationSegmentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for NotificationSegment.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__NotificationSegmentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    campaigns<T extends NotificationSegment$campaignsArgs<ExtArgs> = {}>(args?: Subset<T, NotificationSegment$campaignsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationCampaignPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the NotificationSegment model
   */ 
  interface NotificationSegmentFieldRefs {
    readonly id: FieldRef<"NotificationSegment", 'String'>
    readonly name: FieldRef<"NotificationSegment", 'String'>
    readonly description: FieldRef<"NotificationSegment", 'String'>
    readonly createdAt: FieldRef<"NotificationSegment", 'DateTime'>
    readonly updatedAt: FieldRef<"NotificationSegment", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * NotificationSegment findUnique
   */
  export type NotificationSegmentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationSegment
     */
    select?: NotificationSegmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationSegmentInclude<ExtArgs> | null
    /**
     * Filter, which NotificationSegment to fetch.
     */
    where: NotificationSegmentWhereUniqueInput
  }

  /**
   * NotificationSegment findUniqueOrThrow
   */
  export type NotificationSegmentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationSegment
     */
    select?: NotificationSegmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationSegmentInclude<ExtArgs> | null
    /**
     * Filter, which NotificationSegment to fetch.
     */
    where: NotificationSegmentWhereUniqueInput
  }

  /**
   * NotificationSegment findFirst
   */
  export type NotificationSegmentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationSegment
     */
    select?: NotificationSegmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationSegmentInclude<ExtArgs> | null
    /**
     * Filter, which NotificationSegment to fetch.
     */
    where?: NotificationSegmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of NotificationSegments to fetch.
     */
    orderBy?: NotificationSegmentOrderByWithRelationInput | NotificationSegmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for NotificationSegments.
     */
    cursor?: NotificationSegmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` NotificationSegments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` NotificationSegments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of NotificationSegments.
     */
    distinct?: NotificationSegmentScalarFieldEnum | NotificationSegmentScalarFieldEnum[]
  }

  /**
   * NotificationSegment findFirstOrThrow
   */
  export type NotificationSegmentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationSegment
     */
    select?: NotificationSegmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationSegmentInclude<ExtArgs> | null
    /**
     * Filter, which NotificationSegment to fetch.
     */
    where?: NotificationSegmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of NotificationSegments to fetch.
     */
    orderBy?: NotificationSegmentOrderByWithRelationInput | NotificationSegmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for NotificationSegments.
     */
    cursor?: NotificationSegmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` NotificationSegments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` NotificationSegments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of NotificationSegments.
     */
    distinct?: NotificationSegmentScalarFieldEnum | NotificationSegmentScalarFieldEnum[]
  }

  /**
   * NotificationSegment findMany
   */
  export type NotificationSegmentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationSegment
     */
    select?: NotificationSegmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationSegmentInclude<ExtArgs> | null
    /**
     * Filter, which NotificationSegments to fetch.
     */
    where?: NotificationSegmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of NotificationSegments to fetch.
     */
    orderBy?: NotificationSegmentOrderByWithRelationInput | NotificationSegmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing NotificationSegments.
     */
    cursor?: NotificationSegmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` NotificationSegments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` NotificationSegments.
     */
    skip?: number
    distinct?: NotificationSegmentScalarFieldEnum | NotificationSegmentScalarFieldEnum[]
  }

  /**
   * NotificationSegment create
   */
  export type NotificationSegmentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationSegment
     */
    select?: NotificationSegmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationSegmentInclude<ExtArgs> | null
    /**
     * The data needed to create a NotificationSegment.
     */
    data: XOR<NotificationSegmentCreateInput, NotificationSegmentUncheckedCreateInput>
  }

  /**
   * NotificationSegment createMany
   */
  export type NotificationSegmentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many NotificationSegments.
     */
    data: NotificationSegmentCreateManyInput | NotificationSegmentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * NotificationSegment update
   */
  export type NotificationSegmentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationSegment
     */
    select?: NotificationSegmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationSegmentInclude<ExtArgs> | null
    /**
     * The data needed to update a NotificationSegment.
     */
    data: XOR<NotificationSegmentUpdateInput, NotificationSegmentUncheckedUpdateInput>
    /**
     * Choose, which NotificationSegment to update.
     */
    where: NotificationSegmentWhereUniqueInput
  }

  /**
   * NotificationSegment updateMany
   */
  export type NotificationSegmentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update NotificationSegments.
     */
    data: XOR<NotificationSegmentUpdateManyMutationInput, NotificationSegmentUncheckedUpdateManyInput>
    /**
     * Filter which NotificationSegments to update
     */
    where?: NotificationSegmentWhereInput
  }

  /**
   * NotificationSegment upsert
   */
  export type NotificationSegmentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationSegment
     */
    select?: NotificationSegmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationSegmentInclude<ExtArgs> | null
    /**
     * The filter to search for the NotificationSegment to update in case it exists.
     */
    where: NotificationSegmentWhereUniqueInput
    /**
     * In case the NotificationSegment found by the `where` argument doesn't exist, create a new NotificationSegment with this data.
     */
    create: XOR<NotificationSegmentCreateInput, NotificationSegmentUncheckedCreateInput>
    /**
     * In case the NotificationSegment was found with the provided `where` argument, update it with this data.
     */
    update: XOR<NotificationSegmentUpdateInput, NotificationSegmentUncheckedUpdateInput>
  }

  /**
   * NotificationSegment delete
   */
  export type NotificationSegmentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationSegment
     */
    select?: NotificationSegmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationSegmentInclude<ExtArgs> | null
    /**
     * Filter which NotificationSegment to delete.
     */
    where: NotificationSegmentWhereUniqueInput
  }

  /**
   * NotificationSegment deleteMany
   */
  export type NotificationSegmentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which NotificationSegments to delete
     */
    where?: NotificationSegmentWhereInput
  }

  /**
   * NotificationSegment.campaigns
   */
  export type NotificationSegment$campaignsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationCampaign
     */
    select?: NotificationCampaignSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationCampaignInclude<ExtArgs> | null
    where?: NotificationCampaignWhereInput
    orderBy?: NotificationCampaignOrderByWithRelationInput | NotificationCampaignOrderByWithRelationInput[]
    cursor?: NotificationCampaignWhereUniqueInput
    take?: number
    skip?: number
    distinct?: NotificationCampaignScalarFieldEnum | NotificationCampaignScalarFieldEnum[]
  }

  /**
   * NotificationSegment without action
   */
  export type NotificationSegmentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationSegment
     */
    select?: NotificationSegmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationSegmentInclude<ExtArgs> | null
  }


  /**
   * Model NotificationCampaign
   */

  export type AggregateNotificationCampaign = {
    _count: NotificationCampaignCountAggregateOutputType | null
    _avg: NotificationCampaignAvgAggregateOutputType | null
    _sum: NotificationCampaignSumAggregateOutputType | null
    _min: NotificationCampaignMinAggregateOutputType | null
    _max: NotificationCampaignMaxAggregateOutputType | null
  }

  export type NotificationCampaignAvgAggregateOutputType = {
    statsSent: number | null
    statsOpened: number | null
    statsClicked: number | null
  }

  export type NotificationCampaignSumAggregateOutputType = {
    statsSent: number | null
    statsOpened: number | null
    statsClicked: number | null
  }

  export type NotificationCampaignMinAggregateOutputType = {
    id: string | null
    name: string | null
    subject: string | null
    status: $Enums.CampaignStatus | null
    scheduledAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
    segmentId: string | null
    statsSent: number | null
    statsOpened: number | null
    statsClicked: number | null
  }

  export type NotificationCampaignMaxAggregateOutputType = {
    id: string | null
    name: string | null
    subject: string | null
    status: $Enums.CampaignStatus | null
    scheduledAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
    segmentId: string | null
    statsSent: number | null
    statsOpened: number | null
    statsClicked: number | null
  }

  export type NotificationCampaignCountAggregateOutputType = {
    id: number
    name: number
    subject: number
    channels: number
    status: number
    scheduledAt: number
    createdAt: number
    updatedAt: number
    segmentId: number
    statsSent: number
    statsOpened: number
    statsClicked: number
    _all: number
  }


  export type NotificationCampaignAvgAggregateInputType = {
    statsSent?: true
    statsOpened?: true
    statsClicked?: true
  }

  export type NotificationCampaignSumAggregateInputType = {
    statsSent?: true
    statsOpened?: true
    statsClicked?: true
  }

  export type NotificationCampaignMinAggregateInputType = {
    id?: true
    name?: true
    subject?: true
    status?: true
    scheduledAt?: true
    createdAt?: true
    updatedAt?: true
    segmentId?: true
    statsSent?: true
    statsOpened?: true
    statsClicked?: true
  }

  export type NotificationCampaignMaxAggregateInputType = {
    id?: true
    name?: true
    subject?: true
    status?: true
    scheduledAt?: true
    createdAt?: true
    updatedAt?: true
    segmentId?: true
    statsSent?: true
    statsOpened?: true
    statsClicked?: true
  }

  export type NotificationCampaignCountAggregateInputType = {
    id?: true
    name?: true
    subject?: true
    channels?: true
    status?: true
    scheduledAt?: true
    createdAt?: true
    updatedAt?: true
    segmentId?: true
    statsSent?: true
    statsOpened?: true
    statsClicked?: true
    _all?: true
  }

  export type NotificationCampaignAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which NotificationCampaign to aggregate.
     */
    where?: NotificationCampaignWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of NotificationCampaigns to fetch.
     */
    orderBy?: NotificationCampaignOrderByWithRelationInput | NotificationCampaignOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: NotificationCampaignWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` NotificationCampaigns from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` NotificationCampaigns.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned NotificationCampaigns
    **/
    _count?: true | NotificationCampaignCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: NotificationCampaignAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: NotificationCampaignSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: NotificationCampaignMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: NotificationCampaignMaxAggregateInputType
  }

  export type GetNotificationCampaignAggregateType<T extends NotificationCampaignAggregateArgs> = {
        [P in keyof T & keyof AggregateNotificationCampaign]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateNotificationCampaign[P]>
      : GetScalarType<T[P], AggregateNotificationCampaign[P]>
  }




  export type NotificationCampaignGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NotificationCampaignWhereInput
    orderBy?: NotificationCampaignOrderByWithAggregationInput | NotificationCampaignOrderByWithAggregationInput[]
    by: NotificationCampaignScalarFieldEnum[] | NotificationCampaignScalarFieldEnum
    having?: NotificationCampaignScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: NotificationCampaignCountAggregateInputType | true
    _avg?: NotificationCampaignAvgAggregateInputType
    _sum?: NotificationCampaignSumAggregateInputType
    _min?: NotificationCampaignMinAggregateInputType
    _max?: NotificationCampaignMaxAggregateInputType
  }

  export type NotificationCampaignGroupByOutputType = {
    id: string
    name: string
    subject: string
    channels: JsonValue
    status: $Enums.CampaignStatus
    scheduledAt: Date | null
    createdAt: Date
    updatedAt: Date
    segmentId: string
    statsSent: number
    statsOpened: number
    statsClicked: number
    _count: NotificationCampaignCountAggregateOutputType | null
    _avg: NotificationCampaignAvgAggregateOutputType | null
    _sum: NotificationCampaignSumAggregateOutputType | null
    _min: NotificationCampaignMinAggregateOutputType | null
    _max: NotificationCampaignMaxAggregateOutputType | null
  }

  type GetNotificationCampaignGroupByPayload<T extends NotificationCampaignGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<NotificationCampaignGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof NotificationCampaignGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], NotificationCampaignGroupByOutputType[P]>
            : GetScalarType<T[P], NotificationCampaignGroupByOutputType[P]>
        }
      >
    >


  export type NotificationCampaignSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    subject?: boolean
    channels?: boolean
    status?: boolean
    scheduledAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    segmentId?: boolean
    statsSent?: boolean
    statsOpened?: boolean
    statsClicked?: boolean
    segment?: boolean | NotificationSegmentDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["notificationCampaign"]>


  export type NotificationCampaignSelectScalar = {
    id?: boolean
    name?: boolean
    subject?: boolean
    channels?: boolean
    status?: boolean
    scheduledAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    segmentId?: boolean
    statsSent?: boolean
    statsOpened?: boolean
    statsClicked?: boolean
  }

  export type NotificationCampaignInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    segment?: boolean | NotificationSegmentDefaultArgs<ExtArgs>
  }

  export type $NotificationCampaignPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "NotificationCampaign"
    objects: {
      segment: Prisma.$NotificationSegmentPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      subject: string
      channels: Prisma.JsonValue
      status: $Enums.CampaignStatus
      scheduledAt: Date | null
      createdAt: Date
      updatedAt: Date
      segmentId: string
      statsSent: number
      statsOpened: number
      statsClicked: number
    }, ExtArgs["result"]["notificationCampaign"]>
    composites: {}
  }

  type NotificationCampaignGetPayload<S extends boolean | null | undefined | NotificationCampaignDefaultArgs> = $Result.GetResult<Prisma.$NotificationCampaignPayload, S>

  type NotificationCampaignCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<NotificationCampaignFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: NotificationCampaignCountAggregateInputType | true
    }

  export interface NotificationCampaignDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['NotificationCampaign'], meta: { name: 'NotificationCampaign' } }
    /**
     * Find zero or one NotificationCampaign that matches the filter.
     * @param {NotificationCampaignFindUniqueArgs} args - Arguments to find a NotificationCampaign
     * @example
     * // Get one NotificationCampaign
     * const notificationCampaign = await prisma.notificationCampaign.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends NotificationCampaignFindUniqueArgs>(args: SelectSubset<T, NotificationCampaignFindUniqueArgs<ExtArgs>>): Prisma__NotificationCampaignClient<$Result.GetResult<Prisma.$NotificationCampaignPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one NotificationCampaign that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {NotificationCampaignFindUniqueOrThrowArgs} args - Arguments to find a NotificationCampaign
     * @example
     * // Get one NotificationCampaign
     * const notificationCampaign = await prisma.notificationCampaign.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends NotificationCampaignFindUniqueOrThrowArgs>(args: SelectSubset<T, NotificationCampaignFindUniqueOrThrowArgs<ExtArgs>>): Prisma__NotificationCampaignClient<$Result.GetResult<Prisma.$NotificationCampaignPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first NotificationCampaign that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationCampaignFindFirstArgs} args - Arguments to find a NotificationCampaign
     * @example
     * // Get one NotificationCampaign
     * const notificationCampaign = await prisma.notificationCampaign.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends NotificationCampaignFindFirstArgs>(args?: SelectSubset<T, NotificationCampaignFindFirstArgs<ExtArgs>>): Prisma__NotificationCampaignClient<$Result.GetResult<Prisma.$NotificationCampaignPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first NotificationCampaign that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationCampaignFindFirstOrThrowArgs} args - Arguments to find a NotificationCampaign
     * @example
     * // Get one NotificationCampaign
     * const notificationCampaign = await prisma.notificationCampaign.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends NotificationCampaignFindFirstOrThrowArgs>(args?: SelectSubset<T, NotificationCampaignFindFirstOrThrowArgs<ExtArgs>>): Prisma__NotificationCampaignClient<$Result.GetResult<Prisma.$NotificationCampaignPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more NotificationCampaigns that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationCampaignFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all NotificationCampaigns
     * const notificationCampaigns = await prisma.notificationCampaign.findMany()
     * 
     * // Get first 10 NotificationCampaigns
     * const notificationCampaigns = await prisma.notificationCampaign.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const notificationCampaignWithIdOnly = await prisma.notificationCampaign.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends NotificationCampaignFindManyArgs>(args?: SelectSubset<T, NotificationCampaignFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationCampaignPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a NotificationCampaign.
     * @param {NotificationCampaignCreateArgs} args - Arguments to create a NotificationCampaign.
     * @example
     * // Create one NotificationCampaign
     * const NotificationCampaign = await prisma.notificationCampaign.create({
     *   data: {
     *     // ... data to create a NotificationCampaign
     *   }
     * })
     * 
     */
    create<T extends NotificationCampaignCreateArgs>(args: SelectSubset<T, NotificationCampaignCreateArgs<ExtArgs>>): Prisma__NotificationCampaignClient<$Result.GetResult<Prisma.$NotificationCampaignPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many NotificationCampaigns.
     * @param {NotificationCampaignCreateManyArgs} args - Arguments to create many NotificationCampaigns.
     * @example
     * // Create many NotificationCampaigns
     * const notificationCampaign = await prisma.notificationCampaign.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends NotificationCampaignCreateManyArgs>(args?: SelectSubset<T, NotificationCampaignCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a NotificationCampaign.
     * @param {NotificationCampaignDeleteArgs} args - Arguments to delete one NotificationCampaign.
     * @example
     * // Delete one NotificationCampaign
     * const NotificationCampaign = await prisma.notificationCampaign.delete({
     *   where: {
     *     // ... filter to delete one NotificationCampaign
     *   }
     * })
     * 
     */
    delete<T extends NotificationCampaignDeleteArgs>(args: SelectSubset<T, NotificationCampaignDeleteArgs<ExtArgs>>): Prisma__NotificationCampaignClient<$Result.GetResult<Prisma.$NotificationCampaignPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one NotificationCampaign.
     * @param {NotificationCampaignUpdateArgs} args - Arguments to update one NotificationCampaign.
     * @example
     * // Update one NotificationCampaign
     * const notificationCampaign = await prisma.notificationCampaign.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends NotificationCampaignUpdateArgs>(args: SelectSubset<T, NotificationCampaignUpdateArgs<ExtArgs>>): Prisma__NotificationCampaignClient<$Result.GetResult<Prisma.$NotificationCampaignPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more NotificationCampaigns.
     * @param {NotificationCampaignDeleteManyArgs} args - Arguments to filter NotificationCampaigns to delete.
     * @example
     * // Delete a few NotificationCampaigns
     * const { count } = await prisma.notificationCampaign.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends NotificationCampaignDeleteManyArgs>(args?: SelectSubset<T, NotificationCampaignDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more NotificationCampaigns.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationCampaignUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many NotificationCampaigns
     * const notificationCampaign = await prisma.notificationCampaign.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends NotificationCampaignUpdateManyArgs>(args: SelectSubset<T, NotificationCampaignUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one NotificationCampaign.
     * @param {NotificationCampaignUpsertArgs} args - Arguments to update or create a NotificationCampaign.
     * @example
     * // Update or create a NotificationCampaign
     * const notificationCampaign = await prisma.notificationCampaign.upsert({
     *   create: {
     *     // ... data to create a NotificationCampaign
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the NotificationCampaign we want to update
     *   }
     * })
     */
    upsert<T extends NotificationCampaignUpsertArgs>(args: SelectSubset<T, NotificationCampaignUpsertArgs<ExtArgs>>): Prisma__NotificationCampaignClient<$Result.GetResult<Prisma.$NotificationCampaignPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of NotificationCampaigns.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationCampaignCountArgs} args - Arguments to filter NotificationCampaigns to count.
     * @example
     * // Count the number of NotificationCampaigns
     * const count = await prisma.notificationCampaign.count({
     *   where: {
     *     // ... the filter for the NotificationCampaigns we want to count
     *   }
     * })
    **/
    count<T extends NotificationCampaignCountArgs>(
      args?: Subset<T, NotificationCampaignCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], NotificationCampaignCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a NotificationCampaign.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationCampaignAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends NotificationCampaignAggregateArgs>(args: Subset<T, NotificationCampaignAggregateArgs>): Prisma.PrismaPromise<GetNotificationCampaignAggregateType<T>>

    /**
     * Group by NotificationCampaign.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationCampaignGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends NotificationCampaignGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: NotificationCampaignGroupByArgs['orderBy'] }
        : { orderBy?: NotificationCampaignGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, NotificationCampaignGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetNotificationCampaignGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the NotificationCampaign model
   */
  readonly fields: NotificationCampaignFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for NotificationCampaign.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__NotificationCampaignClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    segment<T extends NotificationSegmentDefaultArgs<ExtArgs> = {}>(args?: Subset<T, NotificationSegmentDefaultArgs<ExtArgs>>): Prisma__NotificationSegmentClient<$Result.GetResult<Prisma.$NotificationSegmentPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the NotificationCampaign model
   */ 
  interface NotificationCampaignFieldRefs {
    readonly id: FieldRef<"NotificationCampaign", 'String'>
    readonly name: FieldRef<"NotificationCampaign", 'String'>
    readonly subject: FieldRef<"NotificationCampaign", 'String'>
    readonly channels: FieldRef<"NotificationCampaign", 'Json'>
    readonly status: FieldRef<"NotificationCampaign", 'CampaignStatus'>
    readonly scheduledAt: FieldRef<"NotificationCampaign", 'DateTime'>
    readonly createdAt: FieldRef<"NotificationCampaign", 'DateTime'>
    readonly updatedAt: FieldRef<"NotificationCampaign", 'DateTime'>
    readonly segmentId: FieldRef<"NotificationCampaign", 'String'>
    readonly statsSent: FieldRef<"NotificationCampaign", 'Int'>
    readonly statsOpened: FieldRef<"NotificationCampaign", 'Int'>
    readonly statsClicked: FieldRef<"NotificationCampaign", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * NotificationCampaign findUnique
   */
  export type NotificationCampaignFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationCampaign
     */
    select?: NotificationCampaignSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationCampaignInclude<ExtArgs> | null
    /**
     * Filter, which NotificationCampaign to fetch.
     */
    where: NotificationCampaignWhereUniqueInput
  }

  /**
   * NotificationCampaign findUniqueOrThrow
   */
  export type NotificationCampaignFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationCampaign
     */
    select?: NotificationCampaignSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationCampaignInclude<ExtArgs> | null
    /**
     * Filter, which NotificationCampaign to fetch.
     */
    where: NotificationCampaignWhereUniqueInput
  }

  /**
   * NotificationCampaign findFirst
   */
  export type NotificationCampaignFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationCampaign
     */
    select?: NotificationCampaignSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationCampaignInclude<ExtArgs> | null
    /**
     * Filter, which NotificationCampaign to fetch.
     */
    where?: NotificationCampaignWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of NotificationCampaigns to fetch.
     */
    orderBy?: NotificationCampaignOrderByWithRelationInput | NotificationCampaignOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for NotificationCampaigns.
     */
    cursor?: NotificationCampaignWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` NotificationCampaigns from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` NotificationCampaigns.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of NotificationCampaigns.
     */
    distinct?: NotificationCampaignScalarFieldEnum | NotificationCampaignScalarFieldEnum[]
  }

  /**
   * NotificationCampaign findFirstOrThrow
   */
  export type NotificationCampaignFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationCampaign
     */
    select?: NotificationCampaignSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationCampaignInclude<ExtArgs> | null
    /**
     * Filter, which NotificationCampaign to fetch.
     */
    where?: NotificationCampaignWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of NotificationCampaigns to fetch.
     */
    orderBy?: NotificationCampaignOrderByWithRelationInput | NotificationCampaignOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for NotificationCampaigns.
     */
    cursor?: NotificationCampaignWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` NotificationCampaigns from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` NotificationCampaigns.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of NotificationCampaigns.
     */
    distinct?: NotificationCampaignScalarFieldEnum | NotificationCampaignScalarFieldEnum[]
  }

  /**
   * NotificationCampaign findMany
   */
  export type NotificationCampaignFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationCampaign
     */
    select?: NotificationCampaignSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationCampaignInclude<ExtArgs> | null
    /**
     * Filter, which NotificationCampaigns to fetch.
     */
    where?: NotificationCampaignWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of NotificationCampaigns to fetch.
     */
    orderBy?: NotificationCampaignOrderByWithRelationInput | NotificationCampaignOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing NotificationCampaigns.
     */
    cursor?: NotificationCampaignWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` NotificationCampaigns from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` NotificationCampaigns.
     */
    skip?: number
    distinct?: NotificationCampaignScalarFieldEnum | NotificationCampaignScalarFieldEnum[]
  }

  /**
   * NotificationCampaign create
   */
  export type NotificationCampaignCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationCampaign
     */
    select?: NotificationCampaignSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationCampaignInclude<ExtArgs> | null
    /**
     * The data needed to create a NotificationCampaign.
     */
    data: XOR<NotificationCampaignCreateInput, NotificationCampaignUncheckedCreateInput>
  }

  /**
   * NotificationCampaign createMany
   */
  export type NotificationCampaignCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many NotificationCampaigns.
     */
    data: NotificationCampaignCreateManyInput | NotificationCampaignCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * NotificationCampaign update
   */
  export type NotificationCampaignUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationCampaign
     */
    select?: NotificationCampaignSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationCampaignInclude<ExtArgs> | null
    /**
     * The data needed to update a NotificationCampaign.
     */
    data: XOR<NotificationCampaignUpdateInput, NotificationCampaignUncheckedUpdateInput>
    /**
     * Choose, which NotificationCampaign to update.
     */
    where: NotificationCampaignWhereUniqueInput
  }

  /**
   * NotificationCampaign updateMany
   */
  export type NotificationCampaignUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update NotificationCampaigns.
     */
    data: XOR<NotificationCampaignUpdateManyMutationInput, NotificationCampaignUncheckedUpdateManyInput>
    /**
     * Filter which NotificationCampaigns to update
     */
    where?: NotificationCampaignWhereInput
  }

  /**
   * NotificationCampaign upsert
   */
  export type NotificationCampaignUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationCampaign
     */
    select?: NotificationCampaignSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationCampaignInclude<ExtArgs> | null
    /**
     * The filter to search for the NotificationCampaign to update in case it exists.
     */
    where: NotificationCampaignWhereUniqueInput
    /**
     * In case the NotificationCampaign found by the `where` argument doesn't exist, create a new NotificationCampaign with this data.
     */
    create: XOR<NotificationCampaignCreateInput, NotificationCampaignUncheckedCreateInput>
    /**
     * In case the NotificationCampaign was found with the provided `where` argument, update it with this data.
     */
    update: XOR<NotificationCampaignUpdateInput, NotificationCampaignUncheckedUpdateInput>
  }

  /**
   * NotificationCampaign delete
   */
  export type NotificationCampaignDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationCampaign
     */
    select?: NotificationCampaignSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationCampaignInclude<ExtArgs> | null
    /**
     * Filter which NotificationCampaign to delete.
     */
    where: NotificationCampaignWhereUniqueInput
  }

  /**
   * NotificationCampaign deleteMany
   */
  export type NotificationCampaignDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which NotificationCampaigns to delete
     */
    where?: NotificationCampaignWhereInput
  }

  /**
   * NotificationCampaign without action
   */
  export type NotificationCampaignDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationCampaign
     */
    select?: NotificationCampaignSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationCampaignInclude<ExtArgs> | null
  }


  /**
   * Model PlatformSettings
   */

  export type AggregatePlatformSettings = {
    _count: PlatformSettingsCountAggregateOutputType | null
    _avg: PlatformSettingsAvgAggregateOutputType | null
    _sum: PlatformSettingsSumAggregateOutputType | null
    _min: PlatformSettingsMinAggregateOutputType | null
    _max: PlatformSettingsMaxAggregateOutputType | null
  }

  export type PlatformSettingsAvgAggregateOutputType = {
    id: number | null
    settlementDays: number | null
    cgst: Decimal | null
    sgst: Decimal | null
    convenienceFee: Decimal | null
    refundWindowHours: number | null
  }

  export type PlatformSettingsSumAggregateOutputType = {
    id: number | null
    settlementDays: number | null
    cgst: Decimal | null
    sgst: Decimal | null
    convenienceFee: Decimal | null
    refundWindowHours: number | null
  }

  export type PlatformSettingsMinAggregateOutputType = {
    id: number | null
    razorpayKey: string | null
    stripeKey: string | null
    settlementDays: number | null
    cgst: Decimal | null
    sgst: Decimal | null
    convenienceFee: Decimal | null
    theatreName: string | null
    supportEmail: string | null
    contactNumber: string | null
    address: string | null
    termsUrl: string | null
    privacyUrl: string | null
    refundWindowHours: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PlatformSettingsMaxAggregateOutputType = {
    id: number | null
    razorpayKey: string | null
    stripeKey: string | null
    settlementDays: number | null
    cgst: Decimal | null
    sgst: Decimal | null
    convenienceFee: Decimal | null
    theatreName: string | null
    supportEmail: string | null
    contactNumber: string | null
    address: string | null
    termsUrl: string | null
    privacyUrl: string | null
    refundWindowHours: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PlatformSettingsCountAggregateOutputType = {
    id: number
    razorpayKey: number
    stripeKey: number
    settlementDays: number
    cgst: number
    sgst: number
    convenienceFee: number
    theatreName: number
    supportEmail: number
    contactNumber: number
    address: number
    termsUrl: number
    privacyUrl: number
    refundWindowHours: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type PlatformSettingsAvgAggregateInputType = {
    id?: true
    settlementDays?: true
    cgst?: true
    sgst?: true
    convenienceFee?: true
    refundWindowHours?: true
  }

  export type PlatformSettingsSumAggregateInputType = {
    id?: true
    settlementDays?: true
    cgst?: true
    sgst?: true
    convenienceFee?: true
    refundWindowHours?: true
  }

  export type PlatformSettingsMinAggregateInputType = {
    id?: true
    razorpayKey?: true
    stripeKey?: true
    settlementDays?: true
    cgst?: true
    sgst?: true
    convenienceFee?: true
    theatreName?: true
    supportEmail?: true
    contactNumber?: true
    address?: true
    termsUrl?: true
    privacyUrl?: true
    refundWindowHours?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PlatformSettingsMaxAggregateInputType = {
    id?: true
    razorpayKey?: true
    stripeKey?: true
    settlementDays?: true
    cgst?: true
    sgst?: true
    convenienceFee?: true
    theatreName?: true
    supportEmail?: true
    contactNumber?: true
    address?: true
    termsUrl?: true
    privacyUrl?: true
    refundWindowHours?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PlatformSettingsCountAggregateInputType = {
    id?: true
    razorpayKey?: true
    stripeKey?: true
    settlementDays?: true
    cgst?: true
    sgst?: true
    convenienceFee?: true
    theatreName?: true
    supportEmail?: true
    contactNumber?: true
    address?: true
    termsUrl?: true
    privacyUrl?: true
    refundWindowHours?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type PlatformSettingsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PlatformSettings to aggregate.
     */
    where?: PlatformSettingsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PlatformSettings to fetch.
     */
    orderBy?: PlatformSettingsOrderByWithRelationInput | PlatformSettingsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PlatformSettingsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PlatformSettings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PlatformSettings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PlatformSettings
    **/
    _count?: true | PlatformSettingsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PlatformSettingsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PlatformSettingsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PlatformSettingsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PlatformSettingsMaxAggregateInputType
  }

  export type GetPlatformSettingsAggregateType<T extends PlatformSettingsAggregateArgs> = {
        [P in keyof T & keyof AggregatePlatformSettings]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePlatformSettings[P]>
      : GetScalarType<T[P], AggregatePlatformSettings[P]>
  }




  export type PlatformSettingsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PlatformSettingsWhereInput
    orderBy?: PlatformSettingsOrderByWithAggregationInput | PlatformSettingsOrderByWithAggregationInput[]
    by: PlatformSettingsScalarFieldEnum[] | PlatformSettingsScalarFieldEnum
    having?: PlatformSettingsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PlatformSettingsCountAggregateInputType | true
    _avg?: PlatformSettingsAvgAggregateInputType
    _sum?: PlatformSettingsSumAggregateInputType
    _min?: PlatformSettingsMinAggregateInputType
    _max?: PlatformSettingsMaxAggregateInputType
  }

  export type PlatformSettingsGroupByOutputType = {
    id: number
    razorpayKey: string
    stripeKey: string
    settlementDays: number
    cgst: Decimal
    sgst: Decimal
    convenienceFee: Decimal
    theatreName: string
    supportEmail: string
    contactNumber: string
    address: string | null
    termsUrl: string
    privacyUrl: string
    refundWindowHours: number
    createdAt: Date
    updatedAt: Date
    _count: PlatformSettingsCountAggregateOutputType | null
    _avg: PlatformSettingsAvgAggregateOutputType | null
    _sum: PlatformSettingsSumAggregateOutputType | null
    _min: PlatformSettingsMinAggregateOutputType | null
    _max: PlatformSettingsMaxAggregateOutputType | null
  }

  type GetPlatformSettingsGroupByPayload<T extends PlatformSettingsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PlatformSettingsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PlatformSettingsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PlatformSettingsGroupByOutputType[P]>
            : GetScalarType<T[P], PlatformSettingsGroupByOutputType[P]>
        }
      >
    >


  export type PlatformSettingsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    razorpayKey?: boolean
    stripeKey?: boolean
    settlementDays?: boolean
    cgst?: boolean
    sgst?: boolean
    convenienceFee?: boolean
    theatreName?: boolean
    supportEmail?: boolean
    contactNumber?: boolean
    address?: boolean
    termsUrl?: boolean
    privacyUrl?: boolean
    refundWindowHours?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["platformSettings"]>


  export type PlatformSettingsSelectScalar = {
    id?: boolean
    razorpayKey?: boolean
    stripeKey?: boolean
    settlementDays?: boolean
    cgst?: boolean
    sgst?: boolean
    convenienceFee?: boolean
    theatreName?: boolean
    supportEmail?: boolean
    contactNumber?: boolean
    address?: boolean
    termsUrl?: boolean
    privacyUrl?: boolean
    refundWindowHours?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }


  export type $PlatformSettingsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "PlatformSettings"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      razorpayKey: string
      stripeKey: string
      settlementDays: number
      cgst: Prisma.Decimal
      sgst: Prisma.Decimal
      convenienceFee: Prisma.Decimal
      theatreName: string
      supportEmail: string
      contactNumber: string
      address: string | null
      termsUrl: string
      privacyUrl: string
      refundWindowHours: number
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["platformSettings"]>
    composites: {}
  }

  type PlatformSettingsGetPayload<S extends boolean | null | undefined | PlatformSettingsDefaultArgs> = $Result.GetResult<Prisma.$PlatformSettingsPayload, S>

  type PlatformSettingsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<PlatformSettingsFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: PlatformSettingsCountAggregateInputType | true
    }

  export interface PlatformSettingsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PlatformSettings'], meta: { name: 'PlatformSettings' } }
    /**
     * Find zero or one PlatformSettings that matches the filter.
     * @param {PlatformSettingsFindUniqueArgs} args - Arguments to find a PlatformSettings
     * @example
     * // Get one PlatformSettings
     * const platformSettings = await prisma.platformSettings.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PlatformSettingsFindUniqueArgs>(args: SelectSubset<T, PlatformSettingsFindUniqueArgs<ExtArgs>>): Prisma__PlatformSettingsClient<$Result.GetResult<Prisma.$PlatformSettingsPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one PlatformSettings that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {PlatformSettingsFindUniqueOrThrowArgs} args - Arguments to find a PlatformSettings
     * @example
     * // Get one PlatformSettings
     * const platformSettings = await prisma.platformSettings.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PlatformSettingsFindUniqueOrThrowArgs>(args: SelectSubset<T, PlatformSettingsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PlatformSettingsClient<$Result.GetResult<Prisma.$PlatformSettingsPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first PlatformSettings that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlatformSettingsFindFirstArgs} args - Arguments to find a PlatformSettings
     * @example
     * // Get one PlatformSettings
     * const platformSettings = await prisma.platformSettings.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PlatformSettingsFindFirstArgs>(args?: SelectSubset<T, PlatformSettingsFindFirstArgs<ExtArgs>>): Prisma__PlatformSettingsClient<$Result.GetResult<Prisma.$PlatformSettingsPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first PlatformSettings that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlatformSettingsFindFirstOrThrowArgs} args - Arguments to find a PlatformSettings
     * @example
     * // Get one PlatformSettings
     * const platformSettings = await prisma.platformSettings.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PlatformSettingsFindFirstOrThrowArgs>(args?: SelectSubset<T, PlatformSettingsFindFirstOrThrowArgs<ExtArgs>>): Prisma__PlatformSettingsClient<$Result.GetResult<Prisma.$PlatformSettingsPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more PlatformSettings that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlatformSettingsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PlatformSettings
     * const platformSettings = await prisma.platformSettings.findMany()
     * 
     * // Get first 10 PlatformSettings
     * const platformSettings = await prisma.platformSettings.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const platformSettingsWithIdOnly = await prisma.platformSettings.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PlatformSettingsFindManyArgs>(args?: SelectSubset<T, PlatformSettingsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PlatformSettingsPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a PlatformSettings.
     * @param {PlatformSettingsCreateArgs} args - Arguments to create a PlatformSettings.
     * @example
     * // Create one PlatformSettings
     * const PlatformSettings = await prisma.platformSettings.create({
     *   data: {
     *     // ... data to create a PlatformSettings
     *   }
     * })
     * 
     */
    create<T extends PlatformSettingsCreateArgs>(args: SelectSubset<T, PlatformSettingsCreateArgs<ExtArgs>>): Prisma__PlatformSettingsClient<$Result.GetResult<Prisma.$PlatformSettingsPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many PlatformSettings.
     * @param {PlatformSettingsCreateManyArgs} args - Arguments to create many PlatformSettings.
     * @example
     * // Create many PlatformSettings
     * const platformSettings = await prisma.platformSettings.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PlatformSettingsCreateManyArgs>(args?: SelectSubset<T, PlatformSettingsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a PlatformSettings.
     * @param {PlatformSettingsDeleteArgs} args - Arguments to delete one PlatformSettings.
     * @example
     * // Delete one PlatformSettings
     * const PlatformSettings = await prisma.platformSettings.delete({
     *   where: {
     *     // ... filter to delete one PlatformSettings
     *   }
     * })
     * 
     */
    delete<T extends PlatformSettingsDeleteArgs>(args: SelectSubset<T, PlatformSettingsDeleteArgs<ExtArgs>>): Prisma__PlatformSettingsClient<$Result.GetResult<Prisma.$PlatformSettingsPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one PlatformSettings.
     * @param {PlatformSettingsUpdateArgs} args - Arguments to update one PlatformSettings.
     * @example
     * // Update one PlatformSettings
     * const platformSettings = await prisma.platformSettings.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PlatformSettingsUpdateArgs>(args: SelectSubset<T, PlatformSettingsUpdateArgs<ExtArgs>>): Prisma__PlatformSettingsClient<$Result.GetResult<Prisma.$PlatformSettingsPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more PlatformSettings.
     * @param {PlatformSettingsDeleteManyArgs} args - Arguments to filter PlatformSettings to delete.
     * @example
     * // Delete a few PlatformSettings
     * const { count } = await prisma.platformSettings.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PlatformSettingsDeleteManyArgs>(args?: SelectSubset<T, PlatformSettingsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PlatformSettings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlatformSettingsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PlatformSettings
     * const platformSettings = await prisma.platformSettings.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PlatformSettingsUpdateManyArgs>(args: SelectSubset<T, PlatformSettingsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one PlatformSettings.
     * @param {PlatformSettingsUpsertArgs} args - Arguments to update or create a PlatformSettings.
     * @example
     * // Update or create a PlatformSettings
     * const platformSettings = await prisma.platformSettings.upsert({
     *   create: {
     *     // ... data to create a PlatformSettings
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PlatformSettings we want to update
     *   }
     * })
     */
    upsert<T extends PlatformSettingsUpsertArgs>(args: SelectSubset<T, PlatformSettingsUpsertArgs<ExtArgs>>): Prisma__PlatformSettingsClient<$Result.GetResult<Prisma.$PlatformSettingsPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of PlatformSettings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlatformSettingsCountArgs} args - Arguments to filter PlatformSettings to count.
     * @example
     * // Count the number of PlatformSettings
     * const count = await prisma.platformSettings.count({
     *   where: {
     *     // ... the filter for the PlatformSettings we want to count
     *   }
     * })
    **/
    count<T extends PlatformSettingsCountArgs>(
      args?: Subset<T, PlatformSettingsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PlatformSettingsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PlatformSettings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlatformSettingsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PlatformSettingsAggregateArgs>(args: Subset<T, PlatformSettingsAggregateArgs>): Prisma.PrismaPromise<GetPlatformSettingsAggregateType<T>>

    /**
     * Group by PlatformSettings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlatformSettingsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PlatformSettingsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PlatformSettingsGroupByArgs['orderBy'] }
        : { orderBy?: PlatformSettingsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PlatformSettingsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPlatformSettingsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the PlatformSettings model
   */
  readonly fields: PlatformSettingsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PlatformSettings.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PlatformSettingsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the PlatformSettings model
   */ 
  interface PlatformSettingsFieldRefs {
    readonly id: FieldRef<"PlatformSettings", 'Int'>
    readonly razorpayKey: FieldRef<"PlatformSettings", 'String'>
    readonly stripeKey: FieldRef<"PlatformSettings", 'String'>
    readonly settlementDays: FieldRef<"PlatformSettings", 'Int'>
    readonly cgst: FieldRef<"PlatformSettings", 'Decimal'>
    readonly sgst: FieldRef<"PlatformSettings", 'Decimal'>
    readonly convenienceFee: FieldRef<"PlatformSettings", 'Decimal'>
    readonly theatreName: FieldRef<"PlatformSettings", 'String'>
    readonly supportEmail: FieldRef<"PlatformSettings", 'String'>
    readonly contactNumber: FieldRef<"PlatformSettings", 'String'>
    readonly address: FieldRef<"PlatformSettings", 'String'>
    readonly termsUrl: FieldRef<"PlatformSettings", 'String'>
    readonly privacyUrl: FieldRef<"PlatformSettings", 'String'>
    readonly refundWindowHours: FieldRef<"PlatformSettings", 'Int'>
    readonly createdAt: FieldRef<"PlatformSettings", 'DateTime'>
    readonly updatedAt: FieldRef<"PlatformSettings", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * PlatformSettings findUnique
   */
  export type PlatformSettingsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlatformSettings
     */
    select?: PlatformSettingsSelect<ExtArgs> | null
    /**
     * Filter, which PlatformSettings to fetch.
     */
    where: PlatformSettingsWhereUniqueInput
  }

  /**
   * PlatformSettings findUniqueOrThrow
   */
  export type PlatformSettingsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlatformSettings
     */
    select?: PlatformSettingsSelect<ExtArgs> | null
    /**
     * Filter, which PlatformSettings to fetch.
     */
    where: PlatformSettingsWhereUniqueInput
  }

  /**
   * PlatformSettings findFirst
   */
  export type PlatformSettingsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlatformSettings
     */
    select?: PlatformSettingsSelect<ExtArgs> | null
    /**
     * Filter, which PlatformSettings to fetch.
     */
    where?: PlatformSettingsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PlatformSettings to fetch.
     */
    orderBy?: PlatformSettingsOrderByWithRelationInput | PlatformSettingsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PlatformSettings.
     */
    cursor?: PlatformSettingsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PlatformSettings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PlatformSettings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PlatformSettings.
     */
    distinct?: PlatformSettingsScalarFieldEnum | PlatformSettingsScalarFieldEnum[]
  }

  /**
   * PlatformSettings findFirstOrThrow
   */
  export type PlatformSettingsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlatformSettings
     */
    select?: PlatformSettingsSelect<ExtArgs> | null
    /**
     * Filter, which PlatformSettings to fetch.
     */
    where?: PlatformSettingsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PlatformSettings to fetch.
     */
    orderBy?: PlatformSettingsOrderByWithRelationInput | PlatformSettingsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PlatformSettings.
     */
    cursor?: PlatformSettingsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PlatformSettings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PlatformSettings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PlatformSettings.
     */
    distinct?: PlatformSettingsScalarFieldEnum | PlatformSettingsScalarFieldEnum[]
  }

  /**
   * PlatformSettings findMany
   */
  export type PlatformSettingsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlatformSettings
     */
    select?: PlatformSettingsSelect<ExtArgs> | null
    /**
     * Filter, which PlatformSettings to fetch.
     */
    where?: PlatformSettingsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PlatformSettings to fetch.
     */
    orderBy?: PlatformSettingsOrderByWithRelationInput | PlatformSettingsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PlatformSettings.
     */
    cursor?: PlatformSettingsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PlatformSettings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PlatformSettings.
     */
    skip?: number
    distinct?: PlatformSettingsScalarFieldEnum | PlatformSettingsScalarFieldEnum[]
  }

  /**
   * PlatformSettings create
   */
  export type PlatformSettingsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlatformSettings
     */
    select?: PlatformSettingsSelect<ExtArgs> | null
    /**
     * The data needed to create a PlatformSettings.
     */
    data: XOR<PlatformSettingsCreateInput, PlatformSettingsUncheckedCreateInput>
  }

  /**
   * PlatformSettings createMany
   */
  export type PlatformSettingsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many PlatformSettings.
     */
    data: PlatformSettingsCreateManyInput | PlatformSettingsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * PlatformSettings update
   */
  export type PlatformSettingsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlatformSettings
     */
    select?: PlatformSettingsSelect<ExtArgs> | null
    /**
     * The data needed to update a PlatformSettings.
     */
    data: XOR<PlatformSettingsUpdateInput, PlatformSettingsUncheckedUpdateInput>
    /**
     * Choose, which PlatformSettings to update.
     */
    where: PlatformSettingsWhereUniqueInput
  }

  /**
   * PlatformSettings updateMany
   */
  export type PlatformSettingsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update PlatformSettings.
     */
    data: XOR<PlatformSettingsUpdateManyMutationInput, PlatformSettingsUncheckedUpdateManyInput>
    /**
     * Filter which PlatformSettings to update
     */
    where?: PlatformSettingsWhereInput
  }

  /**
   * PlatformSettings upsert
   */
  export type PlatformSettingsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlatformSettings
     */
    select?: PlatformSettingsSelect<ExtArgs> | null
    /**
     * The filter to search for the PlatformSettings to update in case it exists.
     */
    where: PlatformSettingsWhereUniqueInput
    /**
     * In case the PlatformSettings found by the `where` argument doesn't exist, create a new PlatformSettings with this data.
     */
    create: XOR<PlatformSettingsCreateInput, PlatformSettingsUncheckedCreateInput>
    /**
     * In case the PlatformSettings was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PlatformSettingsUpdateInput, PlatformSettingsUncheckedUpdateInput>
  }

  /**
   * PlatformSettings delete
   */
  export type PlatformSettingsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlatformSettings
     */
    select?: PlatformSettingsSelect<ExtArgs> | null
    /**
     * Filter which PlatformSettings to delete.
     */
    where: PlatformSettingsWhereUniqueInput
  }

  /**
   * PlatformSettings deleteMany
   */
  export type PlatformSettingsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PlatformSettings to delete
     */
    where?: PlatformSettingsWhereInput
  }

  /**
   * PlatformSettings without action
   */
  export type PlatformSettingsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlatformSettings
     */
    select?: PlatformSettingsSelect<ExtArgs> | null
  }


  /**
   * Model PaymentAudit
   */

  export type AggregatePaymentAudit = {
    _count: PaymentAuditCountAggregateOutputType | null
    _avg: PaymentAuditAvgAggregateOutputType | null
    _sum: PaymentAuditSumAggregateOutputType | null
    _min: PaymentAuditMinAggregateOutputType | null
    _max: PaymentAuditMaxAggregateOutputType | null
  }

  export type PaymentAuditAvgAggregateOutputType = {
    amount: Decimal | null
  }

  export type PaymentAuditSumAggregateOutputType = {
    amount: Decimal | null
  }

  export type PaymentAuditMinAggregateOutputType = {
    id: string | null
    transactionId: string | null
    status: string | null
    method: string | null
    amount: Decimal | null
    movieTitle: string | null
    showtime: string | null
    createdAt: Date | null
  }

  export type PaymentAuditMaxAggregateOutputType = {
    id: string | null
    transactionId: string | null
    status: string | null
    method: string | null
    amount: Decimal | null
    movieTitle: string | null
    showtime: string | null
    createdAt: Date | null
  }

  export type PaymentAuditCountAggregateOutputType = {
    id: number
    transactionId: number
    status: number
    method: number
    amount: number
    movieTitle: number
    showtime: number
    seats: number
    createdAt: number
    _all: number
  }


  export type PaymentAuditAvgAggregateInputType = {
    amount?: true
  }

  export type PaymentAuditSumAggregateInputType = {
    amount?: true
  }

  export type PaymentAuditMinAggregateInputType = {
    id?: true
    transactionId?: true
    status?: true
    method?: true
    amount?: true
    movieTitle?: true
    showtime?: true
    createdAt?: true
  }

  export type PaymentAuditMaxAggregateInputType = {
    id?: true
    transactionId?: true
    status?: true
    method?: true
    amount?: true
    movieTitle?: true
    showtime?: true
    createdAt?: true
  }

  export type PaymentAuditCountAggregateInputType = {
    id?: true
    transactionId?: true
    status?: true
    method?: true
    amount?: true
    movieTitle?: true
    showtime?: true
    seats?: true
    createdAt?: true
    _all?: true
  }

  export type PaymentAuditAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PaymentAudit to aggregate.
     */
    where?: PaymentAuditWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PaymentAudits to fetch.
     */
    orderBy?: PaymentAuditOrderByWithRelationInput | PaymentAuditOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PaymentAuditWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PaymentAudits from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PaymentAudits.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PaymentAudits
    **/
    _count?: true | PaymentAuditCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PaymentAuditAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PaymentAuditSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PaymentAuditMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PaymentAuditMaxAggregateInputType
  }

  export type GetPaymentAuditAggregateType<T extends PaymentAuditAggregateArgs> = {
        [P in keyof T & keyof AggregatePaymentAudit]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePaymentAudit[P]>
      : GetScalarType<T[P], AggregatePaymentAudit[P]>
  }




  export type PaymentAuditGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PaymentAuditWhereInput
    orderBy?: PaymentAuditOrderByWithAggregationInput | PaymentAuditOrderByWithAggregationInput[]
    by: PaymentAuditScalarFieldEnum[] | PaymentAuditScalarFieldEnum
    having?: PaymentAuditScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PaymentAuditCountAggregateInputType | true
    _avg?: PaymentAuditAvgAggregateInputType
    _sum?: PaymentAuditSumAggregateInputType
    _min?: PaymentAuditMinAggregateInputType
    _max?: PaymentAuditMaxAggregateInputType
  }

  export type PaymentAuditGroupByOutputType = {
    id: string
    transactionId: string
    status: string
    method: string
    amount: Decimal
    movieTitle: string
    showtime: string | null
    seats: JsonValue | null
    createdAt: Date
    _count: PaymentAuditCountAggregateOutputType | null
    _avg: PaymentAuditAvgAggregateOutputType | null
    _sum: PaymentAuditSumAggregateOutputType | null
    _min: PaymentAuditMinAggregateOutputType | null
    _max: PaymentAuditMaxAggregateOutputType | null
  }

  type GetPaymentAuditGroupByPayload<T extends PaymentAuditGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PaymentAuditGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PaymentAuditGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PaymentAuditGroupByOutputType[P]>
            : GetScalarType<T[P], PaymentAuditGroupByOutputType[P]>
        }
      >
    >


  export type PaymentAuditSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    transactionId?: boolean
    status?: boolean
    method?: boolean
    amount?: boolean
    movieTitle?: boolean
    showtime?: boolean
    seats?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["paymentAudit"]>


  export type PaymentAuditSelectScalar = {
    id?: boolean
    transactionId?: boolean
    status?: boolean
    method?: boolean
    amount?: boolean
    movieTitle?: boolean
    showtime?: boolean
    seats?: boolean
    createdAt?: boolean
  }


  export type $PaymentAuditPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "PaymentAudit"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      transactionId: string
      status: string
      method: string
      amount: Prisma.Decimal
      movieTitle: string
      showtime: string | null
      seats: Prisma.JsonValue | null
      createdAt: Date
    }, ExtArgs["result"]["paymentAudit"]>
    composites: {}
  }

  type PaymentAuditGetPayload<S extends boolean | null | undefined | PaymentAuditDefaultArgs> = $Result.GetResult<Prisma.$PaymentAuditPayload, S>

  type PaymentAuditCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<PaymentAuditFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: PaymentAuditCountAggregateInputType | true
    }

  export interface PaymentAuditDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PaymentAudit'], meta: { name: 'PaymentAudit' } }
    /**
     * Find zero or one PaymentAudit that matches the filter.
     * @param {PaymentAuditFindUniqueArgs} args - Arguments to find a PaymentAudit
     * @example
     * // Get one PaymentAudit
     * const paymentAudit = await prisma.paymentAudit.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PaymentAuditFindUniqueArgs>(args: SelectSubset<T, PaymentAuditFindUniqueArgs<ExtArgs>>): Prisma__PaymentAuditClient<$Result.GetResult<Prisma.$PaymentAuditPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one PaymentAudit that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {PaymentAuditFindUniqueOrThrowArgs} args - Arguments to find a PaymentAudit
     * @example
     * // Get one PaymentAudit
     * const paymentAudit = await prisma.paymentAudit.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PaymentAuditFindUniqueOrThrowArgs>(args: SelectSubset<T, PaymentAuditFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PaymentAuditClient<$Result.GetResult<Prisma.$PaymentAuditPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first PaymentAudit that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentAuditFindFirstArgs} args - Arguments to find a PaymentAudit
     * @example
     * // Get one PaymentAudit
     * const paymentAudit = await prisma.paymentAudit.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PaymentAuditFindFirstArgs>(args?: SelectSubset<T, PaymentAuditFindFirstArgs<ExtArgs>>): Prisma__PaymentAuditClient<$Result.GetResult<Prisma.$PaymentAuditPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first PaymentAudit that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentAuditFindFirstOrThrowArgs} args - Arguments to find a PaymentAudit
     * @example
     * // Get one PaymentAudit
     * const paymentAudit = await prisma.paymentAudit.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PaymentAuditFindFirstOrThrowArgs>(args?: SelectSubset<T, PaymentAuditFindFirstOrThrowArgs<ExtArgs>>): Prisma__PaymentAuditClient<$Result.GetResult<Prisma.$PaymentAuditPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more PaymentAudits that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentAuditFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PaymentAudits
     * const paymentAudits = await prisma.paymentAudit.findMany()
     * 
     * // Get first 10 PaymentAudits
     * const paymentAudits = await prisma.paymentAudit.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const paymentAuditWithIdOnly = await prisma.paymentAudit.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PaymentAuditFindManyArgs>(args?: SelectSubset<T, PaymentAuditFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PaymentAuditPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a PaymentAudit.
     * @param {PaymentAuditCreateArgs} args - Arguments to create a PaymentAudit.
     * @example
     * // Create one PaymentAudit
     * const PaymentAudit = await prisma.paymentAudit.create({
     *   data: {
     *     // ... data to create a PaymentAudit
     *   }
     * })
     * 
     */
    create<T extends PaymentAuditCreateArgs>(args: SelectSubset<T, PaymentAuditCreateArgs<ExtArgs>>): Prisma__PaymentAuditClient<$Result.GetResult<Prisma.$PaymentAuditPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many PaymentAudits.
     * @param {PaymentAuditCreateManyArgs} args - Arguments to create many PaymentAudits.
     * @example
     * // Create many PaymentAudits
     * const paymentAudit = await prisma.paymentAudit.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PaymentAuditCreateManyArgs>(args?: SelectSubset<T, PaymentAuditCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a PaymentAudit.
     * @param {PaymentAuditDeleteArgs} args - Arguments to delete one PaymentAudit.
     * @example
     * // Delete one PaymentAudit
     * const PaymentAudit = await prisma.paymentAudit.delete({
     *   where: {
     *     // ... filter to delete one PaymentAudit
     *   }
     * })
     * 
     */
    delete<T extends PaymentAuditDeleteArgs>(args: SelectSubset<T, PaymentAuditDeleteArgs<ExtArgs>>): Prisma__PaymentAuditClient<$Result.GetResult<Prisma.$PaymentAuditPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one PaymentAudit.
     * @param {PaymentAuditUpdateArgs} args - Arguments to update one PaymentAudit.
     * @example
     * // Update one PaymentAudit
     * const paymentAudit = await prisma.paymentAudit.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PaymentAuditUpdateArgs>(args: SelectSubset<T, PaymentAuditUpdateArgs<ExtArgs>>): Prisma__PaymentAuditClient<$Result.GetResult<Prisma.$PaymentAuditPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more PaymentAudits.
     * @param {PaymentAuditDeleteManyArgs} args - Arguments to filter PaymentAudits to delete.
     * @example
     * // Delete a few PaymentAudits
     * const { count } = await prisma.paymentAudit.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PaymentAuditDeleteManyArgs>(args?: SelectSubset<T, PaymentAuditDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PaymentAudits.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentAuditUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PaymentAudits
     * const paymentAudit = await prisma.paymentAudit.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PaymentAuditUpdateManyArgs>(args: SelectSubset<T, PaymentAuditUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one PaymentAudit.
     * @param {PaymentAuditUpsertArgs} args - Arguments to update or create a PaymentAudit.
     * @example
     * // Update or create a PaymentAudit
     * const paymentAudit = await prisma.paymentAudit.upsert({
     *   create: {
     *     // ... data to create a PaymentAudit
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PaymentAudit we want to update
     *   }
     * })
     */
    upsert<T extends PaymentAuditUpsertArgs>(args: SelectSubset<T, PaymentAuditUpsertArgs<ExtArgs>>): Prisma__PaymentAuditClient<$Result.GetResult<Prisma.$PaymentAuditPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of PaymentAudits.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentAuditCountArgs} args - Arguments to filter PaymentAudits to count.
     * @example
     * // Count the number of PaymentAudits
     * const count = await prisma.paymentAudit.count({
     *   where: {
     *     // ... the filter for the PaymentAudits we want to count
     *   }
     * })
    **/
    count<T extends PaymentAuditCountArgs>(
      args?: Subset<T, PaymentAuditCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PaymentAuditCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PaymentAudit.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentAuditAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PaymentAuditAggregateArgs>(args: Subset<T, PaymentAuditAggregateArgs>): Prisma.PrismaPromise<GetPaymentAuditAggregateType<T>>

    /**
     * Group by PaymentAudit.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentAuditGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PaymentAuditGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PaymentAuditGroupByArgs['orderBy'] }
        : { orderBy?: PaymentAuditGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PaymentAuditGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPaymentAuditGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the PaymentAudit model
   */
  readonly fields: PaymentAuditFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PaymentAudit.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PaymentAuditClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the PaymentAudit model
   */ 
  interface PaymentAuditFieldRefs {
    readonly id: FieldRef<"PaymentAudit", 'String'>
    readonly transactionId: FieldRef<"PaymentAudit", 'String'>
    readonly status: FieldRef<"PaymentAudit", 'String'>
    readonly method: FieldRef<"PaymentAudit", 'String'>
    readonly amount: FieldRef<"PaymentAudit", 'Decimal'>
    readonly movieTitle: FieldRef<"PaymentAudit", 'String'>
    readonly showtime: FieldRef<"PaymentAudit", 'String'>
    readonly seats: FieldRef<"PaymentAudit", 'Json'>
    readonly createdAt: FieldRef<"PaymentAudit", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * PaymentAudit findUnique
   */
  export type PaymentAuditFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentAudit
     */
    select?: PaymentAuditSelect<ExtArgs> | null
    /**
     * Filter, which PaymentAudit to fetch.
     */
    where: PaymentAuditWhereUniqueInput
  }

  /**
   * PaymentAudit findUniqueOrThrow
   */
  export type PaymentAuditFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentAudit
     */
    select?: PaymentAuditSelect<ExtArgs> | null
    /**
     * Filter, which PaymentAudit to fetch.
     */
    where: PaymentAuditWhereUniqueInput
  }

  /**
   * PaymentAudit findFirst
   */
  export type PaymentAuditFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentAudit
     */
    select?: PaymentAuditSelect<ExtArgs> | null
    /**
     * Filter, which PaymentAudit to fetch.
     */
    where?: PaymentAuditWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PaymentAudits to fetch.
     */
    orderBy?: PaymentAuditOrderByWithRelationInput | PaymentAuditOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PaymentAudits.
     */
    cursor?: PaymentAuditWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PaymentAudits from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PaymentAudits.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PaymentAudits.
     */
    distinct?: PaymentAuditScalarFieldEnum | PaymentAuditScalarFieldEnum[]
  }

  /**
   * PaymentAudit findFirstOrThrow
   */
  export type PaymentAuditFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentAudit
     */
    select?: PaymentAuditSelect<ExtArgs> | null
    /**
     * Filter, which PaymentAudit to fetch.
     */
    where?: PaymentAuditWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PaymentAudits to fetch.
     */
    orderBy?: PaymentAuditOrderByWithRelationInput | PaymentAuditOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PaymentAudits.
     */
    cursor?: PaymentAuditWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PaymentAudits from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PaymentAudits.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PaymentAudits.
     */
    distinct?: PaymentAuditScalarFieldEnum | PaymentAuditScalarFieldEnum[]
  }

  /**
   * PaymentAudit findMany
   */
  export type PaymentAuditFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentAudit
     */
    select?: PaymentAuditSelect<ExtArgs> | null
    /**
     * Filter, which PaymentAudits to fetch.
     */
    where?: PaymentAuditWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PaymentAudits to fetch.
     */
    orderBy?: PaymentAuditOrderByWithRelationInput | PaymentAuditOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PaymentAudits.
     */
    cursor?: PaymentAuditWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PaymentAudits from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PaymentAudits.
     */
    skip?: number
    distinct?: PaymentAuditScalarFieldEnum | PaymentAuditScalarFieldEnum[]
  }

  /**
   * PaymentAudit create
   */
  export type PaymentAuditCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentAudit
     */
    select?: PaymentAuditSelect<ExtArgs> | null
    /**
     * The data needed to create a PaymentAudit.
     */
    data: XOR<PaymentAuditCreateInput, PaymentAuditUncheckedCreateInput>
  }

  /**
   * PaymentAudit createMany
   */
  export type PaymentAuditCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many PaymentAudits.
     */
    data: PaymentAuditCreateManyInput | PaymentAuditCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * PaymentAudit update
   */
  export type PaymentAuditUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentAudit
     */
    select?: PaymentAuditSelect<ExtArgs> | null
    /**
     * The data needed to update a PaymentAudit.
     */
    data: XOR<PaymentAuditUpdateInput, PaymentAuditUncheckedUpdateInput>
    /**
     * Choose, which PaymentAudit to update.
     */
    where: PaymentAuditWhereUniqueInput
  }

  /**
   * PaymentAudit updateMany
   */
  export type PaymentAuditUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update PaymentAudits.
     */
    data: XOR<PaymentAuditUpdateManyMutationInput, PaymentAuditUncheckedUpdateManyInput>
    /**
     * Filter which PaymentAudits to update
     */
    where?: PaymentAuditWhereInput
  }

  /**
   * PaymentAudit upsert
   */
  export type PaymentAuditUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentAudit
     */
    select?: PaymentAuditSelect<ExtArgs> | null
    /**
     * The filter to search for the PaymentAudit to update in case it exists.
     */
    where: PaymentAuditWhereUniqueInput
    /**
     * In case the PaymentAudit found by the `where` argument doesn't exist, create a new PaymentAudit with this data.
     */
    create: XOR<PaymentAuditCreateInput, PaymentAuditUncheckedCreateInput>
    /**
     * In case the PaymentAudit was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PaymentAuditUpdateInput, PaymentAuditUncheckedUpdateInput>
  }

  /**
   * PaymentAudit delete
   */
  export type PaymentAuditDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentAudit
     */
    select?: PaymentAuditSelect<ExtArgs> | null
    /**
     * Filter which PaymentAudit to delete.
     */
    where: PaymentAuditWhereUniqueInput
  }

  /**
   * PaymentAudit deleteMany
   */
  export type PaymentAuditDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PaymentAudits to delete
     */
    where?: PaymentAuditWhereInput
  }

  /**
   * PaymentAudit without action
   */
  export type PaymentAuditDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentAudit
     */
    select?: PaymentAuditSelect<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const UserScalarFieldEnum: {
    id: 'id',
    email: 'email',
    passwordHash: 'passwordHash',
    displayName: 'displayName',
    avatarUrl: 'avatarUrl',
    phoneNumber: 'phoneNumber',
    isAdmin: 'isAdmin',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type UserScalarFieldEnum = (typeof UserScalarFieldEnum)[keyof typeof UserScalarFieldEnum]


  export const AdminUserScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    status: 'status',
    lastActiveAt: 'lastActiveAt',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type AdminUserScalarFieldEnum = (typeof AdminUserScalarFieldEnum)[keyof typeof AdminUserScalarFieldEnum]


  export const AdminUserRoleScalarFieldEnum: {
    id: 'id',
    adminUserId: 'adminUserId',
    role: 'role'
  };

  export type AdminUserRoleScalarFieldEnum = (typeof AdminUserRoleScalarFieldEnum)[keyof typeof AdminUserRoleScalarFieldEnum]


  export const SessionScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    refreshToken: 'refreshToken',
    expiresAt: 'expiresAt',
    createdAt: 'createdAt',
    revokedAt: 'revokedAt',
    ipAddress: 'ipAddress',
    userAgent: 'userAgent'
  };

  export type SessionScalarFieldEnum = (typeof SessionScalarFieldEnum)[keyof typeof SessionScalarFieldEnum]


  export const PasswordResetTokenScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    otp: 'otp',
    expiresAt: 'expiresAt',
    usedAt: 'usedAt',
    createdAt: 'createdAt'
  };

  export type PasswordResetTokenScalarFieldEnum = (typeof PasswordResetTokenScalarFieldEnum)[keyof typeof PasswordResetTokenScalarFieldEnum]


  export const MovieScalarFieldEnum: {
    id: 'id',
    title: 'title',
    slug: 'slug',
    status: 'status',
    durationMinutes: 'durationMinutes',
    synopsis: 'synopsis',
    tagline: 'tagline',
    posterUrl: 'posterUrl',
    backdropUrl: 'backdropUrl',
    releaseYear: 'releaseYear',
    rating: 'rating',
    isTrending: 'isTrending',
    isTopPick: 'isTopPick',
    isUpcoming: 'isUpcoming',
    metadata: 'metadata',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type MovieScalarFieldEnum = (typeof MovieScalarFieldEnum)[keyof typeof MovieScalarFieldEnum]


  export const MovieGenreScalarFieldEnum: {
    id: 'id',
    movieId: 'movieId',
    name: 'name'
  };

  export type MovieGenreScalarFieldEnum = (typeof MovieGenreScalarFieldEnum)[keyof typeof MovieGenreScalarFieldEnum]


  export const MovieLanguageScalarFieldEnum: {
    id: 'id',
    movieId: 'movieId',
    name: 'name'
  };

  export type MovieLanguageScalarFieldEnum = (typeof MovieLanguageScalarFieldEnum)[keyof typeof MovieLanguageScalarFieldEnum]


  export const AuditoriumScalarFieldEnum: {
    id: 'id',
    cinemaId: 'cinemaId',
    cinemaName: 'cinemaName',
    name: 'name',
    capacity: 'capacity',
    layoutVersion: 'layoutVersion',
    layoutJson: 'layoutJson',
    layoutUpdatedAt: 'layoutUpdatedAt',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type AuditoriumScalarFieldEnum = (typeof AuditoriumScalarFieldEnum)[keyof typeof AuditoriumScalarFieldEnum]


  export const ShowtimeScalarFieldEnum: {
    id: 'id',
    movieId: 'movieId',
    auditoriumId: 'auditoriumId',
    startsAt: 'startsAt',
    endsAt: 'endsAt',
    basePrice: 'basePrice',
    status: 'status',
    seatLayoutVersion: 'seatLayoutVersion',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ShowtimeScalarFieldEnum = (typeof ShowtimeScalarFieldEnum)[keyof typeof ShowtimeScalarFieldEnum]


  export const ShowtimePricingTierScalarFieldEnum: {
    id: 'id',
    showtimeId: 'showtimeId',
    label: 'label',
    price: 'price',
    seatTypes: 'seatTypes',
    createdAt: 'createdAt'
  };

  export type ShowtimePricingTierScalarFieldEnum = (typeof ShowtimePricingTierScalarFieldEnum)[keyof typeof ShowtimePricingTierScalarFieldEnum]


  export const BookingScalarFieldEnum: {
    id: 'id',
    reference: 'reference',
    showtimeId: 'showtimeId',
    userId: 'userId',
    purchaserEmail: 'purchaserEmail',
    purchaserName: 'purchaserName',
    status: 'status',
    totalAmount: 'totalAmount',
    currency: 'currency',
    purchasedAt: 'purchasedAt',
    movieTitle: 'movieTitle'
  };

  export type BookingScalarFieldEnum = (typeof BookingScalarFieldEnum)[keyof typeof BookingScalarFieldEnum]


  export const BookingTicketScalarFieldEnum: {
    id: 'id',
    bookingId: 'bookingId',
    seatId: 'seatId',
    seatLabel: 'seatLabel',
    price: 'price',
    tierLabel: 'tierLabel',
    tierId: 'tierId'
  };

  export type BookingTicketScalarFieldEnum = (typeof BookingTicketScalarFieldEnum)[keyof typeof BookingTicketScalarFieldEnum]


  export const BookingAuditScalarFieldEnum: {
    id: 'id',
    bookingId: 'bookingId',
    type: 'type',
    message: 'message',
    actor: 'actor',
    createdAt: 'createdAt'
  };

  export type BookingAuditScalarFieldEnum = (typeof BookingAuditScalarFieldEnum)[keyof typeof BookingAuditScalarFieldEnum]


  export const SettlementTransactionScalarFieldEnum: {
    id: 'id',
    gateway: 'gateway',
    transactionId: 'transactionId',
    amount: 'amount',
    currency: 'currency',
    status: 'status',
    fees: 'fees',
    netPayout: 'netPayout',
    settledAt: 'settledAt',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    bookingId: 'bookingId'
  };

  export type SettlementTransactionScalarFieldEnum = (typeof SettlementTransactionScalarFieldEnum)[keyof typeof SettlementTransactionScalarFieldEnum]


  export const NotificationSegmentScalarFieldEnum: {
    id: 'id',
    name: 'name',
    description: 'description',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type NotificationSegmentScalarFieldEnum = (typeof NotificationSegmentScalarFieldEnum)[keyof typeof NotificationSegmentScalarFieldEnum]


  export const NotificationCampaignScalarFieldEnum: {
    id: 'id',
    name: 'name',
    subject: 'subject',
    channels: 'channels',
    status: 'status',
    scheduledAt: 'scheduledAt',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    segmentId: 'segmentId',
    statsSent: 'statsSent',
    statsOpened: 'statsOpened',
    statsClicked: 'statsClicked'
  };

  export type NotificationCampaignScalarFieldEnum = (typeof NotificationCampaignScalarFieldEnum)[keyof typeof NotificationCampaignScalarFieldEnum]


  export const PlatformSettingsScalarFieldEnum: {
    id: 'id',
    razorpayKey: 'razorpayKey',
    stripeKey: 'stripeKey',
    settlementDays: 'settlementDays',
    cgst: 'cgst',
    sgst: 'sgst',
    convenienceFee: 'convenienceFee',
    theatreName: 'theatreName',
    supportEmail: 'supportEmail',
    contactNumber: 'contactNumber',
    address: 'address',
    termsUrl: 'termsUrl',
    privacyUrl: 'privacyUrl',
    refundWindowHours: 'refundWindowHours',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type PlatformSettingsScalarFieldEnum = (typeof PlatformSettingsScalarFieldEnum)[keyof typeof PlatformSettingsScalarFieldEnum]


  export const PaymentAuditScalarFieldEnum: {
    id: 'id',
    transactionId: 'transactionId',
    status: 'status',
    method: 'method',
    amount: 'amount',
    movieTitle: 'movieTitle',
    showtime: 'showtime',
    seats: 'seats',
    createdAt: 'createdAt'
  };

  export type PaymentAuditScalarFieldEnum = (typeof PaymentAuditScalarFieldEnum)[keyof typeof PaymentAuditScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const NullableJsonNullValueInput: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull
  };

  export type NullableJsonNullValueInput = (typeof NullableJsonNullValueInput)[keyof typeof NullableJsonNullValueInput]


  export const JsonNullValueInput: {
    JsonNull: typeof JsonNull
  };

  export type JsonNullValueInput = (typeof JsonNullValueInput)[keyof typeof JsonNullValueInput]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  export const JsonNullValueFilter: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull,
    AnyNull: typeof AnyNull
  };

  export type JsonNullValueFilter = (typeof JsonNullValueFilter)[keyof typeof JsonNullValueFilter]


  /**
   * Field references 
   */


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'AdminStatus'
   */
  export type EnumAdminStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'AdminStatus'>
    


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'AdminRole'
   */
  export type EnumAdminRoleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'AdminRole'>
    


  /**
   * Reference to a field of type 'MovieStatus'
   */
  export type EnumMovieStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'MovieStatus'>
    


  /**
   * Reference to a field of type 'Decimal'
   */
  export type DecimalFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Decimal'>
    


  /**
   * Reference to a field of type 'Json'
   */
  export type JsonFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Json'>
    


  /**
   * Reference to a field of type 'ShowtimeStatus'
   */
  export type EnumShowtimeStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ShowtimeStatus'>
    


  /**
   * Reference to a field of type 'BookingStatus'
   */
  export type EnumBookingStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'BookingStatus'>
    


  /**
   * Reference to a field of type 'SettlementStatus'
   */
  export type EnumSettlementStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'SettlementStatus'>
    


  /**
   * Reference to a field of type 'CampaignStatus'
   */
  export type EnumCampaignStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'CampaignStatus'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    
  /**
   * Deep Input Types
   */


  export type UserWhereInput = {
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    id?: StringFilter<"User"> | string
    email?: StringFilter<"User"> | string
    passwordHash?: StringFilter<"User"> | string
    displayName?: StringFilter<"User"> | string
    avatarUrl?: StringNullableFilter<"User"> | string | null
    phoneNumber?: StringNullableFilter<"User"> | string | null
    isAdmin?: BoolFilter<"User"> | boolean
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    adminProfile?: XOR<AdminUserNullableRelationFilter, AdminUserWhereInput> | null
    sessions?: SessionListRelationFilter
    bookings?: BookingListRelationFilter
    passwordResetTokens?: PasswordResetTokenListRelationFilter
  }

  export type UserOrderByWithRelationInput = {
    id?: SortOrder
    email?: SortOrder
    passwordHash?: SortOrder
    displayName?: SortOrder
    avatarUrl?: SortOrderInput | SortOrder
    phoneNumber?: SortOrderInput | SortOrder
    isAdmin?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    adminProfile?: AdminUserOrderByWithRelationInput
    sessions?: SessionOrderByRelationAggregateInput
    bookings?: BookingOrderByRelationAggregateInput
    passwordResetTokens?: PasswordResetTokenOrderByRelationAggregateInput
  }

  export type UserWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    email?: string
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    passwordHash?: StringFilter<"User"> | string
    displayName?: StringFilter<"User"> | string
    avatarUrl?: StringNullableFilter<"User"> | string | null
    phoneNumber?: StringNullableFilter<"User"> | string | null
    isAdmin?: BoolFilter<"User"> | boolean
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    adminProfile?: XOR<AdminUserNullableRelationFilter, AdminUserWhereInput> | null
    sessions?: SessionListRelationFilter
    bookings?: BookingListRelationFilter
    passwordResetTokens?: PasswordResetTokenListRelationFilter
  }, "id" | "email">

  export type UserOrderByWithAggregationInput = {
    id?: SortOrder
    email?: SortOrder
    passwordHash?: SortOrder
    displayName?: SortOrder
    avatarUrl?: SortOrderInput | SortOrder
    phoneNumber?: SortOrderInput | SortOrder
    isAdmin?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: UserCountOrderByAggregateInput
    _max?: UserMaxOrderByAggregateInput
    _min?: UserMinOrderByAggregateInput
  }

  export type UserScalarWhereWithAggregatesInput = {
    AND?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    OR?: UserScalarWhereWithAggregatesInput[]
    NOT?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"User"> | string
    email?: StringWithAggregatesFilter<"User"> | string
    passwordHash?: StringWithAggregatesFilter<"User"> | string
    displayName?: StringWithAggregatesFilter<"User"> | string
    avatarUrl?: StringNullableWithAggregatesFilter<"User"> | string | null
    phoneNumber?: StringNullableWithAggregatesFilter<"User"> | string | null
    isAdmin?: BoolWithAggregatesFilter<"User"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
  }

  export type AdminUserWhereInput = {
    AND?: AdminUserWhereInput | AdminUserWhereInput[]
    OR?: AdminUserWhereInput[]
    NOT?: AdminUserWhereInput | AdminUserWhereInput[]
    id?: StringFilter<"AdminUser"> | string
    userId?: StringFilter<"AdminUser"> | string
    status?: EnumAdminStatusFilter<"AdminUser"> | $Enums.AdminStatus
    lastActiveAt?: DateTimeNullableFilter<"AdminUser"> | Date | string | null
    createdAt?: DateTimeFilter<"AdminUser"> | Date | string
    updatedAt?: DateTimeFilter<"AdminUser"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
    roles?: AdminUserRoleListRelationFilter
  }

  export type AdminUserOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    status?: SortOrder
    lastActiveAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
    roles?: AdminUserRoleOrderByRelationAggregateInput
  }

  export type AdminUserWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    userId?: string
    AND?: AdminUserWhereInput | AdminUserWhereInput[]
    OR?: AdminUserWhereInput[]
    NOT?: AdminUserWhereInput | AdminUserWhereInput[]
    status?: EnumAdminStatusFilter<"AdminUser"> | $Enums.AdminStatus
    lastActiveAt?: DateTimeNullableFilter<"AdminUser"> | Date | string | null
    createdAt?: DateTimeFilter<"AdminUser"> | Date | string
    updatedAt?: DateTimeFilter<"AdminUser"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
    roles?: AdminUserRoleListRelationFilter
  }, "id" | "userId">

  export type AdminUserOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    status?: SortOrder
    lastActiveAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: AdminUserCountOrderByAggregateInput
    _max?: AdminUserMaxOrderByAggregateInput
    _min?: AdminUserMinOrderByAggregateInput
  }

  export type AdminUserScalarWhereWithAggregatesInput = {
    AND?: AdminUserScalarWhereWithAggregatesInput | AdminUserScalarWhereWithAggregatesInput[]
    OR?: AdminUserScalarWhereWithAggregatesInput[]
    NOT?: AdminUserScalarWhereWithAggregatesInput | AdminUserScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"AdminUser"> | string
    userId?: StringWithAggregatesFilter<"AdminUser"> | string
    status?: EnumAdminStatusWithAggregatesFilter<"AdminUser"> | $Enums.AdminStatus
    lastActiveAt?: DateTimeNullableWithAggregatesFilter<"AdminUser"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"AdminUser"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"AdminUser"> | Date | string
  }

  export type AdminUserRoleWhereInput = {
    AND?: AdminUserRoleWhereInput | AdminUserRoleWhereInput[]
    OR?: AdminUserRoleWhereInput[]
    NOT?: AdminUserRoleWhereInput | AdminUserRoleWhereInput[]
    id?: IntFilter<"AdminUserRole"> | number
    adminUserId?: StringFilter<"AdminUserRole"> | string
    role?: EnumAdminRoleFilter<"AdminUserRole"> | $Enums.AdminRole
    adminUser?: XOR<AdminUserRelationFilter, AdminUserWhereInput>
  }

  export type AdminUserRoleOrderByWithRelationInput = {
    id?: SortOrder
    adminUserId?: SortOrder
    role?: SortOrder
    adminUser?: AdminUserOrderByWithRelationInput
  }

  export type AdminUserRoleWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    adminUserId_role?: AdminUserRoleAdminUserIdRoleCompoundUniqueInput
    AND?: AdminUserRoleWhereInput | AdminUserRoleWhereInput[]
    OR?: AdminUserRoleWhereInput[]
    NOT?: AdminUserRoleWhereInput | AdminUserRoleWhereInput[]
    adminUserId?: StringFilter<"AdminUserRole"> | string
    role?: EnumAdminRoleFilter<"AdminUserRole"> | $Enums.AdminRole
    adminUser?: XOR<AdminUserRelationFilter, AdminUserWhereInput>
  }, "id" | "adminUserId_role">

  export type AdminUserRoleOrderByWithAggregationInput = {
    id?: SortOrder
    adminUserId?: SortOrder
    role?: SortOrder
    _count?: AdminUserRoleCountOrderByAggregateInput
    _avg?: AdminUserRoleAvgOrderByAggregateInput
    _max?: AdminUserRoleMaxOrderByAggregateInput
    _min?: AdminUserRoleMinOrderByAggregateInput
    _sum?: AdminUserRoleSumOrderByAggregateInput
  }

  export type AdminUserRoleScalarWhereWithAggregatesInput = {
    AND?: AdminUserRoleScalarWhereWithAggregatesInput | AdminUserRoleScalarWhereWithAggregatesInput[]
    OR?: AdminUserRoleScalarWhereWithAggregatesInput[]
    NOT?: AdminUserRoleScalarWhereWithAggregatesInput | AdminUserRoleScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"AdminUserRole"> | number
    adminUserId?: StringWithAggregatesFilter<"AdminUserRole"> | string
    role?: EnumAdminRoleWithAggregatesFilter<"AdminUserRole"> | $Enums.AdminRole
  }

  export type SessionWhereInput = {
    AND?: SessionWhereInput | SessionWhereInput[]
    OR?: SessionWhereInput[]
    NOT?: SessionWhereInput | SessionWhereInput[]
    id?: StringFilter<"Session"> | string
    userId?: StringFilter<"Session"> | string
    refreshToken?: StringFilter<"Session"> | string
    expiresAt?: DateTimeFilter<"Session"> | Date | string
    createdAt?: DateTimeFilter<"Session"> | Date | string
    revokedAt?: DateTimeNullableFilter<"Session"> | Date | string | null
    ipAddress?: StringNullableFilter<"Session"> | string | null
    userAgent?: StringNullableFilter<"Session"> | string | null
    user?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type SessionOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    refreshToken?: SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrder
    revokedAt?: SortOrderInput | SortOrder
    ipAddress?: SortOrderInput | SortOrder
    userAgent?: SortOrderInput | SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type SessionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    refreshToken?: string
    AND?: SessionWhereInput | SessionWhereInput[]
    OR?: SessionWhereInput[]
    NOT?: SessionWhereInput | SessionWhereInput[]
    userId?: StringFilter<"Session"> | string
    expiresAt?: DateTimeFilter<"Session"> | Date | string
    createdAt?: DateTimeFilter<"Session"> | Date | string
    revokedAt?: DateTimeNullableFilter<"Session"> | Date | string | null
    ipAddress?: StringNullableFilter<"Session"> | string | null
    userAgent?: StringNullableFilter<"Session"> | string | null
    user?: XOR<UserRelationFilter, UserWhereInput>
  }, "id" | "refreshToken">

  export type SessionOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    refreshToken?: SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrder
    revokedAt?: SortOrderInput | SortOrder
    ipAddress?: SortOrderInput | SortOrder
    userAgent?: SortOrderInput | SortOrder
    _count?: SessionCountOrderByAggregateInput
    _max?: SessionMaxOrderByAggregateInput
    _min?: SessionMinOrderByAggregateInput
  }

  export type SessionScalarWhereWithAggregatesInput = {
    AND?: SessionScalarWhereWithAggregatesInput | SessionScalarWhereWithAggregatesInput[]
    OR?: SessionScalarWhereWithAggregatesInput[]
    NOT?: SessionScalarWhereWithAggregatesInput | SessionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Session"> | string
    userId?: StringWithAggregatesFilter<"Session"> | string
    refreshToken?: StringWithAggregatesFilter<"Session"> | string
    expiresAt?: DateTimeWithAggregatesFilter<"Session"> | Date | string
    createdAt?: DateTimeWithAggregatesFilter<"Session"> | Date | string
    revokedAt?: DateTimeNullableWithAggregatesFilter<"Session"> | Date | string | null
    ipAddress?: StringNullableWithAggregatesFilter<"Session"> | string | null
    userAgent?: StringNullableWithAggregatesFilter<"Session"> | string | null
  }

  export type PasswordResetTokenWhereInput = {
    AND?: PasswordResetTokenWhereInput | PasswordResetTokenWhereInput[]
    OR?: PasswordResetTokenWhereInput[]
    NOT?: PasswordResetTokenWhereInput | PasswordResetTokenWhereInput[]
    id?: StringFilter<"PasswordResetToken"> | string
    userId?: StringFilter<"PasswordResetToken"> | string
    otp?: StringFilter<"PasswordResetToken"> | string
    expiresAt?: DateTimeFilter<"PasswordResetToken"> | Date | string
    usedAt?: DateTimeNullableFilter<"PasswordResetToken"> | Date | string | null
    createdAt?: DateTimeFilter<"PasswordResetToken"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type PasswordResetTokenOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    otp?: SortOrder
    expiresAt?: SortOrder
    usedAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type PasswordResetTokenWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: PasswordResetTokenWhereInput | PasswordResetTokenWhereInput[]
    OR?: PasswordResetTokenWhereInput[]
    NOT?: PasswordResetTokenWhereInput | PasswordResetTokenWhereInput[]
    userId?: StringFilter<"PasswordResetToken"> | string
    otp?: StringFilter<"PasswordResetToken"> | string
    expiresAt?: DateTimeFilter<"PasswordResetToken"> | Date | string
    usedAt?: DateTimeNullableFilter<"PasswordResetToken"> | Date | string | null
    createdAt?: DateTimeFilter<"PasswordResetToken"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
  }, "id">

  export type PasswordResetTokenOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    otp?: SortOrder
    expiresAt?: SortOrder
    usedAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: PasswordResetTokenCountOrderByAggregateInput
    _max?: PasswordResetTokenMaxOrderByAggregateInput
    _min?: PasswordResetTokenMinOrderByAggregateInput
  }

  export type PasswordResetTokenScalarWhereWithAggregatesInput = {
    AND?: PasswordResetTokenScalarWhereWithAggregatesInput | PasswordResetTokenScalarWhereWithAggregatesInput[]
    OR?: PasswordResetTokenScalarWhereWithAggregatesInput[]
    NOT?: PasswordResetTokenScalarWhereWithAggregatesInput | PasswordResetTokenScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"PasswordResetToken"> | string
    userId?: StringWithAggregatesFilter<"PasswordResetToken"> | string
    otp?: StringWithAggregatesFilter<"PasswordResetToken"> | string
    expiresAt?: DateTimeWithAggregatesFilter<"PasswordResetToken"> | Date | string
    usedAt?: DateTimeNullableWithAggregatesFilter<"PasswordResetToken"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"PasswordResetToken"> | Date | string
  }

  export type MovieWhereInput = {
    AND?: MovieWhereInput | MovieWhereInput[]
    OR?: MovieWhereInput[]
    NOT?: MovieWhereInput | MovieWhereInput[]
    id?: StringFilter<"Movie"> | string
    title?: StringFilter<"Movie"> | string
    slug?: StringFilter<"Movie"> | string
    status?: EnumMovieStatusFilter<"Movie"> | $Enums.MovieStatus
    durationMinutes?: IntNullableFilter<"Movie"> | number | null
    synopsis?: StringNullableFilter<"Movie"> | string | null
    tagline?: StringNullableFilter<"Movie"> | string | null
    posterUrl?: StringNullableFilter<"Movie"> | string | null
    backdropUrl?: StringNullableFilter<"Movie"> | string | null
    releaseYear?: IntNullableFilter<"Movie"> | number | null
    rating?: DecimalNullableFilter<"Movie"> | Decimal | DecimalJsLike | number | string | null
    isTrending?: BoolFilter<"Movie"> | boolean
    isTopPick?: BoolFilter<"Movie"> | boolean
    isUpcoming?: BoolFilter<"Movie"> | boolean
    metadata?: JsonNullableFilter<"Movie">
    createdAt?: DateTimeFilter<"Movie"> | Date | string
    updatedAt?: DateTimeFilter<"Movie"> | Date | string
    genres?: MovieGenreListRelationFilter
    languages?: MovieLanguageListRelationFilter
    showtimes?: ShowtimeListRelationFilter
  }

  export type MovieOrderByWithRelationInput = {
    id?: SortOrder
    title?: SortOrder
    slug?: SortOrder
    status?: SortOrder
    durationMinutes?: SortOrderInput | SortOrder
    synopsis?: SortOrderInput | SortOrder
    tagline?: SortOrderInput | SortOrder
    posterUrl?: SortOrderInput | SortOrder
    backdropUrl?: SortOrderInput | SortOrder
    releaseYear?: SortOrderInput | SortOrder
    rating?: SortOrderInput | SortOrder
    isTrending?: SortOrder
    isTopPick?: SortOrder
    isUpcoming?: SortOrder
    metadata?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    genres?: MovieGenreOrderByRelationAggregateInput
    languages?: MovieLanguageOrderByRelationAggregateInput
    showtimes?: ShowtimeOrderByRelationAggregateInput
  }

  export type MovieWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    slug?: string
    AND?: MovieWhereInput | MovieWhereInput[]
    OR?: MovieWhereInput[]
    NOT?: MovieWhereInput | MovieWhereInput[]
    title?: StringFilter<"Movie"> | string
    status?: EnumMovieStatusFilter<"Movie"> | $Enums.MovieStatus
    durationMinutes?: IntNullableFilter<"Movie"> | number | null
    synopsis?: StringNullableFilter<"Movie"> | string | null
    tagline?: StringNullableFilter<"Movie"> | string | null
    posterUrl?: StringNullableFilter<"Movie"> | string | null
    backdropUrl?: StringNullableFilter<"Movie"> | string | null
    releaseYear?: IntNullableFilter<"Movie"> | number | null
    rating?: DecimalNullableFilter<"Movie"> | Decimal | DecimalJsLike | number | string | null
    isTrending?: BoolFilter<"Movie"> | boolean
    isTopPick?: BoolFilter<"Movie"> | boolean
    isUpcoming?: BoolFilter<"Movie"> | boolean
    metadata?: JsonNullableFilter<"Movie">
    createdAt?: DateTimeFilter<"Movie"> | Date | string
    updatedAt?: DateTimeFilter<"Movie"> | Date | string
    genres?: MovieGenreListRelationFilter
    languages?: MovieLanguageListRelationFilter
    showtimes?: ShowtimeListRelationFilter
  }, "id" | "slug">

  export type MovieOrderByWithAggregationInput = {
    id?: SortOrder
    title?: SortOrder
    slug?: SortOrder
    status?: SortOrder
    durationMinutes?: SortOrderInput | SortOrder
    synopsis?: SortOrderInput | SortOrder
    tagline?: SortOrderInput | SortOrder
    posterUrl?: SortOrderInput | SortOrder
    backdropUrl?: SortOrderInput | SortOrder
    releaseYear?: SortOrderInput | SortOrder
    rating?: SortOrderInput | SortOrder
    isTrending?: SortOrder
    isTopPick?: SortOrder
    isUpcoming?: SortOrder
    metadata?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: MovieCountOrderByAggregateInput
    _avg?: MovieAvgOrderByAggregateInput
    _max?: MovieMaxOrderByAggregateInput
    _min?: MovieMinOrderByAggregateInput
    _sum?: MovieSumOrderByAggregateInput
  }

  export type MovieScalarWhereWithAggregatesInput = {
    AND?: MovieScalarWhereWithAggregatesInput | MovieScalarWhereWithAggregatesInput[]
    OR?: MovieScalarWhereWithAggregatesInput[]
    NOT?: MovieScalarWhereWithAggregatesInput | MovieScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Movie"> | string
    title?: StringWithAggregatesFilter<"Movie"> | string
    slug?: StringWithAggregatesFilter<"Movie"> | string
    status?: EnumMovieStatusWithAggregatesFilter<"Movie"> | $Enums.MovieStatus
    durationMinutes?: IntNullableWithAggregatesFilter<"Movie"> | number | null
    synopsis?: StringNullableWithAggregatesFilter<"Movie"> | string | null
    tagline?: StringNullableWithAggregatesFilter<"Movie"> | string | null
    posterUrl?: StringNullableWithAggregatesFilter<"Movie"> | string | null
    backdropUrl?: StringNullableWithAggregatesFilter<"Movie"> | string | null
    releaseYear?: IntNullableWithAggregatesFilter<"Movie"> | number | null
    rating?: DecimalNullableWithAggregatesFilter<"Movie"> | Decimal | DecimalJsLike | number | string | null
    isTrending?: BoolWithAggregatesFilter<"Movie"> | boolean
    isTopPick?: BoolWithAggregatesFilter<"Movie"> | boolean
    isUpcoming?: BoolWithAggregatesFilter<"Movie"> | boolean
    metadata?: JsonNullableWithAggregatesFilter<"Movie">
    createdAt?: DateTimeWithAggregatesFilter<"Movie"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Movie"> | Date | string
  }

  export type MovieGenreWhereInput = {
    AND?: MovieGenreWhereInput | MovieGenreWhereInput[]
    OR?: MovieGenreWhereInput[]
    NOT?: MovieGenreWhereInput | MovieGenreWhereInput[]
    id?: IntFilter<"MovieGenre"> | number
    movieId?: StringFilter<"MovieGenre"> | string
    name?: StringFilter<"MovieGenre"> | string
    movie?: XOR<MovieRelationFilter, MovieWhereInput>
  }

  export type MovieGenreOrderByWithRelationInput = {
    id?: SortOrder
    movieId?: SortOrder
    name?: SortOrder
    movie?: MovieOrderByWithRelationInput
  }

  export type MovieGenreWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: MovieGenreWhereInput | MovieGenreWhereInput[]
    OR?: MovieGenreWhereInput[]
    NOT?: MovieGenreWhereInput | MovieGenreWhereInput[]
    movieId?: StringFilter<"MovieGenre"> | string
    name?: StringFilter<"MovieGenre"> | string
    movie?: XOR<MovieRelationFilter, MovieWhereInput>
  }, "id">

  export type MovieGenreOrderByWithAggregationInput = {
    id?: SortOrder
    movieId?: SortOrder
    name?: SortOrder
    _count?: MovieGenreCountOrderByAggregateInput
    _avg?: MovieGenreAvgOrderByAggregateInput
    _max?: MovieGenreMaxOrderByAggregateInput
    _min?: MovieGenreMinOrderByAggregateInput
    _sum?: MovieGenreSumOrderByAggregateInput
  }

  export type MovieGenreScalarWhereWithAggregatesInput = {
    AND?: MovieGenreScalarWhereWithAggregatesInput | MovieGenreScalarWhereWithAggregatesInput[]
    OR?: MovieGenreScalarWhereWithAggregatesInput[]
    NOT?: MovieGenreScalarWhereWithAggregatesInput | MovieGenreScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"MovieGenre"> | number
    movieId?: StringWithAggregatesFilter<"MovieGenre"> | string
    name?: StringWithAggregatesFilter<"MovieGenre"> | string
  }

  export type MovieLanguageWhereInput = {
    AND?: MovieLanguageWhereInput | MovieLanguageWhereInput[]
    OR?: MovieLanguageWhereInput[]
    NOT?: MovieLanguageWhereInput | MovieLanguageWhereInput[]
    id?: IntFilter<"MovieLanguage"> | number
    movieId?: StringFilter<"MovieLanguage"> | string
    name?: StringFilter<"MovieLanguage"> | string
    movie?: XOR<MovieRelationFilter, MovieWhereInput>
  }

  export type MovieLanguageOrderByWithRelationInput = {
    id?: SortOrder
    movieId?: SortOrder
    name?: SortOrder
    movie?: MovieOrderByWithRelationInput
  }

  export type MovieLanguageWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: MovieLanguageWhereInput | MovieLanguageWhereInput[]
    OR?: MovieLanguageWhereInput[]
    NOT?: MovieLanguageWhereInput | MovieLanguageWhereInput[]
    movieId?: StringFilter<"MovieLanguage"> | string
    name?: StringFilter<"MovieLanguage"> | string
    movie?: XOR<MovieRelationFilter, MovieWhereInput>
  }, "id">

  export type MovieLanguageOrderByWithAggregationInput = {
    id?: SortOrder
    movieId?: SortOrder
    name?: SortOrder
    _count?: MovieLanguageCountOrderByAggregateInput
    _avg?: MovieLanguageAvgOrderByAggregateInput
    _max?: MovieLanguageMaxOrderByAggregateInput
    _min?: MovieLanguageMinOrderByAggregateInput
    _sum?: MovieLanguageSumOrderByAggregateInput
  }

  export type MovieLanguageScalarWhereWithAggregatesInput = {
    AND?: MovieLanguageScalarWhereWithAggregatesInput | MovieLanguageScalarWhereWithAggregatesInput[]
    OR?: MovieLanguageScalarWhereWithAggregatesInput[]
    NOT?: MovieLanguageScalarWhereWithAggregatesInput | MovieLanguageScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"MovieLanguage"> | number
    movieId?: StringWithAggregatesFilter<"MovieLanguage"> | string
    name?: StringWithAggregatesFilter<"MovieLanguage"> | string
  }

  export type AuditoriumWhereInput = {
    AND?: AuditoriumWhereInput | AuditoriumWhereInput[]
    OR?: AuditoriumWhereInput[]
    NOT?: AuditoriumWhereInput | AuditoriumWhereInput[]
    id?: StringFilter<"Auditorium"> | string
    cinemaId?: StringFilter<"Auditorium"> | string
    cinemaName?: StringFilter<"Auditorium"> | string
    name?: StringFilter<"Auditorium"> | string
    capacity?: IntFilter<"Auditorium"> | number
    layoutVersion?: IntFilter<"Auditorium"> | number
    layoutJson?: JsonFilter<"Auditorium">
    layoutUpdatedAt?: DateTimeFilter<"Auditorium"> | Date | string
    createdAt?: DateTimeFilter<"Auditorium"> | Date | string
    updatedAt?: DateTimeFilter<"Auditorium"> | Date | string
    showtimes?: ShowtimeListRelationFilter
  }

  export type AuditoriumOrderByWithRelationInput = {
    id?: SortOrder
    cinemaId?: SortOrder
    cinemaName?: SortOrder
    name?: SortOrder
    capacity?: SortOrder
    layoutVersion?: SortOrder
    layoutJson?: SortOrder
    layoutUpdatedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    showtimes?: ShowtimeOrderByRelationAggregateInput
  }

  export type AuditoriumWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: AuditoriumWhereInput | AuditoriumWhereInput[]
    OR?: AuditoriumWhereInput[]
    NOT?: AuditoriumWhereInput | AuditoriumWhereInput[]
    cinemaId?: StringFilter<"Auditorium"> | string
    cinemaName?: StringFilter<"Auditorium"> | string
    name?: StringFilter<"Auditorium"> | string
    capacity?: IntFilter<"Auditorium"> | number
    layoutVersion?: IntFilter<"Auditorium"> | number
    layoutJson?: JsonFilter<"Auditorium">
    layoutUpdatedAt?: DateTimeFilter<"Auditorium"> | Date | string
    createdAt?: DateTimeFilter<"Auditorium"> | Date | string
    updatedAt?: DateTimeFilter<"Auditorium"> | Date | string
    showtimes?: ShowtimeListRelationFilter
  }, "id">

  export type AuditoriumOrderByWithAggregationInput = {
    id?: SortOrder
    cinemaId?: SortOrder
    cinemaName?: SortOrder
    name?: SortOrder
    capacity?: SortOrder
    layoutVersion?: SortOrder
    layoutJson?: SortOrder
    layoutUpdatedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: AuditoriumCountOrderByAggregateInput
    _avg?: AuditoriumAvgOrderByAggregateInput
    _max?: AuditoriumMaxOrderByAggregateInput
    _min?: AuditoriumMinOrderByAggregateInput
    _sum?: AuditoriumSumOrderByAggregateInput
  }

  export type AuditoriumScalarWhereWithAggregatesInput = {
    AND?: AuditoriumScalarWhereWithAggregatesInput | AuditoriumScalarWhereWithAggregatesInput[]
    OR?: AuditoriumScalarWhereWithAggregatesInput[]
    NOT?: AuditoriumScalarWhereWithAggregatesInput | AuditoriumScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Auditorium"> | string
    cinemaId?: StringWithAggregatesFilter<"Auditorium"> | string
    cinemaName?: StringWithAggregatesFilter<"Auditorium"> | string
    name?: StringWithAggregatesFilter<"Auditorium"> | string
    capacity?: IntWithAggregatesFilter<"Auditorium"> | number
    layoutVersion?: IntWithAggregatesFilter<"Auditorium"> | number
    layoutJson?: JsonWithAggregatesFilter<"Auditorium">
    layoutUpdatedAt?: DateTimeWithAggregatesFilter<"Auditorium"> | Date | string
    createdAt?: DateTimeWithAggregatesFilter<"Auditorium"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Auditorium"> | Date | string
  }

  export type ShowtimeWhereInput = {
    AND?: ShowtimeWhereInput | ShowtimeWhereInput[]
    OR?: ShowtimeWhereInput[]
    NOT?: ShowtimeWhereInput | ShowtimeWhereInput[]
    id?: StringFilter<"Showtime"> | string
    movieId?: StringFilter<"Showtime"> | string
    auditoriumId?: StringFilter<"Showtime"> | string
    startsAt?: DateTimeFilter<"Showtime"> | Date | string
    endsAt?: DateTimeFilter<"Showtime"> | Date | string
    basePrice?: DecimalFilter<"Showtime"> | Decimal | DecimalJsLike | number | string
    status?: EnumShowtimeStatusFilter<"Showtime"> | $Enums.ShowtimeStatus
    seatLayoutVersion?: IntFilter<"Showtime"> | number
    createdAt?: DateTimeFilter<"Showtime"> | Date | string
    updatedAt?: DateTimeFilter<"Showtime"> | Date | string
    movie?: XOR<MovieRelationFilter, MovieWhereInput>
    auditorium?: XOR<AuditoriumRelationFilter, AuditoriumWhereInput>
    pricingTiers?: ShowtimePricingTierListRelationFilter
    bookings?: BookingListRelationFilter
  }

  export type ShowtimeOrderByWithRelationInput = {
    id?: SortOrder
    movieId?: SortOrder
    auditoriumId?: SortOrder
    startsAt?: SortOrder
    endsAt?: SortOrder
    basePrice?: SortOrder
    status?: SortOrder
    seatLayoutVersion?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    movie?: MovieOrderByWithRelationInput
    auditorium?: AuditoriumOrderByWithRelationInput
    pricingTiers?: ShowtimePricingTierOrderByRelationAggregateInput
    bookings?: BookingOrderByRelationAggregateInput
  }

  export type ShowtimeWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ShowtimeWhereInput | ShowtimeWhereInput[]
    OR?: ShowtimeWhereInput[]
    NOT?: ShowtimeWhereInput | ShowtimeWhereInput[]
    movieId?: StringFilter<"Showtime"> | string
    auditoriumId?: StringFilter<"Showtime"> | string
    startsAt?: DateTimeFilter<"Showtime"> | Date | string
    endsAt?: DateTimeFilter<"Showtime"> | Date | string
    basePrice?: DecimalFilter<"Showtime"> | Decimal | DecimalJsLike | number | string
    status?: EnumShowtimeStatusFilter<"Showtime"> | $Enums.ShowtimeStatus
    seatLayoutVersion?: IntFilter<"Showtime"> | number
    createdAt?: DateTimeFilter<"Showtime"> | Date | string
    updatedAt?: DateTimeFilter<"Showtime"> | Date | string
    movie?: XOR<MovieRelationFilter, MovieWhereInput>
    auditorium?: XOR<AuditoriumRelationFilter, AuditoriumWhereInput>
    pricingTiers?: ShowtimePricingTierListRelationFilter
    bookings?: BookingListRelationFilter
  }, "id">

  export type ShowtimeOrderByWithAggregationInput = {
    id?: SortOrder
    movieId?: SortOrder
    auditoriumId?: SortOrder
    startsAt?: SortOrder
    endsAt?: SortOrder
    basePrice?: SortOrder
    status?: SortOrder
    seatLayoutVersion?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ShowtimeCountOrderByAggregateInput
    _avg?: ShowtimeAvgOrderByAggregateInput
    _max?: ShowtimeMaxOrderByAggregateInput
    _min?: ShowtimeMinOrderByAggregateInput
    _sum?: ShowtimeSumOrderByAggregateInput
  }

  export type ShowtimeScalarWhereWithAggregatesInput = {
    AND?: ShowtimeScalarWhereWithAggregatesInput | ShowtimeScalarWhereWithAggregatesInput[]
    OR?: ShowtimeScalarWhereWithAggregatesInput[]
    NOT?: ShowtimeScalarWhereWithAggregatesInput | ShowtimeScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Showtime"> | string
    movieId?: StringWithAggregatesFilter<"Showtime"> | string
    auditoriumId?: StringWithAggregatesFilter<"Showtime"> | string
    startsAt?: DateTimeWithAggregatesFilter<"Showtime"> | Date | string
    endsAt?: DateTimeWithAggregatesFilter<"Showtime"> | Date | string
    basePrice?: DecimalWithAggregatesFilter<"Showtime"> | Decimal | DecimalJsLike | number | string
    status?: EnumShowtimeStatusWithAggregatesFilter<"Showtime"> | $Enums.ShowtimeStatus
    seatLayoutVersion?: IntWithAggregatesFilter<"Showtime"> | number
    createdAt?: DateTimeWithAggregatesFilter<"Showtime"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Showtime"> | Date | string
  }

  export type ShowtimePricingTierWhereInput = {
    AND?: ShowtimePricingTierWhereInput | ShowtimePricingTierWhereInput[]
    OR?: ShowtimePricingTierWhereInput[]
    NOT?: ShowtimePricingTierWhereInput | ShowtimePricingTierWhereInput[]
    id?: StringFilter<"ShowtimePricingTier"> | string
    showtimeId?: StringFilter<"ShowtimePricingTier"> | string
    label?: StringFilter<"ShowtimePricingTier"> | string
    price?: DecimalFilter<"ShowtimePricingTier"> | Decimal | DecimalJsLike | number | string
    seatTypes?: JsonFilter<"ShowtimePricingTier">
    createdAt?: DateTimeFilter<"ShowtimePricingTier"> | Date | string
    showtime?: XOR<ShowtimeRelationFilter, ShowtimeWhereInput>
  }

  export type ShowtimePricingTierOrderByWithRelationInput = {
    id?: SortOrder
    showtimeId?: SortOrder
    label?: SortOrder
    price?: SortOrder
    seatTypes?: SortOrder
    createdAt?: SortOrder
    showtime?: ShowtimeOrderByWithRelationInput
  }

  export type ShowtimePricingTierWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ShowtimePricingTierWhereInput | ShowtimePricingTierWhereInput[]
    OR?: ShowtimePricingTierWhereInput[]
    NOT?: ShowtimePricingTierWhereInput | ShowtimePricingTierWhereInput[]
    showtimeId?: StringFilter<"ShowtimePricingTier"> | string
    label?: StringFilter<"ShowtimePricingTier"> | string
    price?: DecimalFilter<"ShowtimePricingTier"> | Decimal | DecimalJsLike | number | string
    seatTypes?: JsonFilter<"ShowtimePricingTier">
    createdAt?: DateTimeFilter<"ShowtimePricingTier"> | Date | string
    showtime?: XOR<ShowtimeRelationFilter, ShowtimeWhereInput>
  }, "id">

  export type ShowtimePricingTierOrderByWithAggregationInput = {
    id?: SortOrder
    showtimeId?: SortOrder
    label?: SortOrder
    price?: SortOrder
    seatTypes?: SortOrder
    createdAt?: SortOrder
    _count?: ShowtimePricingTierCountOrderByAggregateInput
    _avg?: ShowtimePricingTierAvgOrderByAggregateInput
    _max?: ShowtimePricingTierMaxOrderByAggregateInput
    _min?: ShowtimePricingTierMinOrderByAggregateInput
    _sum?: ShowtimePricingTierSumOrderByAggregateInput
  }

  export type ShowtimePricingTierScalarWhereWithAggregatesInput = {
    AND?: ShowtimePricingTierScalarWhereWithAggregatesInput | ShowtimePricingTierScalarWhereWithAggregatesInput[]
    OR?: ShowtimePricingTierScalarWhereWithAggregatesInput[]
    NOT?: ShowtimePricingTierScalarWhereWithAggregatesInput | ShowtimePricingTierScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ShowtimePricingTier"> | string
    showtimeId?: StringWithAggregatesFilter<"ShowtimePricingTier"> | string
    label?: StringWithAggregatesFilter<"ShowtimePricingTier"> | string
    price?: DecimalWithAggregatesFilter<"ShowtimePricingTier"> | Decimal | DecimalJsLike | number | string
    seatTypes?: JsonWithAggregatesFilter<"ShowtimePricingTier">
    createdAt?: DateTimeWithAggregatesFilter<"ShowtimePricingTier"> | Date | string
  }

  export type BookingWhereInput = {
    AND?: BookingWhereInput | BookingWhereInput[]
    OR?: BookingWhereInput[]
    NOT?: BookingWhereInput | BookingWhereInput[]
    id?: StringFilter<"Booking"> | string
    reference?: StringFilter<"Booking"> | string
    showtimeId?: StringFilter<"Booking"> | string
    userId?: StringNullableFilter<"Booking"> | string | null
    purchaserEmail?: StringFilter<"Booking"> | string
    purchaserName?: StringFilter<"Booking"> | string
    status?: EnumBookingStatusFilter<"Booking"> | $Enums.BookingStatus
    totalAmount?: DecimalFilter<"Booking"> | Decimal | DecimalJsLike | number | string
    currency?: StringFilter<"Booking"> | string
    purchasedAt?: DateTimeFilter<"Booking"> | Date | string
    movieTitle?: StringFilter<"Booking"> | string
    user?: XOR<UserNullableRelationFilter, UserWhereInput> | null
    showtime?: XOR<ShowtimeRelationFilter, ShowtimeWhereInput>
    tickets?: BookingTicketListRelationFilter
    auditLog?: BookingAuditListRelationFilter
    settlements?: SettlementTransactionListRelationFilter
  }

  export type BookingOrderByWithRelationInput = {
    id?: SortOrder
    reference?: SortOrder
    showtimeId?: SortOrder
    userId?: SortOrderInput | SortOrder
    purchaserEmail?: SortOrder
    purchaserName?: SortOrder
    status?: SortOrder
    totalAmount?: SortOrder
    currency?: SortOrder
    purchasedAt?: SortOrder
    movieTitle?: SortOrder
    user?: UserOrderByWithRelationInput
    showtime?: ShowtimeOrderByWithRelationInput
    tickets?: BookingTicketOrderByRelationAggregateInput
    auditLog?: BookingAuditOrderByRelationAggregateInput
    settlements?: SettlementTransactionOrderByRelationAggregateInput
  }

  export type BookingWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    reference?: string
    AND?: BookingWhereInput | BookingWhereInput[]
    OR?: BookingWhereInput[]
    NOT?: BookingWhereInput | BookingWhereInput[]
    showtimeId?: StringFilter<"Booking"> | string
    userId?: StringNullableFilter<"Booking"> | string | null
    purchaserEmail?: StringFilter<"Booking"> | string
    purchaserName?: StringFilter<"Booking"> | string
    status?: EnumBookingStatusFilter<"Booking"> | $Enums.BookingStatus
    totalAmount?: DecimalFilter<"Booking"> | Decimal | DecimalJsLike | number | string
    currency?: StringFilter<"Booking"> | string
    purchasedAt?: DateTimeFilter<"Booking"> | Date | string
    movieTitle?: StringFilter<"Booking"> | string
    user?: XOR<UserNullableRelationFilter, UserWhereInput> | null
    showtime?: XOR<ShowtimeRelationFilter, ShowtimeWhereInput>
    tickets?: BookingTicketListRelationFilter
    auditLog?: BookingAuditListRelationFilter
    settlements?: SettlementTransactionListRelationFilter
  }, "id" | "reference">

  export type BookingOrderByWithAggregationInput = {
    id?: SortOrder
    reference?: SortOrder
    showtimeId?: SortOrder
    userId?: SortOrderInput | SortOrder
    purchaserEmail?: SortOrder
    purchaserName?: SortOrder
    status?: SortOrder
    totalAmount?: SortOrder
    currency?: SortOrder
    purchasedAt?: SortOrder
    movieTitle?: SortOrder
    _count?: BookingCountOrderByAggregateInput
    _avg?: BookingAvgOrderByAggregateInput
    _max?: BookingMaxOrderByAggregateInput
    _min?: BookingMinOrderByAggregateInput
    _sum?: BookingSumOrderByAggregateInput
  }

  export type BookingScalarWhereWithAggregatesInput = {
    AND?: BookingScalarWhereWithAggregatesInput | BookingScalarWhereWithAggregatesInput[]
    OR?: BookingScalarWhereWithAggregatesInput[]
    NOT?: BookingScalarWhereWithAggregatesInput | BookingScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Booking"> | string
    reference?: StringWithAggregatesFilter<"Booking"> | string
    showtimeId?: StringWithAggregatesFilter<"Booking"> | string
    userId?: StringNullableWithAggregatesFilter<"Booking"> | string | null
    purchaserEmail?: StringWithAggregatesFilter<"Booking"> | string
    purchaserName?: StringWithAggregatesFilter<"Booking"> | string
    status?: EnumBookingStatusWithAggregatesFilter<"Booking"> | $Enums.BookingStatus
    totalAmount?: DecimalWithAggregatesFilter<"Booking"> | Decimal | DecimalJsLike | number | string
    currency?: StringWithAggregatesFilter<"Booking"> | string
    purchasedAt?: DateTimeWithAggregatesFilter<"Booking"> | Date | string
    movieTitle?: StringWithAggregatesFilter<"Booking"> | string
  }

  export type BookingTicketWhereInput = {
    AND?: BookingTicketWhereInput | BookingTicketWhereInput[]
    OR?: BookingTicketWhereInput[]
    NOT?: BookingTicketWhereInput | BookingTicketWhereInput[]
    id?: StringFilter<"BookingTicket"> | string
    bookingId?: StringFilter<"BookingTicket"> | string
    seatId?: StringFilter<"BookingTicket"> | string
    seatLabel?: StringFilter<"BookingTicket"> | string
    price?: DecimalFilter<"BookingTicket"> | Decimal | DecimalJsLike | number | string
    tierLabel?: StringNullableFilter<"BookingTicket"> | string | null
    tierId?: StringNullableFilter<"BookingTicket"> | string | null
    booking?: XOR<BookingRelationFilter, BookingWhereInput>
  }

  export type BookingTicketOrderByWithRelationInput = {
    id?: SortOrder
    bookingId?: SortOrder
    seatId?: SortOrder
    seatLabel?: SortOrder
    price?: SortOrder
    tierLabel?: SortOrderInput | SortOrder
    tierId?: SortOrderInput | SortOrder
    booking?: BookingOrderByWithRelationInput
  }

  export type BookingTicketWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: BookingTicketWhereInput | BookingTicketWhereInput[]
    OR?: BookingTicketWhereInput[]
    NOT?: BookingTicketWhereInput | BookingTicketWhereInput[]
    bookingId?: StringFilter<"BookingTicket"> | string
    seatId?: StringFilter<"BookingTicket"> | string
    seatLabel?: StringFilter<"BookingTicket"> | string
    price?: DecimalFilter<"BookingTicket"> | Decimal | DecimalJsLike | number | string
    tierLabel?: StringNullableFilter<"BookingTicket"> | string | null
    tierId?: StringNullableFilter<"BookingTicket"> | string | null
    booking?: XOR<BookingRelationFilter, BookingWhereInput>
  }, "id">

  export type BookingTicketOrderByWithAggregationInput = {
    id?: SortOrder
    bookingId?: SortOrder
    seatId?: SortOrder
    seatLabel?: SortOrder
    price?: SortOrder
    tierLabel?: SortOrderInput | SortOrder
    tierId?: SortOrderInput | SortOrder
    _count?: BookingTicketCountOrderByAggregateInput
    _avg?: BookingTicketAvgOrderByAggregateInput
    _max?: BookingTicketMaxOrderByAggregateInput
    _min?: BookingTicketMinOrderByAggregateInput
    _sum?: BookingTicketSumOrderByAggregateInput
  }

  export type BookingTicketScalarWhereWithAggregatesInput = {
    AND?: BookingTicketScalarWhereWithAggregatesInput | BookingTicketScalarWhereWithAggregatesInput[]
    OR?: BookingTicketScalarWhereWithAggregatesInput[]
    NOT?: BookingTicketScalarWhereWithAggregatesInput | BookingTicketScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"BookingTicket"> | string
    bookingId?: StringWithAggregatesFilter<"BookingTicket"> | string
    seatId?: StringWithAggregatesFilter<"BookingTicket"> | string
    seatLabel?: StringWithAggregatesFilter<"BookingTicket"> | string
    price?: DecimalWithAggregatesFilter<"BookingTicket"> | Decimal | DecimalJsLike | number | string
    tierLabel?: StringNullableWithAggregatesFilter<"BookingTicket"> | string | null
    tierId?: StringNullableWithAggregatesFilter<"BookingTicket"> | string | null
  }

  export type BookingAuditWhereInput = {
    AND?: BookingAuditWhereInput | BookingAuditWhereInput[]
    OR?: BookingAuditWhereInput[]
    NOT?: BookingAuditWhereInput | BookingAuditWhereInput[]
    id?: StringFilter<"BookingAudit"> | string
    bookingId?: StringFilter<"BookingAudit"> | string
    type?: StringFilter<"BookingAudit"> | string
    message?: StringFilter<"BookingAudit"> | string
    actor?: StringFilter<"BookingAudit"> | string
    createdAt?: DateTimeFilter<"BookingAudit"> | Date | string
    booking?: XOR<BookingRelationFilter, BookingWhereInput>
  }

  export type BookingAuditOrderByWithRelationInput = {
    id?: SortOrder
    bookingId?: SortOrder
    type?: SortOrder
    message?: SortOrder
    actor?: SortOrder
    createdAt?: SortOrder
    booking?: BookingOrderByWithRelationInput
  }

  export type BookingAuditWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: BookingAuditWhereInput | BookingAuditWhereInput[]
    OR?: BookingAuditWhereInput[]
    NOT?: BookingAuditWhereInput | BookingAuditWhereInput[]
    bookingId?: StringFilter<"BookingAudit"> | string
    type?: StringFilter<"BookingAudit"> | string
    message?: StringFilter<"BookingAudit"> | string
    actor?: StringFilter<"BookingAudit"> | string
    createdAt?: DateTimeFilter<"BookingAudit"> | Date | string
    booking?: XOR<BookingRelationFilter, BookingWhereInput>
  }, "id">

  export type BookingAuditOrderByWithAggregationInput = {
    id?: SortOrder
    bookingId?: SortOrder
    type?: SortOrder
    message?: SortOrder
    actor?: SortOrder
    createdAt?: SortOrder
    _count?: BookingAuditCountOrderByAggregateInput
    _max?: BookingAuditMaxOrderByAggregateInput
    _min?: BookingAuditMinOrderByAggregateInput
  }

  export type BookingAuditScalarWhereWithAggregatesInput = {
    AND?: BookingAuditScalarWhereWithAggregatesInput | BookingAuditScalarWhereWithAggregatesInput[]
    OR?: BookingAuditScalarWhereWithAggregatesInput[]
    NOT?: BookingAuditScalarWhereWithAggregatesInput | BookingAuditScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"BookingAudit"> | string
    bookingId?: StringWithAggregatesFilter<"BookingAudit"> | string
    type?: StringWithAggregatesFilter<"BookingAudit"> | string
    message?: StringWithAggregatesFilter<"BookingAudit"> | string
    actor?: StringWithAggregatesFilter<"BookingAudit"> | string
    createdAt?: DateTimeWithAggregatesFilter<"BookingAudit"> | Date | string
  }

  export type SettlementTransactionWhereInput = {
    AND?: SettlementTransactionWhereInput | SettlementTransactionWhereInput[]
    OR?: SettlementTransactionWhereInput[]
    NOT?: SettlementTransactionWhereInput | SettlementTransactionWhereInput[]
    id?: StringFilter<"SettlementTransaction"> | string
    gateway?: StringFilter<"SettlementTransaction"> | string
    transactionId?: StringFilter<"SettlementTransaction"> | string
    amount?: DecimalFilter<"SettlementTransaction"> | Decimal | DecimalJsLike | number | string
    currency?: StringFilter<"SettlementTransaction"> | string
    status?: EnumSettlementStatusFilter<"SettlementTransaction"> | $Enums.SettlementStatus
    fees?: DecimalFilter<"SettlementTransaction"> | Decimal | DecimalJsLike | number | string
    netPayout?: DecimalFilter<"SettlementTransaction"> | Decimal | DecimalJsLike | number | string
    settledAt?: DateTimeNullableFilter<"SettlementTransaction"> | Date | string | null
    createdAt?: DateTimeFilter<"SettlementTransaction"> | Date | string
    updatedAt?: DateTimeFilter<"SettlementTransaction"> | Date | string
    bookingId?: StringNullableFilter<"SettlementTransaction"> | string | null
    booking?: XOR<BookingNullableRelationFilter, BookingWhereInput> | null
  }

  export type SettlementTransactionOrderByWithRelationInput = {
    id?: SortOrder
    gateway?: SortOrder
    transactionId?: SortOrder
    amount?: SortOrder
    currency?: SortOrder
    status?: SortOrder
    fees?: SortOrder
    netPayout?: SortOrder
    settledAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    bookingId?: SortOrderInput | SortOrder
    booking?: BookingOrderByWithRelationInput
  }

  export type SettlementTransactionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: SettlementTransactionWhereInput | SettlementTransactionWhereInput[]
    OR?: SettlementTransactionWhereInput[]
    NOT?: SettlementTransactionWhereInput | SettlementTransactionWhereInput[]
    gateway?: StringFilter<"SettlementTransaction"> | string
    transactionId?: StringFilter<"SettlementTransaction"> | string
    amount?: DecimalFilter<"SettlementTransaction"> | Decimal | DecimalJsLike | number | string
    currency?: StringFilter<"SettlementTransaction"> | string
    status?: EnumSettlementStatusFilter<"SettlementTransaction"> | $Enums.SettlementStatus
    fees?: DecimalFilter<"SettlementTransaction"> | Decimal | DecimalJsLike | number | string
    netPayout?: DecimalFilter<"SettlementTransaction"> | Decimal | DecimalJsLike | number | string
    settledAt?: DateTimeNullableFilter<"SettlementTransaction"> | Date | string | null
    createdAt?: DateTimeFilter<"SettlementTransaction"> | Date | string
    updatedAt?: DateTimeFilter<"SettlementTransaction"> | Date | string
    bookingId?: StringNullableFilter<"SettlementTransaction"> | string | null
    booking?: XOR<BookingNullableRelationFilter, BookingWhereInput> | null
  }, "id">

  export type SettlementTransactionOrderByWithAggregationInput = {
    id?: SortOrder
    gateway?: SortOrder
    transactionId?: SortOrder
    amount?: SortOrder
    currency?: SortOrder
    status?: SortOrder
    fees?: SortOrder
    netPayout?: SortOrder
    settledAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    bookingId?: SortOrderInput | SortOrder
    _count?: SettlementTransactionCountOrderByAggregateInput
    _avg?: SettlementTransactionAvgOrderByAggregateInput
    _max?: SettlementTransactionMaxOrderByAggregateInput
    _min?: SettlementTransactionMinOrderByAggregateInput
    _sum?: SettlementTransactionSumOrderByAggregateInput
  }

  export type SettlementTransactionScalarWhereWithAggregatesInput = {
    AND?: SettlementTransactionScalarWhereWithAggregatesInput | SettlementTransactionScalarWhereWithAggregatesInput[]
    OR?: SettlementTransactionScalarWhereWithAggregatesInput[]
    NOT?: SettlementTransactionScalarWhereWithAggregatesInput | SettlementTransactionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"SettlementTransaction"> | string
    gateway?: StringWithAggregatesFilter<"SettlementTransaction"> | string
    transactionId?: StringWithAggregatesFilter<"SettlementTransaction"> | string
    amount?: DecimalWithAggregatesFilter<"SettlementTransaction"> | Decimal | DecimalJsLike | number | string
    currency?: StringWithAggregatesFilter<"SettlementTransaction"> | string
    status?: EnumSettlementStatusWithAggregatesFilter<"SettlementTransaction"> | $Enums.SettlementStatus
    fees?: DecimalWithAggregatesFilter<"SettlementTransaction"> | Decimal | DecimalJsLike | number | string
    netPayout?: DecimalWithAggregatesFilter<"SettlementTransaction"> | Decimal | DecimalJsLike | number | string
    settledAt?: DateTimeNullableWithAggregatesFilter<"SettlementTransaction"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"SettlementTransaction"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"SettlementTransaction"> | Date | string
    bookingId?: StringNullableWithAggregatesFilter<"SettlementTransaction"> | string | null
  }

  export type NotificationSegmentWhereInput = {
    AND?: NotificationSegmentWhereInput | NotificationSegmentWhereInput[]
    OR?: NotificationSegmentWhereInput[]
    NOT?: NotificationSegmentWhereInput | NotificationSegmentWhereInput[]
    id?: StringFilter<"NotificationSegment"> | string
    name?: StringFilter<"NotificationSegment"> | string
    description?: StringNullableFilter<"NotificationSegment"> | string | null
    createdAt?: DateTimeFilter<"NotificationSegment"> | Date | string
    updatedAt?: DateTimeFilter<"NotificationSegment"> | Date | string
    campaigns?: NotificationCampaignListRelationFilter
  }

  export type NotificationSegmentOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    campaigns?: NotificationCampaignOrderByRelationAggregateInput
  }

  export type NotificationSegmentWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: NotificationSegmentWhereInput | NotificationSegmentWhereInput[]
    OR?: NotificationSegmentWhereInput[]
    NOT?: NotificationSegmentWhereInput | NotificationSegmentWhereInput[]
    name?: StringFilter<"NotificationSegment"> | string
    description?: StringNullableFilter<"NotificationSegment"> | string | null
    createdAt?: DateTimeFilter<"NotificationSegment"> | Date | string
    updatedAt?: DateTimeFilter<"NotificationSegment"> | Date | string
    campaigns?: NotificationCampaignListRelationFilter
  }, "id">

  export type NotificationSegmentOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: NotificationSegmentCountOrderByAggregateInput
    _max?: NotificationSegmentMaxOrderByAggregateInput
    _min?: NotificationSegmentMinOrderByAggregateInput
  }

  export type NotificationSegmentScalarWhereWithAggregatesInput = {
    AND?: NotificationSegmentScalarWhereWithAggregatesInput | NotificationSegmentScalarWhereWithAggregatesInput[]
    OR?: NotificationSegmentScalarWhereWithAggregatesInput[]
    NOT?: NotificationSegmentScalarWhereWithAggregatesInput | NotificationSegmentScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"NotificationSegment"> | string
    name?: StringWithAggregatesFilter<"NotificationSegment"> | string
    description?: StringNullableWithAggregatesFilter<"NotificationSegment"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"NotificationSegment"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"NotificationSegment"> | Date | string
  }

  export type NotificationCampaignWhereInput = {
    AND?: NotificationCampaignWhereInput | NotificationCampaignWhereInput[]
    OR?: NotificationCampaignWhereInput[]
    NOT?: NotificationCampaignWhereInput | NotificationCampaignWhereInput[]
    id?: StringFilter<"NotificationCampaign"> | string
    name?: StringFilter<"NotificationCampaign"> | string
    subject?: StringFilter<"NotificationCampaign"> | string
    channels?: JsonFilter<"NotificationCampaign">
    status?: EnumCampaignStatusFilter<"NotificationCampaign"> | $Enums.CampaignStatus
    scheduledAt?: DateTimeNullableFilter<"NotificationCampaign"> | Date | string | null
    createdAt?: DateTimeFilter<"NotificationCampaign"> | Date | string
    updatedAt?: DateTimeFilter<"NotificationCampaign"> | Date | string
    segmentId?: StringFilter<"NotificationCampaign"> | string
    statsSent?: IntFilter<"NotificationCampaign"> | number
    statsOpened?: IntFilter<"NotificationCampaign"> | number
    statsClicked?: IntFilter<"NotificationCampaign"> | number
    segment?: XOR<NotificationSegmentRelationFilter, NotificationSegmentWhereInput>
  }

  export type NotificationCampaignOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    subject?: SortOrder
    channels?: SortOrder
    status?: SortOrder
    scheduledAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    segmentId?: SortOrder
    statsSent?: SortOrder
    statsOpened?: SortOrder
    statsClicked?: SortOrder
    segment?: NotificationSegmentOrderByWithRelationInput
  }

  export type NotificationCampaignWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: NotificationCampaignWhereInput | NotificationCampaignWhereInput[]
    OR?: NotificationCampaignWhereInput[]
    NOT?: NotificationCampaignWhereInput | NotificationCampaignWhereInput[]
    name?: StringFilter<"NotificationCampaign"> | string
    subject?: StringFilter<"NotificationCampaign"> | string
    channels?: JsonFilter<"NotificationCampaign">
    status?: EnumCampaignStatusFilter<"NotificationCampaign"> | $Enums.CampaignStatus
    scheduledAt?: DateTimeNullableFilter<"NotificationCampaign"> | Date | string | null
    createdAt?: DateTimeFilter<"NotificationCampaign"> | Date | string
    updatedAt?: DateTimeFilter<"NotificationCampaign"> | Date | string
    segmentId?: StringFilter<"NotificationCampaign"> | string
    statsSent?: IntFilter<"NotificationCampaign"> | number
    statsOpened?: IntFilter<"NotificationCampaign"> | number
    statsClicked?: IntFilter<"NotificationCampaign"> | number
    segment?: XOR<NotificationSegmentRelationFilter, NotificationSegmentWhereInput>
  }, "id">

  export type NotificationCampaignOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    subject?: SortOrder
    channels?: SortOrder
    status?: SortOrder
    scheduledAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    segmentId?: SortOrder
    statsSent?: SortOrder
    statsOpened?: SortOrder
    statsClicked?: SortOrder
    _count?: NotificationCampaignCountOrderByAggregateInput
    _avg?: NotificationCampaignAvgOrderByAggregateInput
    _max?: NotificationCampaignMaxOrderByAggregateInput
    _min?: NotificationCampaignMinOrderByAggregateInput
    _sum?: NotificationCampaignSumOrderByAggregateInput
  }

  export type NotificationCampaignScalarWhereWithAggregatesInput = {
    AND?: NotificationCampaignScalarWhereWithAggregatesInput | NotificationCampaignScalarWhereWithAggregatesInput[]
    OR?: NotificationCampaignScalarWhereWithAggregatesInput[]
    NOT?: NotificationCampaignScalarWhereWithAggregatesInput | NotificationCampaignScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"NotificationCampaign"> | string
    name?: StringWithAggregatesFilter<"NotificationCampaign"> | string
    subject?: StringWithAggregatesFilter<"NotificationCampaign"> | string
    channels?: JsonWithAggregatesFilter<"NotificationCampaign">
    status?: EnumCampaignStatusWithAggregatesFilter<"NotificationCampaign"> | $Enums.CampaignStatus
    scheduledAt?: DateTimeNullableWithAggregatesFilter<"NotificationCampaign"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"NotificationCampaign"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"NotificationCampaign"> | Date | string
    segmentId?: StringWithAggregatesFilter<"NotificationCampaign"> | string
    statsSent?: IntWithAggregatesFilter<"NotificationCampaign"> | number
    statsOpened?: IntWithAggregatesFilter<"NotificationCampaign"> | number
    statsClicked?: IntWithAggregatesFilter<"NotificationCampaign"> | number
  }

  export type PlatformSettingsWhereInput = {
    AND?: PlatformSettingsWhereInput | PlatformSettingsWhereInput[]
    OR?: PlatformSettingsWhereInput[]
    NOT?: PlatformSettingsWhereInput | PlatformSettingsWhereInput[]
    id?: IntFilter<"PlatformSettings"> | number
    razorpayKey?: StringFilter<"PlatformSettings"> | string
    stripeKey?: StringFilter<"PlatformSettings"> | string
    settlementDays?: IntFilter<"PlatformSettings"> | number
    cgst?: DecimalFilter<"PlatformSettings"> | Decimal | DecimalJsLike | number | string
    sgst?: DecimalFilter<"PlatformSettings"> | Decimal | DecimalJsLike | number | string
    convenienceFee?: DecimalFilter<"PlatformSettings"> | Decimal | DecimalJsLike | number | string
    theatreName?: StringFilter<"PlatformSettings"> | string
    supportEmail?: StringFilter<"PlatformSettings"> | string
    contactNumber?: StringFilter<"PlatformSettings"> | string
    address?: StringNullableFilter<"PlatformSettings"> | string | null
    termsUrl?: StringFilter<"PlatformSettings"> | string
    privacyUrl?: StringFilter<"PlatformSettings"> | string
    refundWindowHours?: IntFilter<"PlatformSettings"> | number
    createdAt?: DateTimeFilter<"PlatformSettings"> | Date | string
    updatedAt?: DateTimeFilter<"PlatformSettings"> | Date | string
  }

  export type PlatformSettingsOrderByWithRelationInput = {
    id?: SortOrder
    razorpayKey?: SortOrder
    stripeKey?: SortOrder
    settlementDays?: SortOrder
    cgst?: SortOrder
    sgst?: SortOrder
    convenienceFee?: SortOrder
    theatreName?: SortOrder
    supportEmail?: SortOrder
    contactNumber?: SortOrder
    address?: SortOrderInput | SortOrder
    termsUrl?: SortOrder
    privacyUrl?: SortOrder
    refundWindowHours?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PlatformSettingsWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: PlatformSettingsWhereInput | PlatformSettingsWhereInput[]
    OR?: PlatformSettingsWhereInput[]
    NOT?: PlatformSettingsWhereInput | PlatformSettingsWhereInput[]
    razorpayKey?: StringFilter<"PlatformSettings"> | string
    stripeKey?: StringFilter<"PlatformSettings"> | string
    settlementDays?: IntFilter<"PlatformSettings"> | number
    cgst?: DecimalFilter<"PlatformSettings"> | Decimal | DecimalJsLike | number | string
    sgst?: DecimalFilter<"PlatformSettings"> | Decimal | DecimalJsLike | number | string
    convenienceFee?: DecimalFilter<"PlatformSettings"> | Decimal | DecimalJsLike | number | string
    theatreName?: StringFilter<"PlatformSettings"> | string
    supportEmail?: StringFilter<"PlatformSettings"> | string
    contactNumber?: StringFilter<"PlatformSettings"> | string
    address?: StringNullableFilter<"PlatformSettings"> | string | null
    termsUrl?: StringFilter<"PlatformSettings"> | string
    privacyUrl?: StringFilter<"PlatformSettings"> | string
    refundWindowHours?: IntFilter<"PlatformSettings"> | number
    createdAt?: DateTimeFilter<"PlatformSettings"> | Date | string
    updatedAt?: DateTimeFilter<"PlatformSettings"> | Date | string
  }, "id">

  export type PlatformSettingsOrderByWithAggregationInput = {
    id?: SortOrder
    razorpayKey?: SortOrder
    stripeKey?: SortOrder
    settlementDays?: SortOrder
    cgst?: SortOrder
    sgst?: SortOrder
    convenienceFee?: SortOrder
    theatreName?: SortOrder
    supportEmail?: SortOrder
    contactNumber?: SortOrder
    address?: SortOrderInput | SortOrder
    termsUrl?: SortOrder
    privacyUrl?: SortOrder
    refundWindowHours?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: PlatformSettingsCountOrderByAggregateInput
    _avg?: PlatformSettingsAvgOrderByAggregateInput
    _max?: PlatformSettingsMaxOrderByAggregateInput
    _min?: PlatformSettingsMinOrderByAggregateInput
    _sum?: PlatformSettingsSumOrderByAggregateInput
  }

  export type PlatformSettingsScalarWhereWithAggregatesInput = {
    AND?: PlatformSettingsScalarWhereWithAggregatesInput | PlatformSettingsScalarWhereWithAggregatesInput[]
    OR?: PlatformSettingsScalarWhereWithAggregatesInput[]
    NOT?: PlatformSettingsScalarWhereWithAggregatesInput | PlatformSettingsScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"PlatformSettings"> | number
    razorpayKey?: StringWithAggregatesFilter<"PlatformSettings"> | string
    stripeKey?: StringWithAggregatesFilter<"PlatformSettings"> | string
    settlementDays?: IntWithAggregatesFilter<"PlatformSettings"> | number
    cgst?: DecimalWithAggregatesFilter<"PlatformSettings"> | Decimal | DecimalJsLike | number | string
    sgst?: DecimalWithAggregatesFilter<"PlatformSettings"> | Decimal | DecimalJsLike | number | string
    convenienceFee?: DecimalWithAggregatesFilter<"PlatformSettings"> | Decimal | DecimalJsLike | number | string
    theatreName?: StringWithAggregatesFilter<"PlatformSettings"> | string
    supportEmail?: StringWithAggregatesFilter<"PlatformSettings"> | string
    contactNumber?: StringWithAggregatesFilter<"PlatformSettings"> | string
    address?: StringNullableWithAggregatesFilter<"PlatformSettings"> | string | null
    termsUrl?: StringWithAggregatesFilter<"PlatformSettings"> | string
    privacyUrl?: StringWithAggregatesFilter<"PlatformSettings"> | string
    refundWindowHours?: IntWithAggregatesFilter<"PlatformSettings"> | number
    createdAt?: DateTimeWithAggregatesFilter<"PlatformSettings"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"PlatformSettings"> | Date | string
  }

  export type PaymentAuditWhereInput = {
    AND?: PaymentAuditWhereInput | PaymentAuditWhereInput[]
    OR?: PaymentAuditWhereInput[]
    NOT?: PaymentAuditWhereInput | PaymentAuditWhereInput[]
    id?: StringFilter<"PaymentAudit"> | string
    transactionId?: StringFilter<"PaymentAudit"> | string
    status?: StringFilter<"PaymentAudit"> | string
    method?: StringFilter<"PaymentAudit"> | string
    amount?: DecimalFilter<"PaymentAudit"> | Decimal | DecimalJsLike | number | string
    movieTitle?: StringFilter<"PaymentAudit"> | string
    showtime?: StringNullableFilter<"PaymentAudit"> | string | null
    seats?: JsonNullableFilter<"PaymentAudit">
    createdAt?: DateTimeFilter<"PaymentAudit"> | Date | string
  }

  export type PaymentAuditOrderByWithRelationInput = {
    id?: SortOrder
    transactionId?: SortOrder
    status?: SortOrder
    method?: SortOrder
    amount?: SortOrder
    movieTitle?: SortOrder
    showtime?: SortOrderInput | SortOrder
    seats?: SortOrderInput | SortOrder
    createdAt?: SortOrder
  }

  export type PaymentAuditWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    transactionId?: string
    AND?: PaymentAuditWhereInput | PaymentAuditWhereInput[]
    OR?: PaymentAuditWhereInput[]
    NOT?: PaymentAuditWhereInput | PaymentAuditWhereInput[]
    status?: StringFilter<"PaymentAudit"> | string
    method?: StringFilter<"PaymentAudit"> | string
    amount?: DecimalFilter<"PaymentAudit"> | Decimal | DecimalJsLike | number | string
    movieTitle?: StringFilter<"PaymentAudit"> | string
    showtime?: StringNullableFilter<"PaymentAudit"> | string | null
    seats?: JsonNullableFilter<"PaymentAudit">
    createdAt?: DateTimeFilter<"PaymentAudit"> | Date | string
  }, "id" | "transactionId">

  export type PaymentAuditOrderByWithAggregationInput = {
    id?: SortOrder
    transactionId?: SortOrder
    status?: SortOrder
    method?: SortOrder
    amount?: SortOrder
    movieTitle?: SortOrder
    showtime?: SortOrderInput | SortOrder
    seats?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: PaymentAuditCountOrderByAggregateInput
    _avg?: PaymentAuditAvgOrderByAggregateInput
    _max?: PaymentAuditMaxOrderByAggregateInput
    _min?: PaymentAuditMinOrderByAggregateInput
    _sum?: PaymentAuditSumOrderByAggregateInput
  }

  export type PaymentAuditScalarWhereWithAggregatesInput = {
    AND?: PaymentAuditScalarWhereWithAggregatesInput | PaymentAuditScalarWhereWithAggregatesInput[]
    OR?: PaymentAuditScalarWhereWithAggregatesInput[]
    NOT?: PaymentAuditScalarWhereWithAggregatesInput | PaymentAuditScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"PaymentAudit"> | string
    transactionId?: StringWithAggregatesFilter<"PaymentAudit"> | string
    status?: StringWithAggregatesFilter<"PaymentAudit"> | string
    method?: StringWithAggregatesFilter<"PaymentAudit"> | string
    amount?: DecimalWithAggregatesFilter<"PaymentAudit"> | Decimal | DecimalJsLike | number | string
    movieTitle?: StringWithAggregatesFilter<"PaymentAudit"> | string
    showtime?: StringNullableWithAggregatesFilter<"PaymentAudit"> | string | null
    seats?: JsonNullableWithAggregatesFilter<"PaymentAudit">
    createdAt?: DateTimeWithAggregatesFilter<"PaymentAudit"> | Date | string
  }

  export type UserCreateInput = {
    id?: string
    email: string
    passwordHash: string
    displayName: string
    avatarUrl?: string | null
    phoneNumber?: string | null
    isAdmin?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    adminProfile?: AdminUserCreateNestedOneWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    bookings?: BookingCreateNestedManyWithoutUserInput
    passwordResetTokens?: PasswordResetTokenCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateInput = {
    id?: string
    email: string
    passwordHash: string
    displayName: string
    avatarUrl?: string | null
    phoneNumber?: string | null
    isAdmin?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    adminProfile?: AdminUserUncheckedCreateNestedOneWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    bookings?: BookingUncheckedCreateNestedManyWithoutUserInput
    passwordResetTokens?: PasswordResetTokenUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    displayName?: StringFieldUpdateOperationsInput | string
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    isAdmin?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    adminProfile?: AdminUserUpdateOneWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    bookings?: BookingUpdateManyWithoutUserNestedInput
    passwordResetTokens?: PasswordResetTokenUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    displayName?: StringFieldUpdateOperationsInput | string
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    isAdmin?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    adminProfile?: AdminUserUncheckedUpdateOneWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    bookings?: BookingUncheckedUpdateManyWithoutUserNestedInput
    passwordResetTokens?: PasswordResetTokenUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateManyInput = {
    id?: string
    email: string
    passwordHash: string
    displayName: string
    avatarUrl?: string | null
    phoneNumber?: string | null
    isAdmin?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    displayName?: StringFieldUpdateOperationsInput | string
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    isAdmin?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    displayName?: StringFieldUpdateOperationsInput | string
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    isAdmin?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AdminUserCreateInput = {
    id?: string
    status?: $Enums.AdminStatus
    lastActiveAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutAdminProfileInput
    roles?: AdminUserRoleCreateNestedManyWithoutAdminUserInput
  }

  export type AdminUserUncheckedCreateInput = {
    id?: string
    userId: string
    status?: $Enums.AdminStatus
    lastActiveAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    roles?: AdminUserRoleUncheckedCreateNestedManyWithoutAdminUserInput
  }

  export type AdminUserUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumAdminStatusFieldUpdateOperationsInput | $Enums.AdminStatus
    lastActiveAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutAdminProfileNestedInput
    roles?: AdminUserRoleUpdateManyWithoutAdminUserNestedInput
  }

  export type AdminUserUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    status?: EnumAdminStatusFieldUpdateOperationsInput | $Enums.AdminStatus
    lastActiveAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    roles?: AdminUserRoleUncheckedUpdateManyWithoutAdminUserNestedInput
  }

  export type AdminUserCreateManyInput = {
    id?: string
    userId: string
    status?: $Enums.AdminStatus
    lastActiveAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AdminUserUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumAdminStatusFieldUpdateOperationsInput | $Enums.AdminStatus
    lastActiveAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AdminUserUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    status?: EnumAdminStatusFieldUpdateOperationsInput | $Enums.AdminStatus
    lastActiveAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AdminUserRoleCreateInput = {
    role: $Enums.AdminRole
    adminUser: AdminUserCreateNestedOneWithoutRolesInput
  }

  export type AdminUserRoleUncheckedCreateInput = {
    id?: number
    adminUserId: string
    role: $Enums.AdminRole
  }

  export type AdminUserRoleUpdateInput = {
    role?: EnumAdminRoleFieldUpdateOperationsInput | $Enums.AdminRole
    adminUser?: AdminUserUpdateOneRequiredWithoutRolesNestedInput
  }

  export type AdminUserRoleUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    adminUserId?: StringFieldUpdateOperationsInput | string
    role?: EnumAdminRoleFieldUpdateOperationsInput | $Enums.AdminRole
  }

  export type AdminUserRoleCreateManyInput = {
    id?: number
    adminUserId: string
    role: $Enums.AdminRole
  }

  export type AdminUserRoleUpdateManyMutationInput = {
    role?: EnumAdminRoleFieldUpdateOperationsInput | $Enums.AdminRole
  }

  export type AdminUserRoleUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    adminUserId?: StringFieldUpdateOperationsInput | string
    role?: EnumAdminRoleFieldUpdateOperationsInput | $Enums.AdminRole
  }

  export type SessionCreateInput = {
    id?: string
    refreshToken: string
    expiresAt: Date | string
    createdAt?: Date | string
    revokedAt?: Date | string | null
    ipAddress?: string | null
    userAgent?: string | null
    user: UserCreateNestedOneWithoutSessionsInput
  }

  export type SessionUncheckedCreateInput = {
    id?: string
    userId: string
    refreshToken: string
    expiresAt: Date | string
    createdAt?: Date | string
    revokedAt?: Date | string | null
    ipAddress?: string | null
    userAgent?: string | null
  }

  export type SessionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    refreshToken?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    revokedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    user?: UserUpdateOneRequiredWithoutSessionsNestedInput
  }

  export type SessionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    refreshToken?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    revokedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type SessionCreateManyInput = {
    id?: string
    userId: string
    refreshToken: string
    expiresAt: Date | string
    createdAt?: Date | string
    revokedAt?: Date | string | null
    ipAddress?: string | null
    userAgent?: string | null
  }

  export type SessionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    refreshToken?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    revokedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type SessionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    refreshToken?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    revokedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type PasswordResetTokenCreateInput = {
    id?: string
    otp: string
    expiresAt: Date | string
    usedAt?: Date | string | null
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutPasswordResetTokensInput
  }

  export type PasswordResetTokenUncheckedCreateInput = {
    id?: string
    userId: string
    otp: string
    expiresAt: Date | string
    usedAt?: Date | string | null
    createdAt?: Date | string
  }

  export type PasswordResetTokenUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    otp?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    usedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutPasswordResetTokensNestedInput
  }

  export type PasswordResetTokenUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    otp?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    usedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PasswordResetTokenCreateManyInput = {
    id?: string
    userId: string
    otp: string
    expiresAt: Date | string
    usedAt?: Date | string | null
    createdAt?: Date | string
  }

  export type PasswordResetTokenUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    otp?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    usedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PasswordResetTokenUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    otp?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    usedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MovieCreateInput = {
    id?: string
    title: string
    slug: string
    status?: $Enums.MovieStatus
    durationMinutes?: number | null
    synopsis?: string | null
    tagline?: string | null
    posterUrl?: string | null
    backdropUrl?: string | null
    releaseYear?: number | null
    rating?: Decimal | DecimalJsLike | number | string | null
    isTrending?: boolean
    isTopPick?: boolean
    isUpcoming?: boolean
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    genres?: MovieGenreCreateNestedManyWithoutMovieInput
    languages?: MovieLanguageCreateNestedManyWithoutMovieInput
    showtimes?: ShowtimeCreateNestedManyWithoutMovieInput
  }

  export type MovieUncheckedCreateInput = {
    id?: string
    title: string
    slug: string
    status?: $Enums.MovieStatus
    durationMinutes?: number | null
    synopsis?: string | null
    tagline?: string | null
    posterUrl?: string | null
    backdropUrl?: string | null
    releaseYear?: number | null
    rating?: Decimal | DecimalJsLike | number | string | null
    isTrending?: boolean
    isTopPick?: boolean
    isUpcoming?: boolean
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    genres?: MovieGenreUncheckedCreateNestedManyWithoutMovieInput
    languages?: MovieLanguageUncheckedCreateNestedManyWithoutMovieInput
    showtimes?: ShowtimeUncheckedCreateNestedManyWithoutMovieInput
  }

  export type MovieUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    status?: EnumMovieStatusFieldUpdateOperationsInput | $Enums.MovieStatus
    durationMinutes?: NullableIntFieldUpdateOperationsInput | number | null
    synopsis?: NullableStringFieldUpdateOperationsInput | string | null
    tagline?: NullableStringFieldUpdateOperationsInput | string | null
    posterUrl?: NullableStringFieldUpdateOperationsInput | string | null
    backdropUrl?: NullableStringFieldUpdateOperationsInput | string | null
    releaseYear?: NullableIntFieldUpdateOperationsInput | number | null
    rating?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    isTrending?: BoolFieldUpdateOperationsInput | boolean
    isTopPick?: BoolFieldUpdateOperationsInput | boolean
    isUpcoming?: BoolFieldUpdateOperationsInput | boolean
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    genres?: MovieGenreUpdateManyWithoutMovieNestedInput
    languages?: MovieLanguageUpdateManyWithoutMovieNestedInput
    showtimes?: ShowtimeUpdateManyWithoutMovieNestedInput
  }

  export type MovieUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    status?: EnumMovieStatusFieldUpdateOperationsInput | $Enums.MovieStatus
    durationMinutes?: NullableIntFieldUpdateOperationsInput | number | null
    synopsis?: NullableStringFieldUpdateOperationsInput | string | null
    tagline?: NullableStringFieldUpdateOperationsInput | string | null
    posterUrl?: NullableStringFieldUpdateOperationsInput | string | null
    backdropUrl?: NullableStringFieldUpdateOperationsInput | string | null
    releaseYear?: NullableIntFieldUpdateOperationsInput | number | null
    rating?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    isTrending?: BoolFieldUpdateOperationsInput | boolean
    isTopPick?: BoolFieldUpdateOperationsInput | boolean
    isUpcoming?: BoolFieldUpdateOperationsInput | boolean
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    genres?: MovieGenreUncheckedUpdateManyWithoutMovieNestedInput
    languages?: MovieLanguageUncheckedUpdateManyWithoutMovieNestedInput
    showtimes?: ShowtimeUncheckedUpdateManyWithoutMovieNestedInput
  }

  export type MovieCreateManyInput = {
    id?: string
    title: string
    slug: string
    status?: $Enums.MovieStatus
    durationMinutes?: number | null
    synopsis?: string | null
    tagline?: string | null
    posterUrl?: string | null
    backdropUrl?: string | null
    releaseYear?: number | null
    rating?: Decimal | DecimalJsLike | number | string | null
    isTrending?: boolean
    isTopPick?: boolean
    isUpcoming?: boolean
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MovieUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    status?: EnumMovieStatusFieldUpdateOperationsInput | $Enums.MovieStatus
    durationMinutes?: NullableIntFieldUpdateOperationsInput | number | null
    synopsis?: NullableStringFieldUpdateOperationsInput | string | null
    tagline?: NullableStringFieldUpdateOperationsInput | string | null
    posterUrl?: NullableStringFieldUpdateOperationsInput | string | null
    backdropUrl?: NullableStringFieldUpdateOperationsInput | string | null
    releaseYear?: NullableIntFieldUpdateOperationsInput | number | null
    rating?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    isTrending?: BoolFieldUpdateOperationsInput | boolean
    isTopPick?: BoolFieldUpdateOperationsInput | boolean
    isUpcoming?: BoolFieldUpdateOperationsInput | boolean
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MovieUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    status?: EnumMovieStatusFieldUpdateOperationsInput | $Enums.MovieStatus
    durationMinutes?: NullableIntFieldUpdateOperationsInput | number | null
    synopsis?: NullableStringFieldUpdateOperationsInput | string | null
    tagline?: NullableStringFieldUpdateOperationsInput | string | null
    posterUrl?: NullableStringFieldUpdateOperationsInput | string | null
    backdropUrl?: NullableStringFieldUpdateOperationsInput | string | null
    releaseYear?: NullableIntFieldUpdateOperationsInput | number | null
    rating?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    isTrending?: BoolFieldUpdateOperationsInput | boolean
    isTopPick?: BoolFieldUpdateOperationsInput | boolean
    isUpcoming?: BoolFieldUpdateOperationsInput | boolean
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MovieGenreCreateInput = {
    name: string
    movie: MovieCreateNestedOneWithoutGenresInput
  }

  export type MovieGenreUncheckedCreateInput = {
    id?: number
    movieId: string
    name: string
  }

  export type MovieGenreUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    movie?: MovieUpdateOneRequiredWithoutGenresNestedInput
  }

  export type MovieGenreUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    movieId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
  }

  export type MovieGenreCreateManyInput = {
    id?: number
    movieId: string
    name: string
  }

  export type MovieGenreUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
  }

  export type MovieGenreUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    movieId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
  }

  export type MovieLanguageCreateInput = {
    name: string
    movie: MovieCreateNestedOneWithoutLanguagesInput
  }

  export type MovieLanguageUncheckedCreateInput = {
    id?: number
    movieId: string
    name: string
  }

  export type MovieLanguageUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    movie?: MovieUpdateOneRequiredWithoutLanguagesNestedInput
  }

  export type MovieLanguageUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    movieId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
  }

  export type MovieLanguageCreateManyInput = {
    id?: number
    movieId: string
    name: string
  }

  export type MovieLanguageUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
  }

  export type MovieLanguageUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    movieId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
  }

  export type AuditoriumCreateInput = {
    id?: string
    cinemaId: string
    cinemaName: string
    name: string
    capacity: number
    layoutVersion?: number
    layoutJson: JsonNullValueInput | InputJsonValue
    layoutUpdatedAt?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    showtimes?: ShowtimeCreateNestedManyWithoutAuditoriumInput
  }

  export type AuditoriumUncheckedCreateInput = {
    id?: string
    cinemaId: string
    cinemaName: string
    name: string
    capacity: number
    layoutVersion?: number
    layoutJson: JsonNullValueInput | InputJsonValue
    layoutUpdatedAt?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    showtimes?: ShowtimeUncheckedCreateNestedManyWithoutAuditoriumInput
  }

  export type AuditoriumUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    cinemaId?: StringFieldUpdateOperationsInput | string
    cinemaName?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    capacity?: IntFieldUpdateOperationsInput | number
    layoutVersion?: IntFieldUpdateOperationsInput | number
    layoutJson?: JsonNullValueInput | InputJsonValue
    layoutUpdatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    showtimes?: ShowtimeUpdateManyWithoutAuditoriumNestedInput
  }

  export type AuditoriumUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    cinemaId?: StringFieldUpdateOperationsInput | string
    cinemaName?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    capacity?: IntFieldUpdateOperationsInput | number
    layoutVersion?: IntFieldUpdateOperationsInput | number
    layoutJson?: JsonNullValueInput | InputJsonValue
    layoutUpdatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    showtimes?: ShowtimeUncheckedUpdateManyWithoutAuditoriumNestedInput
  }

  export type AuditoriumCreateManyInput = {
    id?: string
    cinemaId: string
    cinemaName: string
    name: string
    capacity: number
    layoutVersion?: number
    layoutJson: JsonNullValueInput | InputJsonValue
    layoutUpdatedAt?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AuditoriumUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    cinemaId?: StringFieldUpdateOperationsInput | string
    cinemaName?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    capacity?: IntFieldUpdateOperationsInput | number
    layoutVersion?: IntFieldUpdateOperationsInput | number
    layoutJson?: JsonNullValueInput | InputJsonValue
    layoutUpdatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuditoriumUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    cinemaId?: StringFieldUpdateOperationsInput | string
    cinemaName?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    capacity?: IntFieldUpdateOperationsInput | number
    layoutVersion?: IntFieldUpdateOperationsInput | number
    layoutJson?: JsonNullValueInput | InputJsonValue
    layoutUpdatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ShowtimeCreateInput = {
    id?: string
    startsAt: Date | string
    endsAt: Date | string
    basePrice: Decimal | DecimalJsLike | number | string
    status?: $Enums.ShowtimeStatus
    seatLayoutVersion?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    movie: MovieCreateNestedOneWithoutShowtimesInput
    auditorium: AuditoriumCreateNestedOneWithoutShowtimesInput
    pricingTiers?: ShowtimePricingTierCreateNestedManyWithoutShowtimeInput
    bookings?: BookingCreateNestedManyWithoutShowtimeInput
  }

  export type ShowtimeUncheckedCreateInput = {
    id?: string
    movieId: string
    auditoriumId: string
    startsAt: Date | string
    endsAt: Date | string
    basePrice: Decimal | DecimalJsLike | number | string
    status?: $Enums.ShowtimeStatus
    seatLayoutVersion?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    pricingTiers?: ShowtimePricingTierUncheckedCreateNestedManyWithoutShowtimeInput
    bookings?: BookingUncheckedCreateNestedManyWithoutShowtimeInput
  }

  export type ShowtimeUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    startsAt?: DateTimeFieldUpdateOperationsInput | Date | string
    endsAt?: DateTimeFieldUpdateOperationsInput | Date | string
    basePrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: EnumShowtimeStatusFieldUpdateOperationsInput | $Enums.ShowtimeStatus
    seatLayoutVersion?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    movie?: MovieUpdateOneRequiredWithoutShowtimesNestedInput
    auditorium?: AuditoriumUpdateOneRequiredWithoutShowtimesNestedInput
    pricingTiers?: ShowtimePricingTierUpdateManyWithoutShowtimeNestedInput
    bookings?: BookingUpdateManyWithoutShowtimeNestedInput
  }

  export type ShowtimeUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    movieId?: StringFieldUpdateOperationsInput | string
    auditoriumId?: StringFieldUpdateOperationsInput | string
    startsAt?: DateTimeFieldUpdateOperationsInput | Date | string
    endsAt?: DateTimeFieldUpdateOperationsInput | Date | string
    basePrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: EnumShowtimeStatusFieldUpdateOperationsInput | $Enums.ShowtimeStatus
    seatLayoutVersion?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    pricingTiers?: ShowtimePricingTierUncheckedUpdateManyWithoutShowtimeNestedInput
    bookings?: BookingUncheckedUpdateManyWithoutShowtimeNestedInput
  }

  export type ShowtimeCreateManyInput = {
    id?: string
    movieId: string
    auditoriumId: string
    startsAt: Date | string
    endsAt: Date | string
    basePrice: Decimal | DecimalJsLike | number | string
    status?: $Enums.ShowtimeStatus
    seatLayoutVersion?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ShowtimeUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    startsAt?: DateTimeFieldUpdateOperationsInput | Date | string
    endsAt?: DateTimeFieldUpdateOperationsInput | Date | string
    basePrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: EnumShowtimeStatusFieldUpdateOperationsInput | $Enums.ShowtimeStatus
    seatLayoutVersion?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ShowtimeUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    movieId?: StringFieldUpdateOperationsInput | string
    auditoriumId?: StringFieldUpdateOperationsInput | string
    startsAt?: DateTimeFieldUpdateOperationsInput | Date | string
    endsAt?: DateTimeFieldUpdateOperationsInput | Date | string
    basePrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: EnumShowtimeStatusFieldUpdateOperationsInput | $Enums.ShowtimeStatus
    seatLayoutVersion?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ShowtimePricingTierCreateInput = {
    id?: string
    label: string
    price: Decimal | DecimalJsLike | number | string
    seatTypes: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    showtime: ShowtimeCreateNestedOneWithoutPricingTiersInput
  }

  export type ShowtimePricingTierUncheckedCreateInput = {
    id?: string
    showtimeId: string
    label: string
    price: Decimal | DecimalJsLike | number | string
    seatTypes: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type ShowtimePricingTierUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    label?: StringFieldUpdateOperationsInput | string
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    seatTypes?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    showtime?: ShowtimeUpdateOneRequiredWithoutPricingTiersNestedInput
  }

  export type ShowtimePricingTierUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    showtimeId?: StringFieldUpdateOperationsInput | string
    label?: StringFieldUpdateOperationsInput | string
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    seatTypes?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ShowtimePricingTierCreateManyInput = {
    id?: string
    showtimeId: string
    label: string
    price: Decimal | DecimalJsLike | number | string
    seatTypes: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type ShowtimePricingTierUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    label?: StringFieldUpdateOperationsInput | string
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    seatTypes?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ShowtimePricingTierUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    showtimeId?: StringFieldUpdateOperationsInput | string
    label?: StringFieldUpdateOperationsInput | string
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    seatTypes?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BookingCreateInput = {
    id?: string
    reference: string
    purchaserEmail: string
    purchaserName: string
    status?: $Enums.BookingStatus
    totalAmount: Decimal | DecimalJsLike | number | string
    currency?: string
    purchasedAt?: Date | string
    movieTitle: string
    user?: UserCreateNestedOneWithoutBookingsInput
    showtime: ShowtimeCreateNestedOneWithoutBookingsInput
    tickets?: BookingTicketCreateNestedManyWithoutBookingInput
    auditLog?: BookingAuditCreateNestedManyWithoutBookingInput
    settlements?: SettlementTransactionCreateNestedManyWithoutBookingInput
  }

  export type BookingUncheckedCreateInput = {
    id?: string
    reference: string
    showtimeId: string
    userId?: string | null
    purchaserEmail: string
    purchaserName: string
    status?: $Enums.BookingStatus
    totalAmount: Decimal | DecimalJsLike | number | string
    currency?: string
    purchasedAt?: Date | string
    movieTitle: string
    tickets?: BookingTicketUncheckedCreateNestedManyWithoutBookingInput
    auditLog?: BookingAuditUncheckedCreateNestedManyWithoutBookingInput
    settlements?: SettlementTransactionUncheckedCreateNestedManyWithoutBookingInput
  }

  export type BookingUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    reference?: StringFieldUpdateOperationsInput | string
    purchaserEmail?: StringFieldUpdateOperationsInput | string
    purchaserName?: StringFieldUpdateOperationsInput | string
    status?: EnumBookingStatusFieldUpdateOperationsInput | $Enums.BookingStatus
    totalAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    purchasedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    movieTitle?: StringFieldUpdateOperationsInput | string
    user?: UserUpdateOneWithoutBookingsNestedInput
    showtime?: ShowtimeUpdateOneRequiredWithoutBookingsNestedInput
    tickets?: BookingTicketUpdateManyWithoutBookingNestedInput
    auditLog?: BookingAuditUpdateManyWithoutBookingNestedInput
    settlements?: SettlementTransactionUpdateManyWithoutBookingNestedInput
  }

  export type BookingUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    reference?: StringFieldUpdateOperationsInput | string
    showtimeId?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    purchaserEmail?: StringFieldUpdateOperationsInput | string
    purchaserName?: StringFieldUpdateOperationsInput | string
    status?: EnumBookingStatusFieldUpdateOperationsInput | $Enums.BookingStatus
    totalAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    purchasedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    movieTitle?: StringFieldUpdateOperationsInput | string
    tickets?: BookingTicketUncheckedUpdateManyWithoutBookingNestedInput
    auditLog?: BookingAuditUncheckedUpdateManyWithoutBookingNestedInput
    settlements?: SettlementTransactionUncheckedUpdateManyWithoutBookingNestedInput
  }

  export type BookingCreateManyInput = {
    id?: string
    reference: string
    showtimeId: string
    userId?: string | null
    purchaserEmail: string
    purchaserName: string
    status?: $Enums.BookingStatus
    totalAmount: Decimal | DecimalJsLike | number | string
    currency?: string
    purchasedAt?: Date | string
    movieTitle: string
  }

  export type BookingUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    reference?: StringFieldUpdateOperationsInput | string
    purchaserEmail?: StringFieldUpdateOperationsInput | string
    purchaserName?: StringFieldUpdateOperationsInput | string
    status?: EnumBookingStatusFieldUpdateOperationsInput | $Enums.BookingStatus
    totalAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    purchasedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    movieTitle?: StringFieldUpdateOperationsInput | string
  }

  export type BookingUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    reference?: StringFieldUpdateOperationsInput | string
    showtimeId?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    purchaserEmail?: StringFieldUpdateOperationsInput | string
    purchaserName?: StringFieldUpdateOperationsInput | string
    status?: EnumBookingStatusFieldUpdateOperationsInput | $Enums.BookingStatus
    totalAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    purchasedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    movieTitle?: StringFieldUpdateOperationsInput | string
  }

  export type BookingTicketCreateInput = {
    id?: string
    seatId: string
    seatLabel: string
    price: Decimal | DecimalJsLike | number | string
    tierLabel?: string | null
    tierId?: string | null
    booking: BookingCreateNestedOneWithoutTicketsInput
  }

  export type BookingTicketUncheckedCreateInput = {
    id?: string
    bookingId: string
    seatId: string
    seatLabel: string
    price: Decimal | DecimalJsLike | number | string
    tierLabel?: string | null
    tierId?: string | null
  }

  export type BookingTicketUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    seatId?: StringFieldUpdateOperationsInput | string
    seatLabel?: StringFieldUpdateOperationsInput | string
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    tierLabel?: NullableStringFieldUpdateOperationsInput | string | null
    tierId?: NullableStringFieldUpdateOperationsInput | string | null
    booking?: BookingUpdateOneRequiredWithoutTicketsNestedInput
  }

  export type BookingTicketUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    bookingId?: StringFieldUpdateOperationsInput | string
    seatId?: StringFieldUpdateOperationsInput | string
    seatLabel?: StringFieldUpdateOperationsInput | string
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    tierLabel?: NullableStringFieldUpdateOperationsInput | string | null
    tierId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type BookingTicketCreateManyInput = {
    id?: string
    bookingId: string
    seatId: string
    seatLabel: string
    price: Decimal | DecimalJsLike | number | string
    tierLabel?: string | null
    tierId?: string | null
  }

  export type BookingTicketUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    seatId?: StringFieldUpdateOperationsInput | string
    seatLabel?: StringFieldUpdateOperationsInput | string
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    tierLabel?: NullableStringFieldUpdateOperationsInput | string | null
    tierId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type BookingTicketUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    bookingId?: StringFieldUpdateOperationsInput | string
    seatId?: StringFieldUpdateOperationsInput | string
    seatLabel?: StringFieldUpdateOperationsInput | string
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    tierLabel?: NullableStringFieldUpdateOperationsInput | string | null
    tierId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type BookingAuditCreateInput = {
    id?: string
    type: string
    message: string
    actor: string
    createdAt?: Date | string
    booking: BookingCreateNestedOneWithoutAuditLogInput
  }

  export type BookingAuditUncheckedCreateInput = {
    id?: string
    bookingId: string
    type: string
    message: string
    actor: string
    createdAt?: Date | string
  }

  export type BookingAuditUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    actor?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    booking?: BookingUpdateOneRequiredWithoutAuditLogNestedInput
  }

  export type BookingAuditUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    bookingId?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    actor?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BookingAuditCreateManyInput = {
    id?: string
    bookingId: string
    type: string
    message: string
    actor: string
    createdAt?: Date | string
  }

  export type BookingAuditUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    actor?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BookingAuditUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    bookingId?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    actor?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SettlementTransactionCreateInput = {
    id?: string
    gateway: string
    transactionId: string
    amount: Decimal | DecimalJsLike | number | string
    currency?: string
    status?: $Enums.SettlementStatus
    fees: Decimal | DecimalJsLike | number | string
    netPayout: Decimal | DecimalJsLike | number | string
    settledAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    booking?: BookingCreateNestedOneWithoutSettlementsInput
  }

  export type SettlementTransactionUncheckedCreateInput = {
    id?: string
    gateway: string
    transactionId: string
    amount: Decimal | DecimalJsLike | number | string
    currency?: string
    status?: $Enums.SettlementStatus
    fees: Decimal | DecimalJsLike | number | string
    netPayout: Decimal | DecimalJsLike | number | string
    settledAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    bookingId?: string | null
  }

  export type SettlementTransactionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    gateway?: StringFieldUpdateOperationsInput | string
    transactionId?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    status?: EnumSettlementStatusFieldUpdateOperationsInput | $Enums.SettlementStatus
    fees?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    netPayout?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    settledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    booking?: BookingUpdateOneWithoutSettlementsNestedInput
  }

  export type SettlementTransactionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    gateway?: StringFieldUpdateOperationsInput | string
    transactionId?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    status?: EnumSettlementStatusFieldUpdateOperationsInput | $Enums.SettlementStatus
    fees?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    netPayout?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    settledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    bookingId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type SettlementTransactionCreateManyInput = {
    id?: string
    gateway: string
    transactionId: string
    amount: Decimal | DecimalJsLike | number | string
    currency?: string
    status?: $Enums.SettlementStatus
    fees: Decimal | DecimalJsLike | number | string
    netPayout: Decimal | DecimalJsLike | number | string
    settledAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    bookingId?: string | null
  }

  export type SettlementTransactionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    gateway?: StringFieldUpdateOperationsInput | string
    transactionId?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    status?: EnumSettlementStatusFieldUpdateOperationsInput | $Enums.SettlementStatus
    fees?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    netPayout?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    settledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SettlementTransactionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    gateway?: StringFieldUpdateOperationsInput | string
    transactionId?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    status?: EnumSettlementStatusFieldUpdateOperationsInput | $Enums.SettlementStatus
    fees?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    netPayout?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    settledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    bookingId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type NotificationSegmentCreateInput = {
    id?: string
    name: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    campaigns?: NotificationCampaignCreateNestedManyWithoutSegmentInput
  }

  export type NotificationSegmentUncheckedCreateInput = {
    id?: string
    name: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    campaigns?: NotificationCampaignUncheckedCreateNestedManyWithoutSegmentInput
  }

  export type NotificationSegmentUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    campaigns?: NotificationCampaignUpdateManyWithoutSegmentNestedInput
  }

  export type NotificationSegmentUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    campaigns?: NotificationCampaignUncheckedUpdateManyWithoutSegmentNestedInput
  }

  export type NotificationSegmentCreateManyInput = {
    id?: string
    name: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type NotificationSegmentUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationSegmentUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationCampaignCreateInput = {
    id?: string
    name: string
    subject: string
    channels: JsonNullValueInput | InputJsonValue
    status?: $Enums.CampaignStatus
    scheduledAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    statsSent?: number
    statsOpened?: number
    statsClicked?: number
    segment: NotificationSegmentCreateNestedOneWithoutCampaignsInput
  }

  export type NotificationCampaignUncheckedCreateInput = {
    id?: string
    name: string
    subject: string
    channels: JsonNullValueInput | InputJsonValue
    status?: $Enums.CampaignStatus
    scheduledAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    segmentId: string
    statsSent?: number
    statsOpened?: number
    statsClicked?: number
  }

  export type NotificationCampaignUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    subject?: StringFieldUpdateOperationsInput | string
    channels?: JsonNullValueInput | InputJsonValue
    status?: EnumCampaignStatusFieldUpdateOperationsInput | $Enums.CampaignStatus
    scheduledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    statsSent?: IntFieldUpdateOperationsInput | number
    statsOpened?: IntFieldUpdateOperationsInput | number
    statsClicked?: IntFieldUpdateOperationsInput | number
    segment?: NotificationSegmentUpdateOneRequiredWithoutCampaignsNestedInput
  }

  export type NotificationCampaignUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    subject?: StringFieldUpdateOperationsInput | string
    channels?: JsonNullValueInput | InputJsonValue
    status?: EnumCampaignStatusFieldUpdateOperationsInput | $Enums.CampaignStatus
    scheduledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    segmentId?: StringFieldUpdateOperationsInput | string
    statsSent?: IntFieldUpdateOperationsInput | number
    statsOpened?: IntFieldUpdateOperationsInput | number
    statsClicked?: IntFieldUpdateOperationsInput | number
  }

  export type NotificationCampaignCreateManyInput = {
    id?: string
    name: string
    subject: string
    channels: JsonNullValueInput | InputJsonValue
    status?: $Enums.CampaignStatus
    scheduledAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    segmentId: string
    statsSent?: number
    statsOpened?: number
    statsClicked?: number
  }

  export type NotificationCampaignUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    subject?: StringFieldUpdateOperationsInput | string
    channels?: JsonNullValueInput | InputJsonValue
    status?: EnumCampaignStatusFieldUpdateOperationsInput | $Enums.CampaignStatus
    scheduledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    statsSent?: IntFieldUpdateOperationsInput | number
    statsOpened?: IntFieldUpdateOperationsInput | number
    statsClicked?: IntFieldUpdateOperationsInput | number
  }

  export type NotificationCampaignUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    subject?: StringFieldUpdateOperationsInput | string
    channels?: JsonNullValueInput | InputJsonValue
    status?: EnumCampaignStatusFieldUpdateOperationsInput | $Enums.CampaignStatus
    scheduledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    segmentId?: StringFieldUpdateOperationsInput | string
    statsSent?: IntFieldUpdateOperationsInput | number
    statsOpened?: IntFieldUpdateOperationsInput | number
    statsClicked?: IntFieldUpdateOperationsInput | number
  }

  export type PlatformSettingsCreateInput = {
    id?: number
    razorpayKey?: string
    stripeKey?: string
    settlementDays?: number
    cgst?: Decimal | DecimalJsLike | number | string
    sgst?: Decimal | DecimalJsLike | number | string
    convenienceFee?: Decimal | DecimalJsLike | number | string
    theatreName?: string
    supportEmail?: string
    contactNumber?: string
    address?: string | null
    termsUrl?: string
    privacyUrl?: string
    refundWindowHours?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PlatformSettingsUncheckedCreateInput = {
    id?: number
    razorpayKey?: string
    stripeKey?: string
    settlementDays?: number
    cgst?: Decimal | DecimalJsLike | number | string
    sgst?: Decimal | DecimalJsLike | number | string
    convenienceFee?: Decimal | DecimalJsLike | number | string
    theatreName?: string
    supportEmail?: string
    contactNumber?: string
    address?: string | null
    termsUrl?: string
    privacyUrl?: string
    refundWindowHours?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PlatformSettingsUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    razorpayKey?: StringFieldUpdateOperationsInput | string
    stripeKey?: StringFieldUpdateOperationsInput | string
    settlementDays?: IntFieldUpdateOperationsInput | number
    cgst?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    sgst?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    convenienceFee?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    theatreName?: StringFieldUpdateOperationsInput | string
    supportEmail?: StringFieldUpdateOperationsInput | string
    contactNumber?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    termsUrl?: StringFieldUpdateOperationsInput | string
    privacyUrl?: StringFieldUpdateOperationsInput | string
    refundWindowHours?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PlatformSettingsUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    razorpayKey?: StringFieldUpdateOperationsInput | string
    stripeKey?: StringFieldUpdateOperationsInput | string
    settlementDays?: IntFieldUpdateOperationsInput | number
    cgst?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    sgst?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    convenienceFee?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    theatreName?: StringFieldUpdateOperationsInput | string
    supportEmail?: StringFieldUpdateOperationsInput | string
    contactNumber?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    termsUrl?: StringFieldUpdateOperationsInput | string
    privacyUrl?: StringFieldUpdateOperationsInput | string
    refundWindowHours?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PlatformSettingsCreateManyInput = {
    id?: number
    razorpayKey?: string
    stripeKey?: string
    settlementDays?: number
    cgst?: Decimal | DecimalJsLike | number | string
    sgst?: Decimal | DecimalJsLike | number | string
    convenienceFee?: Decimal | DecimalJsLike | number | string
    theatreName?: string
    supportEmail?: string
    contactNumber?: string
    address?: string | null
    termsUrl?: string
    privacyUrl?: string
    refundWindowHours?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PlatformSettingsUpdateManyMutationInput = {
    id?: IntFieldUpdateOperationsInput | number
    razorpayKey?: StringFieldUpdateOperationsInput | string
    stripeKey?: StringFieldUpdateOperationsInput | string
    settlementDays?: IntFieldUpdateOperationsInput | number
    cgst?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    sgst?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    convenienceFee?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    theatreName?: StringFieldUpdateOperationsInput | string
    supportEmail?: StringFieldUpdateOperationsInput | string
    contactNumber?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    termsUrl?: StringFieldUpdateOperationsInput | string
    privacyUrl?: StringFieldUpdateOperationsInput | string
    refundWindowHours?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PlatformSettingsUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    razorpayKey?: StringFieldUpdateOperationsInput | string
    stripeKey?: StringFieldUpdateOperationsInput | string
    settlementDays?: IntFieldUpdateOperationsInput | number
    cgst?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    sgst?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    convenienceFee?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    theatreName?: StringFieldUpdateOperationsInput | string
    supportEmail?: StringFieldUpdateOperationsInput | string
    contactNumber?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    termsUrl?: StringFieldUpdateOperationsInput | string
    privacyUrl?: StringFieldUpdateOperationsInput | string
    refundWindowHours?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PaymentAuditCreateInput = {
    id?: string
    transactionId: string
    status: string
    method: string
    amount: Decimal | DecimalJsLike | number | string
    movieTitle: string
    showtime?: string | null
    seats?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type PaymentAuditUncheckedCreateInput = {
    id?: string
    transactionId: string
    status: string
    method: string
    amount: Decimal | DecimalJsLike | number | string
    movieTitle: string
    showtime?: string | null
    seats?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type PaymentAuditUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    transactionId?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    method?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    movieTitle?: StringFieldUpdateOperationsInput | string
    showtime?: NullableStringFieldUpdateOperationsInput | string | null
    seats?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PaymentAuditUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    transactionId?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    method?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    movieTitle?: StringFieldUpdateOperationsInput | string
    showtime?: NullableStringFieldUpdateOperationsInput | string | null
    seats?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PaymentAuditCreateManyInput = {
    id?: string
    transactionId: string
    status: string
    method: string
    amount: Decimal | DecimalJsLike | number | string
    movieTitle: string
    showtime?: string | null
    seats?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type PaymentAuditUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    transactionId?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    method?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    movieTitle?: StringFieldUpdateOperationsInput | string
    showtime?: NullableStringFieldUpdateOperationsInput | string | null
    seats?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PaymentAuditUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    transactionId?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    method?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    movieTitle?: StringFieldUpdateOperationsInput | string
    showtime?: NullableStringFieldUpdateOperationsInput | string | null
    seats?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type AdminUserNullableRelationFilter = {
    is?: AdminUserWhereInput | null
    isNot?: AdminUserWhereInput | null
  }

  export type SessionListRelationFilter = {
    every?: SessionWhereInput
    some?: SessionWhereInput
    none?: SessionWhereInput
  }

  export type BookingListRelationFilter = {
    every?: BookingWhereInput
    some?: BookingWhereInput
    none?: BookingWhereInput
  }

  export type PasswordResetTokenListRelationFilter = {
    every?: PasswordResetTokenWhereInput
    some?: PasswordResetTokenWhereInput
    none?: PasswordResetTokenWhereInput
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type SessionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type BookingOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PasswordResetTokenOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserCountOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    passwordHash?: SortOrder
    displayName?: SortOrder
    avatarUrl?: SortOrder
    phoneNumber?: SortOrder
    isAdmin?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserMaxOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    passwordHash?: SortOrder
    displayName?: SortOrder
    avatarUrl?: SortOrder
    phoneNumber?: SortOrder
    isAdmin?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserMinOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    passwordHash?: SortOrder
    displayName?: SortOrder
    avatarUrl?: SortOrder
    phoneNumber?: SortOrder
    isAdmin?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type EnumAdminStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.AdminStatus | EnumAdminStatusFieldRefInput<$PrismaModel>
    in?: $Enums.AdminStatus[]
    notIn?: $Enums.AdminStatus[]
    not?: NestedEnumAdminStatusFilter<$PrismaModel> | $Enums.AdminStatus
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type UserRelationFilter = {
    is?: UserWhereInput
    isNot?: UserWhereInput
  }

  export type AdminUserRoleListRelationFilter = {
    every?: AdminUserRoleWhereInput
    some?: AdminUserRoleWhereInput
    none?: AdminUserRoleWhereInput
  }

  export type AdminUserRoleOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AdminUserCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    status?: SortOrder
    lastActiveAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AdminUserMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    status?: SortOrder
    lastActiveAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AdminUserMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    status?: SortOrder
    lastActiveAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumAdminStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.AdminStatus | EnumAdminStatusFieldRefInput<$PrismaModel>
    in?: $Enums.AdminStatus[]
    notIn?: $Enums.AdminStatus[]
    not?: NestedEnumAdminStatusWithAggregatesFilter<$PrismaModel> | $Enums.AdminStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumAdminStatusFilter<$PrismaModel>
    _max?: NestedEnumAdminStatusFilter<$PrismaModel>
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type EnumAdminRoleFilter<$PrismaModel = never> = {
    equals?: $Enums.AdminRole | EnumAdminRoleFieldRefInput<$PrismaModel>
    in?: $Enums.AdminRole[]
    notIn?: $Enums.AdminRole[]
    not?: NestedEnumAdminRoleFilter<$PrismaModel> | $Enums.AdminRole
  }

  export type AdminUserRelationFilter = {
    is?: AdminUserWhereInput
    isNot?: AdminUserWhereInput
  }

  export type AdminUserRoleAdminUserIdRoleCompoundUniqueInput = {
    adminUserId: string
    role: $Enums.AdminRole
  }

  export type AdminUserRoleCountOrderByAggregateInput = {
    id?: SortOrder
    adminUserId?: SortOrder
    role?: SortOrder
  }

  export type AdminUserRoleAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type AdminUserRoleMaxOrderByAggregateInput = {
    id?: SortOrder
    adminUserId?: SortOrder
    role?: SortOrder
  }

  export type AdminUserRoleMinOrderByAggregateInput = {
    id?: SortOrder
    adminUserId?: SortOrder
    role?: SortOrder
  }

  export type AdminUserRoleSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type EnumAdminRoleWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.AdminRole | EnumAdminRoleFieldRefInput<$PrismaModel>
    in?: $Enums.AdminRole[]
    notIn?: $Enums.AdminRole[]
    not?: NestedEnumAdminRoleWithAggregatesFilter<$PrismaModel> | $Enums.AdminRole
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumAdminRoleFilter<$PrismaModel>
    _max?: NestedEnumAdminRoleFilter<$PrismaModel>
  }

  export type SessionCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    refreshToken?: SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrder
    revokedAt?: SortOrder
    ipAddress?: SortOrder
    userAgent?: SortOrder
  }

  export type SessionMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    refreshToken?: SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrder
    revokedAt?: SortOrder
    ipAddress?: SortOrder
    userAgent?: SortOrder
  }

  export type SessionMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    refreshToken?: SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrder
    revokedAt?: SortOrder
    ipAddress?: SortOrder
    userAgent?: SortOrder
  }

  export type PasswordResetTokenCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    otp?: SortOrder
    expiresAt?: SortOrder
    usedAt?: SortOrder
    createdAt?: SortOrder
  }

  export type PasswordResetTokenMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    otp?: SortOrder
    expiresAt?: SortOrder
    usedAt?: SortOrder
    createdAt?: SortOrder
  }

  export type PasswordResetTokenMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    otp?: SortOrder
    expiresAt?: SortOrder
    usedAt?: SortOrder
    createdAt?: SortOrder
  }

  export type EnumMovieStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.MovieStatus | EnumMovieStatusFieldRefInput<$PrismaModel>
    in?: $Enums.MovieStatus[]
    notIn?: $Enums.MovieStatus[]
    not?: NestedEnumMovieStatusFilter<$PrismaModel> | $Enums.MovieStatus
  }

  export type IntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type DecimalNullableFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
  }
  export type JsonNullableFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<JsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue
    lte?: InputJsonValue
    gt?: InputJsonValue
    gte?: InputJsonValue
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type MovieGenreListRelationFilter = {
    every?: MovieGenreWhereInput
    some?: MovieGenreWhereInput
    none?: MovieGenreWhereInput
  }

  export type MovieLanguageListRelationFilter = {
    every?: MovieLanguageWhereInput
    some?: MovieLanguageWhereInput
    none?: MovieLanguageWhereInput
  }

  export type ShowtimeListRelationFilter = {
    every?: ShowtimeWhereInput
    some?: ShowtimeWhereInput
    none?: ShowtimeWhereInput
  }

  export type MovieGenreOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type MovieLanguageOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ShowtimeOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type MovieCountOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    slug?: SortOrder
    status?: SortOrder
    durationMinutes?: SortOrder
    synopsis?: SortOrder
    tagline?: SortOrder
    posterUrl?: SortOrder
    backdropUrl?: SortOrder
    releaseYear?: SortOrder
    rating?: SortOrder
    isTrending?: SortOrder
    isTopPick?: SortOrder
    isUpcoming?: SortOrder
    metadata?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type MovieAvgOrderByAggregateInput = {
    durationMinutes?: SortOrder
    releaseYear?: SortOrder
    rating?: SortOrder
  }

  export type MovieMaxOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    slug?: SortOrder
    status?: SortOrder
    durationMinutes?: SortOrder
    synopsis?: SortOrder
    tagline?: SortOrder
    posterUrl?: SortOrder
    backdropUrl?: SortOrder
    releaseYear?: SortOrder
    rating?: SortOrder
    isTrending?: SortOrder
    isTopPick?: SortOrder
    isUpcoming?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type MovieMinOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    slug?: SortOrder
    status?: SortOrder
    durationMinutes?: SortOrder
    synopsis?: SortOrder
    tagline?: SortOrder
    posterUrl?: SortOrder
    backdropUrl?: SortOrder
    releaseYear?: SortOrder
    rating?: SortOrder
    isTrending?: SortOrder
    isTopPick?: SortOrder
    isUpcoming?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type MovieSumOrderByAggregateInput = {
    durationMinutes?: SortOrder
    releaseYear?: SortOrder
    rating?: SortOrder
  }

  export type EnumMovieStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.MovieStatus | EnumMovieStatusFieldRefInput<$PrismaModel>
    in?: $Enums.MovieStatus[]
    notIn?: $Enums.MovieStatus[]
    not?: NestedEnumMovieStatusWithAggregatesFilter<$PrismaModel> | $Enums.MovieStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumMovieStatusFilter<$PrismaModel>
    _max?: NestedEnumMovieStatusFilter<$PrismaModel>
  }

  export type IntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type DecimalNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedDecimalNullableFilter<$PrismaModel>
    _sum?: NestedDecimalNullableFilter<$PrismaModel>
    _min?: NestedDecimalNullableFilter<$PrismaModel>
    _max?: NestedDecimalNullableFilter<$PrismaModel>
  }
  export type JsonNullableWithAggregatesFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableWithAggregatesFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue
    lte?: InputJsonValue
    gt?: InputJsonValue
    gte?: InputJsonValue
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedJsonNullableFilter<$PrismaModel>
    _max?: NestedJsonNullableFilter<$PrismaModel>
  }

  export type MovieRelationFilter = {
    is?: MovieWhereInput
    isNot?: MovieWhereInput
  }

  export type MovieGenreCountOrderByAggregateInput = {
    id?: SortOrder
    movieId?: SortOrder
    name?: SortOrder
  }

  export type MovieGenreAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type MovieGenreMaxOrderByAggregateInput = {
    id?: SortOrder
    movieId?: SortOrder
    name?: SortOrder
  }

  export type MovieGenreMinOrderByAggregateInput = {
    id?: SortOrder
    movieId?: SortOrder
    name?: SortOrder
  }

  export type MovieGenreSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type MovieLanguageCountOrderByAggregateInput = {
    id?: SortOrder
    movieId?: SortOrder
    name?: SortOrder
  }

  export type MovieLanguageAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type MovieLanguageMaxOrderByAggregateInput = {
    id?: SortOrder
    movieId?: SortOrder
    name?: SortOrder
  }

  export type MovieLanguageMinOrderByAggregateInput = {
    id?: SortOrder
    movieId?: SortOrder
    name?: SortOrder
  }

  export type MovieLanguageSumOrderByAggregateInput = {
    id?: SortOrder
  }
  export type JsonFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<JsonFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonFilterBase<$PrismaModel>>, 'path'>>

  export type JsonFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue
    lte?: InputJsonValue
    gt?: InputJsonValue
    gte?: InputJsonValue
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type AuditoriumCountOrderByAggregateInput = {
    id?: SortOrder
    cinemaId?: SortOrder
    cinemaName?: SortOrder
    name?: SortOrder
    capacity?: SortOrder
    layoutVersion?: SortOrder
    layoutJson?: SortOrder
    layoutUpdatedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AuditoriumAvgOrderByAggregateInput = {
    capacity?: SortOrder
    layoutVersion?: SortOrder
  }

  export type AuditoriumMaxOrderByAggregateInput = {
    id?: SortOrder
    cinemaId?: SortOrder
    cinemaName?: SortOrder
    name?: SortOrder
    capacity?: SortOrder
    layoutVersion?: SortOrder
    layoutUpdatedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AuditoriumMinOrderByAggregateInput = {
    id?: SortOrder
    cinemaId?: SortOrder
    cinemaName?: SortOrder
    name?: SortOrder
    capacity?: SortOrder
    layoutVersion?: SortOrder
    layoutUpdatedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AuditoriumSumOrderByAggregateInput = {
    capacity?: SortOrder
    layoutVersion?: SortOrder
  }
  export type JsonWithAggregatesFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<JsonWithAggregatesFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonWithAggregatesFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonWithAggregatesFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonWithAggregatesFilterBase<$PrismaModel>>, 'path'>>

  export type JsonWithAggregatesFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue
    lte?: InputJsonValue
    gt?: InputJsonValue
    gte?: InputJsonValue
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedJsonFilter<$PrismaModel>
    _max?: NestedJsonFilter<$PrismaModel>
  }

  export type DecimalFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[]
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[]
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
  }

  export type EnumShowtimeStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.ShowtimeStatus | EnumShowtimeStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ShowtimeStatus[]
    notIn?: $Enums.ShowtimeStatus[]
    not?: NestedEnumShowtimeStatusFilter<$PrismaModel> | $Enums.ShowtimeStatus
  }

  export type AuditoriumRelationFilter = {
    is?: AuditoriumWhereInput
    isNot?: AuditoriumWhereInput
  }

  export type ShowtimePricingTierListRelationFilter = {
    every?: ShowtimePricingTierWhereInput
    some?: ShowtimePricingTierWhereInput
    none?: ShowtimePricingTierWhereInput
  }

  export type ShowtimePricingTierOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ShowtimeCountOrderByAggregateInput = {
    id?: SortOrder
    movieId?: SortOrder
    auditoriumId?: SortOrder
    startsAt?: SortOrder
    endsAt?: SortOrder
    basePrice?: SortOrder
    status?: SortOrder
    seatLayoutVersion?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ShowtimeAvgOrderByAggregateInput = {
    basePrice?: SortOrder
    seatLayoutVersion?: SortOrder
  }

  export type ShowtimeMaxOrderByAggregateInput = {
    id?: SortOrder
    movieId?: SortOrder
    auditoriumId?: SortOrder
    startsAt?: SortOrder
    endsAt?: SortOrder
    basePrice?: SortOrder
    status?: SortOrder
    seatLayoutVersion?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ShowtimeMinOrderByAggregateInput = {
    id?: SortOrder
    movieId?: SortOrder
    auditoriumId?: SortOrder
    startsAt?: SortOrder
    endsAt?: SortOrder
    basePrice?: SortOrder
    status?: SortOrder
    seatLayoutVersion?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ShowtimeSumOrderByAggregateInput = {
    basePrice?: SortOrder
    seatLayoutVersion?: SortOrder
  }

  export type DecimalWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[]
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[]
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedDecimalFilter<$PrismaModel>
    _sum?: NestedDecimalFilter<$PrismaModel>
    _min?: NestedDecimalFilter<$PrismaModel>
    _max?: NestedDecimalFilter<$PrismaModel>
  }

  export type EnumShowtimeStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ShowtimeStatus | EnumShowtimeStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ShowtimeStatus[]
    notIn?: $Enums.ShowtimeStatus[]
    not?: NestedEnumShowtimeStatusWithAggregatesFilter<$PrismaModel> | $Enums.ShowtimeStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumShowtimeStatusFilter<$PrismaModel>
    _max?: NestedEnumShowtimeStatusFilter<$PrismaModel>
  }

  export type ShowtimeRelationFilter = {
    is?: ShowtimeWhereInput
    isNot?: ShowtimeWhereInput
  }

  export type ShowtimePricingTierCountOrderByAggregateInput = {
    id?: SortOrder
    showtimeId?: SortOrder
    label?: SortOrder
    price?: SortOrder
    seatTypes?: SortOrder
    createdAt?: SortOrder
  }

  export type ShowtimePricingTierAvgOrderByAggregateInput = {
    price?: SortOrder
  }

  export type ShowtimePricingTierMaxOrderByAggregateInput = {
    id?: SortOrder
    showtimeId?: SortOrder
    label?: SortOrder
    price?: SortOrder
    createdAt?: SortOrder
  }

  export type ShowtimePricingTierMinOrderByAggregateInput = {
    id?: SortOrder
    showtimeId?: SortOrder
    label?: SortOrder
    price?: SortOrder
    createdAt?: SortOrder
  }

  export type ShowtimePricingTierSumOrderByAggregateInput = {
    price?: SortOrder
  }

  export type EnumBookingStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.BookingStatus | EnumBookingStatusFieldRefInput<$PrismaModel>
    in?: $Enums.BookingStatus[]
    notIn?: $Enums.BookingStatus[]
    not?: NestedEnumBookingStatusFilter<$PrismaModel> | $Enums.BookingStatus
  }

  export type UserNullableRelationFilter = {
    is?: UserWhereInput | null
    isNot?: UserWhereInput | null
  }

  export type BookingTicketListRelationFilter = {
    every?: BookingTicketWhereInput
    some?: BookingTicketWhereInput
    none?: BookingTicketWhereInput
  }

  export type BookingAuditListRelationFilter = {
    every?: BookingAuditWhereInput
    some?: BookingAuditWhereInput
    none?: BookingAuditWhereInput
  }

  export type SettlementTransactionListRelationFilter = {
    every?: SettlementTransactionWhereInput
    some?: SettlementTransactionWhereInput
    none?: SettlementTransactionWhereInput
  }

  export type BookingTicketOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type BookingAuditOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SettlementTransactionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type BookingCountOrderByAggregateInput = {
    id?: SortOrder
    reference?: SortOrder
    showtimeId?: SortOrder
    userId?: SortOrder
    purchaserEmail?: SortOrder
    purchaserName?: SortOrder
    status?: SortOrder
    totalAmount?: SortOrder
    currency?: SortOrder
    purchasedAt?: SortOrder
    movieTitle?: SortOrder
  }

  export type BookingAvgOrderByAggregateInput = {
    totalAmount?: SortOrder
  }

  export type BookingMaxOrderByAggregateInput = {
    id?: SortOrder
    reference?: SortOrder
    showtimeId?: SortOrder
    userId?: SortOrder
    purchaserEmail?: SortOrder
    purchaserName?: SortOrder
    status?: SortOrder
    totalAmount?: SortOrder
    currency?: SortOrder
    purchasedAt?: SortOrder
    movieTitle?: SortOrder
  }

  export type BookingMinOrderByAggregateInput = {
    id?: SortOrder
    reference?: SortOrder
    showtimeId?: SortOrder
    userId?: SortOrder
    purchaserEmail?: SortOrder
    purchaserName?: SortOrder
    status?: SortOrder
    totalAmount?: SortOrder
    currency?: SortOrder
    purchasedAt?: SortOrder
    movieTitle?: SortOrder
  }

  export type BookingSumOrderByAggregateInput = {
    totalAmount?: SortOrder
  }

  export type EnumBookingStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.BookingStatus | EnumBookingStatusFieldRefInput<$PrismaModel>
    in?: $Enums.BookingStatus[]
    notIn?: $Enums.BookingStatus[]
    not?: NestedEnumBookingStatusWithAggregatesFilter<$PrismaModel> | $Enums.BookingStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumBookingStatusFilter<$PrismaModel>
    _max?: NestedEnumBookingStatusFilter<$PrismaModel>
  }

  export type BookingRelationFilter = {
    is?: BookingWhereInput
    isNot?: BookingWhereInput
  }

  export type BookingTicketCountOrderByAggregateInput = {
    id?: SortOrder
    bookingId?: SortOrder
    seatId?: SortOrder
    seatLabel?: SortOrder
    price?: SortOrder
    tierLabel?: SortOrder
    tierId?: SortOrder
  }

  export type BookingTicketAvgOrderByAggregateInput = {
    price?: SortOrder
  }

  export type BookingTicketMaxOrderByAggregateInput = {
    id?: SortOrder
    bookingId?: SortOrder
    seatId?: SortOrder
    seatLabel?: SortOrder
    price?: SortOrder
    tierLabel?: SortOrder
    tierId?: SortOrder
  }

  export type BookingTicketMinOrderByAggregateInput = {
    id?: SortOrder
    bookingId?: SortOrder
    seatId?: SortOrder
    seatLabel?: SortOrder
    price?: SortOrder
    tierLabel?: SortOrder
    tierId?: SortOrder
  }

  export type BookingTicketSumOrderByAggregateInput = {
    price?: SortOrder
  }

  export type BookingAuditCountOrderByAggregateInput = {
    id?: SortOrder
    bookingId?: SortOrder
    type?: SortOrder
    message?: SortOrder
    actor?: SortOrder
    createdAt?: SortOrder
  }

  export type BookingAuditMaxOrderByAggregateInput = {
    id?: SortOrder
    bookingId?: SortOrder
    type?: SortOrder
    message?: SortOrder
    actor?: SortOrder
    createdAt?: SortOrder
  }

  export type BookingAuditMinOrderByAggregateInput = {
    id?: SortOrder
    bookingId?: SortOrder
    type?: SortOrder
    message?: SortOrder
    actor?: SortOrder
    createdAt?: SortOrder
  }

  export type EnumSettlementStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.SettlementStatus | EnumSettlementStatusFieldRefInput<$PrismaModel>
    in?: $Enums.SettlementStatus[]
    notIn?: $Enums.SettlementStatus[]
    not?: NestedEnumSettlementStatusFilter<$PrismaModel> | $Enums.SettlementStatus
  }

  export type BookingNullableRelationFilter = {
    is?: BookingWhereInput | null
    isNot?: BookingWhereInput | null
  }

  export type SettlementTransactionCountOrderByAggregateInput = {
    id?: SortOrder
    gateway?: SortOrder
    transactionId?: SortOrder
    amount?: SortOrder
    currency?: SortOrder
    status?: SortOrder
    fees?: SortOrder
    netPayout?: SortOrder
    settledAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    bookingId?: SortOrder
  }

  export type SettlementTransactionAvgOrderByAggregateInput = {
    amount?: SortOrder
    fees?: SortOrder
    netPayout?: SortOrder
  }

  export type SettlementTransactionMaxOrderByAggregateInput = {
    id?: SortOrder
    gateway?: SortOrder
    transactionId?: SortOrder
    amount?: SortOrder
    currency?: SortOrder
    status?: SortOrder
    fees?: SortOrder
    netPayout?: SortOrder
    settledAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    bookingId?: SortOrder
  }

  export type SettlementTransactionMinOrderByAggregateInput = {
    id?: SortOrder
    gateway?: SortOrder
    transactionId?: SortOrder
    amount?: SortOrder
    currency?: SortOrder
    status?: SortOrder
    fees?: SortOrder
    netPayout?: SortOrder
    settledAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    bookingId?: SortOrder
  }

  export type SettlementTransactionSumOrderByAggregateInput = {
    amount?: SortOrder
    fees?: SortOrder
    netPayout?: SortOrder
  }

  export type EnumSettlementStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.SettlementStatus | EnumSettlementStatusFieldRefInput<$PrismaModel>
    in?: $Enums.SettlementStatus[]
    notIn?: $Enums.SettlementStatus[]
    not?: NestedEnumSettlementStatusWithAggregatesFilter<$PrismaModel> | $Enums.SettlementStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumSettlementStatusFilter<$PrismaModel>
    _max?: NestedEnumSettlementStatusFilter<$PrismaModel>
  }

  export type NotificationCampaignListRelationFilter = {
    every?: NotificationCampaignWhereInput
    some?: NotificationCampaignWhereInput
    none?: NotificationCampaignWhereInput
  }

  export type NotificationCampaignOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type NotificationSegmentCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type NotificationSegmentMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type NotificationSegmentMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumCampaignStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.CampaignStatus | EnumCampaignStatusFieldRefInput<$PrismaModel>
    in?: $Enums.CampaignStatus[]
    notIn?: $Enums.CampaignStatus[]
    not?: NestedEnumCampaignStatusFilter<$PrismaModel> | $Enums.CampaignStatus
  }

  export type NotificationSegmentRelationFilter = {
    is?: NotificationSegmentWhereInput
    isNot?: NotificationSegmentWhereInput
  }

  export type NotificationCampaignCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    subject?: SortOrder
    channels?: SortOrder
    status?: SortOrder
    scheduledAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    segmentId?: SortOrder
    statsSent?: SortOrder
    statsOpened?: SortOrder
    statsClicked?: SortOrder
  }

  export type NotificationCampaignAvgOrderByAggregateInput = {
    statsSent?: SortOrder
    statsOpened?: SortOrder
    statsClicked?: SortOrder
  }

  export type NotificationCampaignMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    subject?: SortOrder
    status?: SortOrder
    scheduledAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    segmentId?: SortOrder
    statsSent?: SortOrder
    statsOpened?: SortOrder
    statsClicked?: SortOrder
  }

  export type NotificationCampaignMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    subject?: SortOrder
    status?: SortOrder
    scheduledAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    segmentId?: SortOrder
    statsSent?: SortOrder
    statsOpened?: SortOrder
    statsClicked?: SortOrder
  }

  export type NotificationCampaignSumOrderByAggregateInput = {
    statsSent?: SortOrder
    statsOpened?: SortOrder
    statsClicked?: SortOrder
  }

  export type EnumCampaignStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.CampaignStatus | EnumCampaignStatusFieldRefInput<$PrismaModel>
    in?: $Enums.CampaignStatus[]
    notIn?: $Enums.CampaignStatus[]
    not?: NestedEnumCampaignStatusWithAggregatesFilter<$PrismaModel> | $Enums.CampaignStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumCampaignStatusFilter<$PrismaModel>
    _max?: NestedEnumCampaignStatusFilter<$PrismaModel>
  }

  export type PlatformSettingsCountOrderByAggregateInput = {
    id?: SortOrder
    razorpayKey?: SortOrder
    stripeKey?: SortOrder
    settlementDays?: SortOrder
    cgst?: SortOrder
    sgst?: SortOrder
    convenienceFee?: SortOrder
    theatreName?: SortOrder
    supportEmail?: SortOrder
    contactNumber?: SortOrder
    address?: SortOrder
    termsUrl?: SortOrder
    privacyUrl?: SortOrder
    refundWindowHours?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PlatformSettingsAvgOrderByAggregateInput = {
    id?: SortOrder
    settlementDays?: SortOrder
    cgst?: SortOrder
    sgst?: SortOrder
    convenienceFee?: SortOrder
    refundWindowHours?: SortOrder
  }

  export type PlatformSettingsMaxOrderByAggregateInput = {
    id?: SortOrder
    razorpayKey?: SortOrder
    stripeKey?: SortOrder
    settlementDays?: SortOrder
    cgst?: SortOrder
    sgst?: SortOrder
    convenienceFee?: SortOrder
    theatreName?: SortOrder
    supportEmail?: SortOrder
    contactNumber?: SortOrder
    address?: SortOrder
    termsUrl?: SortOrder
    privacyUrl?: SortOrder
    refundWindowHours?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PlatformSettingsMinOrderByAggregateInput = {
    id?: SortOrder
    razorpayKey?: SortOrder
    stripeKey?: SortOrder
    settlementDays?: SortOrder
    cgst?: SortOrder
    sgst?: SortOrder
    convenienceFee?: SortOrder
    theatreName?: SortOrder
    supportEmail?: SortOrder
    contactNumber?: SortOrder
    address?: SortOrder
    termsUrl?: SortOrder
    privacyUrl?: SortOrder
    refundWindowHours?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PlatformSettingsSumOrderByAggregateInput = {
    id?: SortOrder
    settlementDays?: SortOrder
    cgst?: SortOrder
    sgst?: SortOrder
    convenienceFee?: SortOrder
    refundWindowHours?: SortOrder
  }

  export type PaymentAuditCountOrderByAggregateInput = {
    id?: SortOrder
    transactionId?: SortOrder
    status?: SortOrder
    method?: SortOrder
    amount?: SortOrder
    movieTitle?: SortOrder
    showtime?: SortOrder
    seats?: SortOrder
    createdAt?: SortOrder
  }

  export type PaymentAuditAvgOrderByAggregateInput = {
    amount?: SortOrder
  }

  export type PaymentAuditMaxOrderByAggregateInput = {
    id?: SortOrder
    transactionId?: SortOrder
    status?: SortOrder
    method?: SortOrder
    amount?: SortOrder
    movieTitle?: SortOrder
    showtime?: SortOrder
    createdAt?: SortOrder
  }

  export type PaymentAuditMinOrderByAggregateInput = {
    id?: SortOrder
    transactionId?: SortOrder
    status?: SortOrder
    method?: SortOrder
    amount?: SortOrder
    movieTitle?: SortOrder
    showtime?: SortOrder
    createdAt?: SortOrder
  }

  export type PaymentAuditSumOrderByAggregateInput = {
    amount?: SortOrder
  }

  export type AdminUserCreateNestedOneWithoutUserInput = {
    create?: XOR<AdminUserCreateWithoutUserInput, AdminUserUncheckedCreateWithoutUserInput>
    connectOrCreate?: AdminUserCreateOrConnectWithoutUserInput
    connect?: AdminUserWhereUniqueInput
  }

  export type SessionCreateNestedManyWithoutUserInput = {
    create?: XOR<SessionCreateWithoutUserInput, SessionUncheckedCreateWithoutUserInput> | SessionCreateWithoutUserInput[] | SessionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SessionCreateOrConnectWithoutUserInput | SessionCreateOrConnectWithoutUserInput[]
    createMany?: SessionCreateManyUserInputEnvelope
    connect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
  }

  export type BookingCreateNestedManyWithoutUserInput = {
    create?: XOR<BookingCreateWithoutUserInput, BookingUncheckedCreateWithoutUserInput> | BookingCreateWithoutUserInput[] | BookingUncheckedCreateWithoutUserInput[]
    connectOrCreate?: BookingCreateOrConnectWithoutUserInput | BookingCreateOrConnectWithoutUserInput[]
    createMany?: BookingCreateManyUserInputEnvelope
    connect?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
  }

  export type PasswordResetTokenCreateNestedManyWithoutUserInput = {
    create?: XOR<PasswordResetTokenCreateWithoutUserInput, PasswordResetTokenUncheckedCreateWithoutUserInput> | PasswordResetTokenCreateWithoutUserInput[] | PasswordResetTokenUncheckedCreateWithoutUserInput[]
    connectOrCreate?: PasswordResetTokenCreateOrConnectWithoutUserInput | PasswordResetTokenCreateOrConnectWithoutUserInput[]
    createMany?: PasswordResetTokenCreateManyUserInputEnvelope
    connect?: PasswordResetTokenWhereUniqueInput | PasswordResetTokenWhereUniqueInput[]
  }

  export type AdminUserUncheckedCreateNestedOneWithoutUserInput = {
    create?: XOR<AdminUserCreateWithoutUserInput, AdminUserUncheckedCreateWithoutUserInput>
    connectOrCreate?: AdminUserCreateOrConnectWithoutUserInput
    connect?: AdminUserWhereUniqueInput
  }

  export type SessionUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<SessionCreateWithoutUserInput, SessionUncheckedCreateWithoutUserInput> | SessionCreateWithoutUserInput[] | SessionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SessionCreateOrConnectWithoutUserInput | SessionCreateOrConnectWithoutUserInput[]
    createMany?: SessionCreateManyUserInputEnvelope
    connect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
  }

  export type BookingUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<BookingCreateWithoutUserInput, BookingUncheckedCreateWithoutUserInput> | BookingCreateWithoutUserInput[] | BookingUncheckedCreateWithoutUserInput[]
    connectOrCreate?: BookingCreateOrConnectWithoutUserInput | BookingCreateOrConnectWithoutUserInput[]
    createMany?: BookingCreateManyUserInputEnvelope
    connect?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
  }

  export type PasswordResetTokenUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<PasswordResetTokenCreateWithoutUserInput, PasswordResetTokenUncheckedCreateWithoutUserInput> | PasswordResetTokenCreateWithoutUserInput[] | PasswordResetTokenUncheckedCreateWithoutUserInput[]
    connectOrCreate?: PasswordResetTokenCreateOrConnectWithoutUserInput | PasswordResetTokenCreateOrConnectWithoutUserInput[]
    createMany?: PasswordResetTokenCreateManyUserInputEnvelope
    connect?: PasswordResetTokenWhereUniqueInput | PasswordResetTokenWhereUniqueInput[]
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type AdminUserUpdateOneWithoutUserNestedInput = {
    create?: XOR<AdminUserCreateWithoutUserInput, AdminUserUncheckedCreateWithoutUserInput>
    connectOrCreate?: AdminUserCreateOrConnectWithoutUserInput
    upsert?: AdminUserUpsertWithoutUserInput
    disconnect?: AdminUserWhereInput | boolean
    delete?: AdminUserWhereInput | boolean
    connect?: AdminUserWhereUniqueInput
    update?: XOR<XOR<AdminUserUpdateToOneWithWhereWithoutUserInput, AdminUserUpdateWithoutUserInput>, AdminUserUncheckedUpdateWithoutUserInput>
  }

  export type SessionUpdateManyWithoutUserNestedInput = {
    create?: XOR<SessionCreateWithoutUserInput, SessionUncheckedCreateWithoutUserInput> | SessionCreateWithoutUserInput[] | SessionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SessionCreateOrConnectWithoutUserInput | SessionCreateOrConnectWithoutUserInput[]
    upsert?: SessionUpsertWithWhereUniqueWithoutUserInput | SessionUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: SessionCreateManyUserInputEnvelope
    set?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    disconnect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    delete?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    connect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    update?: SessionUpdateWithWhereUniqueWithoutUserInput | SessionUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: SessionUpdateManyWithWhereWithoutUserInput | SessionUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: SessionScalarWhereInput | SessionScalarWhereInput[]
  }

  export type BookingUpdateManyWithoutUserNestedInput = {
    create?: XOR<BookingCreateWithoutUserInput, BookingUncheckedCreateWithoutUserInput> | BookingCreateWithoutUserInput[] | BookingUncheckedCreateWithoutUserInput[]
    connectOrCreate?: BookingCreateOrConnectWithoutUserInput | BookingCreateOrConnectWithoutUserInput[]
    upsert?: BookingUpsertWithWhereUniqueWithoutUserInput | BookingUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: BookingCreateManyUserInputEnvelope
    set?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
    disconnect?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
    delete?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
    connect?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
    update?: BookingUpdateWithWhereUniqueWithoutUserInput | BookingUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: BookingUpdateManyWithWhereWithoutUserInput | BookingUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: BookingScalarWhereInput | BookingScalarWhereInput[]
  }

  export type PasswordResetTokenUpdateManyWithoutUserNestedInput = {
    create?: XOR<PasswordResetTokenCreateWithoutUserInput, PasswordResetTokenUncheckedCreateWithoutUserInput> | PasswordResetTokenCreateWithoutUserInput[] | PasswordResetTokenUncheckedCreateWithoutUserInput[]
    connectOrCreate?: PasswordResetTokenCreateOrConnectWithoutUserInput | PasswordResetTokenCreateOrConnectWithoutUserInput[]
    upsert?: PasswordResetTokenUpsertWithWhereUniqueWithoutUserInput | PasswordResetTokenUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: PasswordResetTokenCreateManyUserInputEnvelope
    set?: PasswordResetTokenWhereUniqueInput | PasswordResetTokenWhereUniqueInput[]
    disconnect?: PasswordResetTokenWhereUniqueInput | PasswordResetTokenWhereUniqueInput[]
    delete?: PasswordResetTokenWhereUniqueInput | PasswordResetTokenWhereUniqueInput[]
    connect?: PasswordResetTokenWhereUniqueInput | PasswordResetTokenWhereUniqueInput[]
    update?: PasswordResetTokenUpdateWithWhereUniqueWithoutUserInput | PasswordResetTokenUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: PasswordResetTokenUpdateManyWithWhereWithoutUserInput | PasswordResetTokenUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: PasswordResetTokenScalarWhereInput | PasswordResetTokenScalarWhereInput[]
  }

  export type AdminUserUncheckedUpdateOneWithoutUserNestedInput = {
    create?: XOR<AdminUserCreateWithoutUserInput, AdminUserUncheckedCreateWithoutUserInput>
    connectOrCreate?: AdminUserCreateOrConnectWithoutUserInput
    upsert?: AdminUserUpsertWithoutUserInput
    disconnect?: AdminUserWhereInput | boolean
    delete?: AdminUserWhereInput | boolean
    connect?: AdminUserWhereUniqueInput
    update?: XOR<XOR<AdminUserUpdateToOneWithWhereWithoutUserInput, AdminUserUpdateWithoutUserInput>, AdminUserUncheckedUpdateWithoutUserInput>
  }

  export type SessionUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<SessionCreateWithoutUserInput, SessionUncheckedCreateWithoutUserInput> | SessionCreateWithoutUserInput[] | SessionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SessionCreateOrConnectWithoutUserInput | SessionCreateOrConnectWithoutUserInput[]
    upsert?: SessionUpsertWithWhereUniqueWithoutUserInput | SessionUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: SessionCreateManyUserInputEnvelope
    set?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    disconnect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    delete?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    connect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    update?: SessionUpdateWithWhereUniqueWithoutUserInput | SessionUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: SessionUpdateManyWithWhereWithoutUserInput | SessionUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: SessionScalarWhereInput | SessionScalarWhereInput[]
  }

  export type BookingUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<BookingCreateWithoutUserInput, BookingUncheckedCreateWithoutUserInput> | BookingCreateWithoutUserInput[] | BookingUncheckedCreateWithoutUserInput[]
    connectOrCreate?: BookingCreateOrConnectWithoutUserInput | BookingCreateOrConnectWithoutUserInput[]
    upsert?: BookingUpsertWithWhereUniqueWithoutUserInput | BookingUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: BookingCreateManyUserInputEnvelope
    set?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
    disconnect?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
    delete?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
    connect?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
    update?: BookingUpdateWithWhereUniqueWithoutUserInput | BookingUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: BookingUpdateManyWithWhereWithoutUserInput | BookingUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: BookingScalarWhereInput | BookingScalarWhereInput[]
  }

  export type PasswordResetTokenUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<PasswordResetTokenCreateWithoutUserInput, PasswordResetTokenUncheckedCreateWithoutUserInput> | PasswordResetTokenCreateWithoutUserInput[] | PasswordResetTokenUncheckedCreateWithoutUserInput[]
    connectOrCreate?: PasswordResetTokenCreateOrConnectWithoutUserInput | PasswordResetTokenCreateOrConnectWithoutUserInput[]
    upsert?: PasswordResetTokenUpsertWithWhereUniqueWithoutUserInput | PasswordResetTokenUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: PasswordResetTokenCreateManyUserInputEnvelope
    set?: PasswordResetTokenWhereUniqueInput | PasswordResetTokenWhereUniqueInput[]
    disconnect?: PasswordResetTokenWhereUniqueInput | PasswordResetTokenWhereUniqueInput[]
    delete?: PasswordResetTokenWhereUniqueInput | PasswordResetTokenWhereUniqueInput[]
    connect?: PasswordResetTokenWhereUniqueInput | PasswordResetTokenWhereUniqueInput[]
    update?: PasswordResetTokenUpdateWithWhereUniqueWithoutUserInput | PasswordResetTokenUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: PasswordResetTokenUpdateManyWithWhereWithoutUserInput | PasswordResetTokenUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: PasswordResetTokenScalarWhereInput | PasswordResetTokenScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutAdminProfileInput = {
    create?: XOR<UserCreateWithoutAdminProfileInput, UserUncheckedCreateWithoutAdminProfileInput>
    connectOrCreate?: UserCreateOrConnectWithoutAdminProfileInput
    connect?: UserWhereUniqueInput
  }

  export type AdminUserRoleCreateNestedManyWithoutAdminUserInput = {
    create?: XOR<AdminUserRoleCreateWithoutAdminUserInput, AdminUserRoleUncheckedCreateWithoutAdminUserInput> | AdminUserRoleCreateWithoutAdminUserInput[] | AdminUserRoleUncheckedCreateWithoutAdminUserInput[]
    connectOrCreate?: AdminUserRoleCreateOrConnectWithoutAdminUserInput | AdminUserRoleCreateOrConnectWithoutAdminUserInput[]
    createMany?: AdminUserRoleCreateManyAdminUserInputEnvelope
    connect?: AdminUserRoleWhereUniqueInput | AdminUserRoleWhereUniqueInput[]
  }

  export type AdminUserRoleUncheckedCreateNestedManyWithoutAdminUserInput = {
    create?: XOR<AdminUserRoleCreateWithoutAdminUserInput, AdminUserRoleUncheckedCreateWithoutAdminUserInput> | AdminUserRoleCreateWithoutAdminUserInput[] | AdminUserRoleUncheckedCreateWithoutAdminUserInput[]
    connectOrCreate?: AdminUserRoleCreateOrConnectWithoutAdminUserInput | AdminUserRoleCreateOrConnectWithoutAdminUserInput[]
    createMany?: AdminUserRoleCreateManyAdminUserInputEnvelope
    connect?: AdminUserRoleWhereUniqueInput | AdminUserRoleWhereUniqueInput[]
  }

  export type EnumAdminStatusFieldUpdateOperationsInput = {
    set?: $Enums.AdminStatus
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type UserUpdateOneRequiredWithoutAdminProfileNestedInput = {
    create?: XOR<UserCreateWithoutAdminProfileInput, UserUncheckedCreateWithoutAdminProfileInput>
    connectOrCreate?: UserCreateOrConnectWithoutAdminProfileInput
    upsert?: UserUpsertWithoutAdminProfileInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutAdminProfileInput, UserUpdateWithoutAdminProfileInput>, UserUncheckedUpdateWithoutAdminProfileInput>
  }

  export type AdminUserRoleUpdateManyWithoutAdminUserNestedInput = {
    create?: XOR<AdminUserRoleCreateWithoutAdminUserInput, AdminUserRoleUncheckedCreateWithoutAdminUserInput> | AdminUserRoleCreateWithoutAdminUserInput[] | AdminUserRoleUncheckedCreateWithoutAdminUserInput[]
    connectOrCreate?: AdminUserRoleCreateOrConnectWithoutAdminUserInput | AdminUserRoleCreateOrConnectWithoutAdminUserInput[]
    upsert?: AdminUserRoleUpsertWithWhereUniqueWithoutAdminUserInput | AdminUserRoleUpsertWithWhereUniqueWithoutAdminUserInput[]
    createMany?: AdminUserRoleCreateManyAdminUserInputEnvelope
    set?: AdminUserRoleWhereUniqueInput | AdminUserRoleWhereUniqueInput[]
    disconnect?: AdminUserRoleWhereUniqueInput | AdminUserRoleWhereUniqueInput[]
    delete?: AdminUserRoleWhereUniqueInput | AdminUserRoleWhereUniqueInput[]
    connect?: AdminUserRoleWhereUniqueInput | AdminUserRoleWhereUniqueInput[]
    update?: AdminUserRoleUpdateWithWhereUniqueWithoutAdminUserInput | AdminUserRoleUpdateWithWhereUniqueWithoutAdminUserInput[]
    updateMany?: AdminUserRoleUpdateManyWithWhereWithoutAdminUserInput | AdminUserRoleUpdateManyWithWhereWithoutAdminUserInput[]
    deleteMany?: AdminUserRoleScalarWhereInput | AdminUserRoleScalarWhereInput[]
  }

  export type AdminUserRoleUncheckedUpdateManyWithoutAdminUserNestedInput = {
    create?: XOR<AdminUserRoleCreateWithoutAdminUserInput, AdminUserRoleUncheckedCreateWithoutAdminUserInput> | AdminUserRoleCreateWithoutAdminUserInput[] | AdminUserRoleUncheckedCreateWithoutAdminUserInput[]
    connectOrCreate?: AdminUserRoleCreateOrConnectWithoutAdminUserInput | AdminUserRoleCreateOrConnectWithoutAdminUserInput[]
    upsert?: AdminUserRoleUpsertWithWhereUniqueWithoutAdminUserInput | AdminUserRoleUpsertWithWhereUniqueWithoutAdminUserInput[]
    createMany?: AdminUserRoleCreateManyAdminUserInputEnvelope
    set?: AdminUserRoleWhereUniqueInput | AdminUserRoleWhereUniqueInput[]
    disconnect?: AdminUserRoleWhereUniqueInput | AdminUserRoleWhereUniqueInput[]
    delete?: AdminUserRoleWhereUniqueInput | AdminUserRoleWhereUniqueInput[]
    connect?: AdminUserRoleWhereUniqueInput | AdminUserRoleWhereUniqueInput[]
    update?: AdminUserRoleUpdateWithWhereUniqueWithoutAdminUserInput | AdminUserRoleUpdateWithWhereUniqueWithoutAdminUserInput[]
    updateMany?: AdminUserRoleUpdateManyWithWhereWithoutAdminUserInput | AdminUserRoleUpdateManyWithWhereWithoutAdminUserInput[]
    deleteMany?: AdminUserRoleScalarWhereInput | AdminUserRoleScalarWhereInput[]
  }

  export type AdminUserCreateNestedOneWithoutRolesInput = {
    create?: XOR<AdminUserCreateWithoutRolesInput, AdminUserUncheckedCreateWithoutRolesInput>
    connectOrCreate?: AdminUserCreateOrConnectWithoutRolesInput
    connect?: AdminUserWhereUniqueInput
  }

  export type EnumAdminRoleFieldUpdateOperationsInput = {
    set?: $Enums.AdminRole
  }

  export type AdminUserUpdateOneRequiredWithoutRolesNestedInput = {
    create?: XOR<AdminUserCreateWithoutRolesInput, AdminUserUncheckedCreateWithoutRolesInput>
    connectOrCreate?: AdminUserCreateOrConnectWithoutRolesInput
    upsert?: AdminUserUpsertWithoutRolesInput
    connect?: AdminUserWhereUniqueInput
    update?: XOR<XOR<AdminUserUpdateToOneWithWhereWithoutRolesInput, AdminUserUpdateWithoutRolesInput>, AdminUserUncheckedUpdateWithoutRolesInput>
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type UserCreateNestedOneWithoutSessionsInput = {
    create?: XOR<UserCreateWithoutSessionsInput, UserUncheckedCreateWithoutSessionsInput>
    connectOrCreate?: UserCreateOrConnectWithoutSessionsInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutSessionsNestedInput = {
    create?: XOR<UserCreateWithoutSessionsInput, UserUncheckedCreateWithoutSessionsInput>
    connectOrCreate?: UserCreateOrConnectWithoutSessionsInput
    upsert?: UserUpsertWithoutSessionsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutSessionsInput, UserUpdateWithoutSessionsInput>, UserUncheckedUpdateWithoutSessionsInput>
  }

  export type UserCreateNestedOneWithoutPasswordResetTokensInput = {
    create?: XOR<UserCreateWithoutPasswordResetTokensInput, UserUncheckedCreateWithoutPasswordResetTokensInput>
    connectOrCreate?: UserCreateOrConnectWithoutPasswordResetTokensInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutPasswordResetTokensNestedInput = {
    create?: XOR<UserCreateWithoutPasswordResetTokensInput, UserUncheckedCreateWithoutPasswordResetTokensInput>
    connectOrCreate?: UserCreateOrConnectWithoutPasswordResetTokensInput
    upsert?: UserUpsertWithoutPasswordResetTokensInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutPasswordResetTokensInput, UserUpdateWithoutPasswordResetTokensInput>, UserUncheckedUpdateWithoutPasswordResetTokensInput>
  }

  export type MovieGenreCreateNestedManyWithoutMovieInput = {
    create?: XOR<MovieGenreCreateWithoutMovieInput, MovieGenreUncheckedCreateWithoutMovieInput> | MovieGenreCreateWithoutMovieInput[] | MovieGenreUncheckedCreateWithoutMovieInput[]
    connectOrCreate?: MovieGenreCreateOrConnectWithoutMovieInput | MovieGenreCreateOrConnectWithoutMovieInput[]
    createMany?: MovieGenreCreateManyMovieInputEnvelope
    connect?: MovieGenreWhereUniqueInput | MovieGenreWhereUniqueInput[]
  }

  export type MovieLanguageCreateNestedManyWithoutMovieInput = {
    create?: XOR<MovieLanguageCreateWithoutMovieInput, MovieLanguageUncheckedCreateWithoutMovieInput> | MovieLanguageCreateWithoutMovieInput[] | MovieLanguageUncheckedCreateWithoutMovieInput[]
    connectOrCreate?: MovieLanguageCreateOrConnectWithoutMovieInput | MovieLanguageCreateOrConnectWithoutMovieInput[]
    createMany?: MovieLanguageCreateManyMovieInputEnvelope
    connect?: MovieLanguageWhereUniqueInput | MovieLanguageWhereUniqueInput[]
  }

  export type ShowtimeCreateNestedManyWithoutMovieInput = {
    create?: XOR<ShowtimeCreateWithoutMovieInput, ShowtimeUncheckedCreateWithoutMovieInput> | ShowtimeCreateWithoutMovieInput[] | ShowtimeUncheckedCreateWithoutMovieInput[]
    connectOrCreate?: ShowtimeCreateOrConnectWithoutMovieInput | ShowtimeCreateOrConnectWithoutMovieInput[]
    createMany?: ShowtimeCreateManyMovieInputEnvelope
    connect?: ShowtimeWhereUniqueInput | ShowtimeWhereUniqueInput[]
  }

  export type MovieGenreUncheckedCreateNestedManyWithoutMovieInput = {
    create?: XOR<MovieGenreCreateWithoutMovieInput, MovieGenreUncheckedCreateWithoutMovieInput> | MovieGenreCreateWithoutMovieInput[] | MovieGenreUncheckedCreateWithoutMovieInput[]
    connectOrCreate?: MovieGenreCreateOrConnectWithoutMovieInput | MovieGenreCreateOrConnectWithoutMovieInput[]
    createMany?: MovieGenreCreateManyMovieInputEnvelope
    connect?: MovieGenreWhereUniqueInput | MovieGenreWhereUniqueInput[]
  }

  export type MovieLanguageUncheckedCreateNestedManyWithoutMovieInput = {
    create?: XOR<MovieLanguageCreateWithoutMovieInput, MovieLanguageUncheckedCreateWithoutMovieInput> | MovieLanguageCreateWithoutMovieInput[] | MovieLanguageUncheckedCreateWithoutMovieInput[]
    connectOrCreate?: MovieLanguageCreateOrConnectWithoutMovieInput | MovieLanguageCreateOrConnectWithoutMovieInput[]
    createMany?: MovieLanguageCreateManyMovieInputEnvelope
    connect?: MovieLanguageWhereUniqueInput | MovieLanguageWhereUniqueInput[]
  }

  export type ShowtimeUncheckedCreateNestedManyWithoutMovieInput = {
    create?: XOR<ShowtimeCreateWithoutMovieInput, ShowtimeUncheckedCreateWithoutMovieInput> | ShowtimeCreateWithoutMovieInput[] | ShowtimeUncheckedCreateWithoutMovieInput[]
    connectOrCreate?: ShowtimeCreateOrConnectWithoutMovieInput | ShowtimeCreateOrConnectWithoutMovieInput[]
    createMany?: ShowtimeCreateManyMovieInputEnvelope
    connect?: ShowtimeWhereUniqueInput | ShowtimeWhereUniqueInput[]
  }

  export type EnumMovieStatusFieldUpdateOperationsInput = {
    set?: $Enums.MovieStatus
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type NullableDecimalFieldUpdateOperationsInput = {
    set?: Decimal | DecimalJsLike | number | string | null
    increment?: Decimal | DecimalJsLike | number | string
    decrement?: Decimal | DecimalJsLike | number | string
    multiply?: Decimal | DecimalJsLike | number | string
    divide?: Decimal | DecimalJsLike | number | string
  }

  export type MovieGenreUpdateManyWithoutMovieNestedInput = {
    create?: XOR<MovieGenreCreateWithoutMovieInput, MovieGenreUncheckedCreateWithoutMovieInput> | MovieGenreCreateWithoutMovieInput[] | MovieGenreUncheckedCreateWithoutMovieInput[]
    connectOrCreate?: MovieGenreCreateOrConnectWithoutMovieInput | MovieGenreCreateOrConnectWithoutMovieInput[]
    upsert?: MovieGenreUpsertWithWhereUniqueWithoutMovieInput | MovieGenreUpsertWithWhereUniqueWithoutMovieInput[]
    createMany?: MovieGenreCreateManyMovieInputEnvelope
    set?: MovieGenreWhereUniqueInput | MovieGenreWhereUniqueInput[]
    disconnect?: MovieGenreWhereUniqueInput | MovieGenreWhereUniqueInput[]
    delete?: MovieGenreWhereUniqueInput | MovieGenreWhereUniqueInput[]
    connect?: MovieGenreWhereUniqueInput | MovieGenreWhereUniqueInput[]
    update?: MovieGenreUpdateWithWhereUniqueWithoutMovieInput | MovieGenreUpdateWithWhereUniqueWithoutMovieInput[]
    updateMany?: MovieGenreUpdateManyWithWhereWithoutMovieInput | MovieGenreUpdateManyWithWhereWithoutMovieInput[]
    deleteMany?: MovieGenreScalarWhereInput | MovieGenreScalarWhereInput[]
  }

  export type MovieLanguageUpdateManyWithoutMovieNestedInput = {
    create?: XOR<MovieLanguageCreateWithoutMovieInput, MovieLanguageUncheckedCreateWithoutMovieInput> | MovieLanguageCreateWithoutMovieInput[] | MovieLanguageUncheckedCreateWithoutMovieInput[]
    connectOrCreate?: MovieLanguageCreateOrConnectWithoutMovieInput | MovieLanguageCreateOrConnectWithoutMovieInput[]
    upsert?: MovieLanguageUpsertWithWhereUniqueWithoutMovieInput | MovieLanguageUpsertWithWhereUniqueWithoutMovieInput[]
    createMany?: MovieLanguageCreateManyMovieInputEnvelope
    set?: MovieLanguageWhereUniqueInput | MovieLanguageWhereUniqueInput[]
    disconnect?: MovieLanguageWhereUniqueInput | MovieLanguageWhereUniqueInput[]
    delete?: MovieLanguageWhereUniqueInput | MovieLanguageWhereUniqueInput[]
    connect?: MovieLanguageWhereUniqueInput | MovieLanguageWhereUniqueInput[]
    update?: MovieLanguageUpdateWithWhereUniqueWithoutMovieInput | MovieLanguageUpdateWithWhereUniqueWithoutMovieInput[]
    updateMany?: MovieLanguageUpdateManyWithWhereWithoutMovieInput | MovieLanguageUpdateManyWithWhereWithoutMovieInput[]
    deleteMany?: MovieLanguageScalarWhereInput | MovieLanguageScalarWhereInput[]
  }

  export type ShowtimeUpdateManyWithoutMovieNestedInput = {
    create?: XOR<ShowtimeCreateWithoutMovieInput, ShowtimeUncheckedCreateWithoutMovieInput> | ShowtimeCreateWithoutMovieInput[] | ShowtimeUncheckedCreateWithoutMovieInput[]
    connectOrCreate?: ShowtimeCreateOrConnectWithoutMovieInput | ShowtimeCreateOrConnectWithoutMovieInput[]
    upsert?: ShowtimeUpsertWithWhereUniqueWithoutMovieInput | ShowtimeUpsertWithWhereUniqueWithoutMovieInput[]
    createMany?: ShowtimeCreateManyMovieInputEnvelope
    set?: ShowtimeWhereUniqueInput | ShowtimeWhereUniqueInput[]
    disconnect?: ShowtimeWhereUniqueInput | ShowtimeWhereUniqueInput[]
    delete?: ShowtimeWhereUniqueInput | ShowtimeWhereUniqueInput[]
    connect?: ShowtimeWhereUniqueInput | ShowtimeWhereUniqueInput[]
    update?: ShowtimeUpdateWithWhereUniqueWithoutMovieInput | ShowtimeUpdateWithWhereUniqueWithoutMovieInput[]
    updateMany?: ShowtimeUpdateManyWithWhereWithoutMovieInput | ShowtimeUpdateManyWithWhereWithoutMovieInput[]
    deleteMany?: ShowtimeScalarWhereInput | ShowtimeScalarWhereInput[]
  }

  export type MovieGenreUncheckedUpdateManyWithoutMovieNestedInput = {
    create?: XOR<MovieGenreCreateWithoutMovieInput, MovieGenreUncheckedCreateWithoutMovieInput> | MovieGenreCreateWithoutMovieInput[] | MovieGenreUncheckedCreateWithoutMovieInput[]
    connectOrCreate?: MovieGenreCreateOrConnectWithoutMovieInput | MovieGenreCreateOrConnectWithoutMovieInput[]
    upsert?: MovieGenreUpsertWithWhereUniqueWithoutMovieInput | MovieGenreUpsertWithWhereUniqueWithoutMovieInput[]
    createMany?: MovieGenreCreateManyMovieInputEnvelope
    set?: MovieGenreWhereUniqueInput | MovieGenreWhereUniqueInput[]
    disconnect?: MovieGenreWhereUniqueInput | MovieGenreWhereUniqueInput[]
    delete?: MovieGenreWhereUniqueInput | MovieGenreWhereUniqueInput[]
    connect?: MovieGenreWhereUniqueInput | MovieGenreWhereUniqueInput[]
    update?: MovieGenreUpdateWithWhereUniqueWithoutMovieInput | MovieGenreUpdateWithWhereUniqueWithoutMovieInput[]
    updateMany?: MovieGenreUpdateManyWithWhereWithoutMovieInput | MovieGenreUpdateManyWithWhereWithoutMovieInput[]
    deleteMany?: MovieGenreScalarWhereInput | MovieGenreScalarWhereInput[]
  }

  export type MovieLanguageUncheckedUpdateManyWithoutMovieNestedInput = {
    create?: XOR<MovieLanguageCreateWithoutMovieInput, MovieLanguageUncheckedCreateWithoutMovieInput> | MovieLanguageCreateWithoutMovieInput[] | MovieLanguageUncheckedCreateWithoutMovieInput[]
    connectOrCreate?: MovieLanguageCreateOrConnectWithoutMovieInput | MovieLanguageCreateOrConnectWithoutMovieInput[]
    upsert?: MovieLanguageUpsertWithWhereUniqueWithoutMovieInput | MovieLanguageUpsertWithWhereUniqueWithoutMovieInput[]
    createMany?: MovieLanguageCreateManyMovieInputEnvelope
    set?: MovieLanguageWhereUniqueInput | MovieLanguageWhereUniqueInput[]
    disconnect?: MovieLanguageWhereUniqueInput | MovieLanguageWhereUniqueInput[]
    delete?: MovieLanguageWhereUniqueInput | MovieLanguageWhereUniqueInput[]
    connect?: MovieLanguageWhereUniqueInput | MovieLanguageWhereUniqueInput[]
    update?: MovieLanguageUpdateWithWhereUniqueWithoutMovieInput | MovieLanguageUpdateWithWhereUniqueWithoutMovieInput[]
    updateMany?: MovieLanguageUpdateManyWithWhereWithoutMovieInput | MovieLanguageUpdateManyWithWhereWithoutMovieInput[]
    deleteMany?: MovieLanguageScalarWhereInput | MovieLanguageScalarWhereInput[]
  }

  export type ShowtimeUncheckedUpdateManyWithoutMovieNestedInput = {
    create?: XOR<ShowtimeCreateWithoutMovieInput, ShowtimeUncheckedCreateWithoutMovieInput> | ShowtimeCreateWithoutMovieInput[] | ShowtimeUncheckedCreateWithoutMovieInput[]
    connectOrCreate?: ShowtimeCreateOrConnectWithoutMovieInput | ShowtimeCreateOrConnectWithoutMovieInput[]
    upsert?: ShowtimeUpsertWithWhereUniqueWithoutMovieInput | ShowtimeUpsertWithWhereUniqueWithoutMovieInput[]
    createMany?: ShowtimeCreateManyMovieInputEnvelope
    set?: ShowtimeWhereUniqueInput | ShowtimeWhereUniqueInput[]
    disconnect?: ShowtimeWhereUniqueInput | ShowtimeWhereUniqueInput[]
    delete?: ShowtimeWhereUniqueInput | ShowtimeWhereUniqueInput[]
    connect?: ShowtimeWhereUniqueInput | ShowtimeWhereUniqueInput[]
    update?: ShowtimeUpdateWithWhereUniqueWithoutMovieInput | ShowtimeUpdateWithWhereUniqueWithoutMovieInput[]
    updateMany?: ShowtimeUpdateManyWithWhereWithoutMovieInput | ShowtimeUpdateManyWithWhereWithoutMovieInput[]
    deleteMany?: ShowtimeScalarWhereInput | ShowtimeScalarWhereInput[]
  }

  export type MovieCreateNestedOneWithoutGenresInput = {
    create?: XOR<MovieCreateWithoutGenresInput, MovieUncheckedCreateWithoutGenresInput>
    connectOrCreate?: MovieCreateOrConnectWithoutGenresInput
    connect?: MovieWhereUniqueInput
  }

  export type MovieUpdateOneRequiredWithoutGenresNestedInput = {
    create?: XOR<MovieCreateWithoutGenresInput, MovieUncheckedCreateWithoutGenresInput>
    connectOrCreate?: MovieCreateOrConnectWithoutGenresInput
    upsert?: MovieUpsertWithoutGenresInput
    connect?: MovieWhereUniqueInput
    update?: XOR<XOR<MovieUpdateToOneWithWhereWithoutGenresInput, MovieUpdateWithoutGenresInput>, MovieUncheckedUpdateWithoutGenresInput>
  }

  export type MovieCreateNestedOneWithoutLanguagesInput = {
    create?: XOR<MovieCreateWithoutLanguagesInput, MovieUncheckedCreateWithoutLanguagesInput>
    connectOrCreate?: MovieCreateOrConnectWithoutLanguagesInput
    connect?: MovieWhereUniqueInput
  }

  export type MovieUpdateOneRequiredWithoutLanguagesNestedInput = {
    create?: XOR<MovieCreateWithoutLanguagesInput, MovieUncheckedCreateWithoutLanguagesInput>
    connectOrCreate?: MovieCreateOrConnectWithoutLanguagesInput
    upsert?: MovieUpsertWithoutLanguagesInput
    connect?: MovieWhereUniqueInput
    update?: XOR<XOR<MovieUpdateToOneWithWhereWithoutLanguagesInput, MovieUpdateWithoutLanguagesInput>, MovieUncheckedUpdateWithoutLanguagesInput>
  }

  export type ShowtimeCreateNestedManyWithoutAuditoriumInput = {
    create?: XOR<ShowtimeCreateWithoutAuditoriumInput, ShowtimeUncheckedCreateWithoutAuditoriumInput> | ShowtimeCreateWithoutAuditoriumInput[] | ShowtimeUncheckedCreateWithoutAuditoriumInput[]
    connectOrCreate?: ShowtimeCreateOrConnectWithoutAuditoriumInput | ShowtimeCreateOrConnectWithoutAuditoriumInput[]
    createMany?: ShowtimeCreateManyAuditoriumInputEnvelope
    connect?: ShowtimeWhereUniqueInput | ShowtimeWhereUniqueInput[]
  }

  export type ShowtimeUncheckedCreateNestedManyWithoutAuditoriumInput = {
    create?: XOR<ShowtimeCreateWithoutAuditoriumInput, ShowtimeUncheckedCreateWithoutAuditoriumInput> | ShowtimeCreateWithoutAuditoriumInput[] | ShowtimeUncheckedCreateWithoutAuditoriumInput[]
    connectOrCreate?: ShowtimeCreateOrConnectWithoutAuditoriumInput | ShowtimeCreateOrConnectWithoutAuditoriumInput[]
    createMany?: ShowtimeCreateManyAuditoriumInputEnvelope
    connect?: ShowtimeWhereUniqueInput | ShowtimeWhereUniqueInput[]
  }

  export type ShowtimeUpdateManyWithoutAuditoriumNestedInput = {
    create?: XOR<ShowtimeCreateWithoutAuditoriumInput, ShowtimeUncheckedCreateWithoutAuditoriumInput> | ShowtimeCreateWithoutAuditoriumInput[] | ShowtimeUncheckedCreateWithoutAuditoriumInput[]
    connectOrCreate?: ShowtimeCreateOrConnectWithoutAuditoriumInput | ShowtimeCreateOrConnectWithoutAuditoriumInput[]
    upsert?: ShowtimeUpsertWithWhereUniqueWithoutAuditoriumInput | ShowtimeUpsertWithWhereUniqueWithoutAuditoriumInput[]
    createMany?: ShowtimeCreateManyAuditoriumInputEnvelope
    set?: ShowtimeWhereUniqueInput | ShowtimeWhereUniqueInput[]
    disconnect?: ShowtimeWhereUniqueInput | ShowtimeWhereUniqueInput[]
    delete?: ShowtimeWhereUniqueInput | ShowtimeWhereUniqueInput[]
    connect?: ShowtimeWhereUniqueInput | ShowtimeWhereUniqueInput[]
    update?: ShowtimeUpdateWithWhereUniqueWithoutAuditoriumInput | ShowtimeUpdateWithWhereUniqueWithoutAuditoriumInput[]
    updateMany?: ShowtimeUpdateManyWithWhereWithoutAuditoriumInput | ShowtimeUpdateManyWithWhereWithoutAuditoriumInput[]
    deleteMany?: ShowtimeScalarWhereInput | ShowtimeScalarWhereInput[]
  }

  export type ShowtimeUncheckedUpdateManyWithoutAuditoriumNestedInput = {
    create?: XOR<ShowtimeCreateWithoutAuditoriumInput, ShowtimeUncheckedCreateWithoutAuditoriumInput> | ShowtimeCreateWithoutAuditoriumInput[] | ShowtimeUncheckedCreateWithoutAuditoriumInput[]
    connectOrCreate?: ShowtimeCreateOrConnectWithoutAuditoriumInput | ShowtimeCreateOrConnectWithoutAuditoriumInput[]
    upsert?: ShowtimeUpsertWithWhereUniqueWithoutAuditoriumInput | ShowtimeUpsertWithWhereUniqueWithoutAuditoriumInput[]
    createMany?: ShowtimeCreateManyAuditoriumInputEnvelope
    set?: ShowtimeWhereUniqueInput | ShowtimeWhereUniqueInput[]
    disconnect?: ShowtimeWhereUniqueInput | ShowtimeWhereUniqueInput[]
    delete?: ShowtimeWhereUniqueInput | ShowtimeWhereUniqueInput[]
    connect?: ShowtimeWhereUniqueInput | ShowtimeWhereUniqueInput[]
    update?: ShowtimeUpdateWithWhereUniqueWithoutAuditoriumInput | ShowtimeUpdateWithWhereUniqueWithoutAuditoriumInput[]
    updateMany?: ShowtimeUpdateManyWithWhereWithoutAuditoriumInput | ShowtimeUpdateManyWithWhereWithoutAuditoriumInput[]
    deleteMany?: ShowtimeScalarWhereInput | ShowtimeScalarWhereInput[]
  }

  export type MovieCreateNestedOneWithoutShowtimesInput = {
    create?: XOR<MovieCreateWithoutShowtimesInput, MovieUncheckedCreateWithoutShowtimesInput>
    connectOrCreate?: MovieCreateOrConnectWithoutShowtimesInput
    connect?: MovieWhereUniqueInput
  }

  export type AuditoriumCreateNestedOneWithoutShowtimesInput = {
    create?: XOR<AuditoriumCreateWithoutShowtimesInput, AuditoriumUncheckedCreateWithoutShowtimesInput>
    connectOrCreate?: AuditoriumCreateOrConnectWithoutShowtimesInput
    connect?: AuditoriumWhereUniqueInput
  }

  export type ShowtimePricingTierCreateNestedManyWithoutShowtimeInput = {
    create?: XOR<ShowtimePricingTierCreateWithoutShowtimeInput, ShowtimePricingTierUncheckedCreateWithoutShowtimeInput> | ShowtimePricingTierCreateWithoutShowtimeInput[] | ShowtimePricingTierUncheckedCreateWithoutShowtimeInput[]
    connectOrCreate?: ShowtimePricingTierCreateOrConnectWithoutShowtimeInput | ShowtimePricingTierCreateOrConnectWithoutShowtimeInput[]
    createMany?: ShowtimePricingTierCreateManyShowtimeInputEnvelope
    connect?: ShowtimePricingTierWhereUniqueInput | ShowtimePricingTierWhereUniqueInput[]
  }

  export type BookingCreateNestedManyWithoutShowtimeInput = {
    create?: XOR<BookingCreateWithoutShowtimeInput, BookingUncheckedCreateWithoutShowtimeInput> | BookingCreateWithoutShowtimeInput[] | BookingUncheckedCreateWithoutShowtimeInput[]
    connectOrCreate?: BookingCreateOrConnectWithoutShowtimeInput | BookingCreateOrConnectWithoutShowtimeInput[]
    createMany?: BookingCreateManyShowtimeInputEnvelope
    connect?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
  }

  export type ShowtimePricingTierUncheckedCreateNestedManyWithoutShowtimeInput = {
    create?: XOR<ShowtimePricingTierCreateWithoutShowtimeInput, ShowtimePricingTierUncheckedCreateWithoutShowtimeInput> | ShowtimePricingTierCreateWithoutShowtimeInput[] | ShowtimePricingTierUncheckedCreateWithoutShowtimeInput[]
    connectOrCreate?: ShowtimePricingTierCreateOrConnectWithoutShowtimeInput | ShowtimePricingTierCreateOrConnectWithoutShowtimeInput[]
    createMany?: ShowtimePricingTierCreateManyShowtimeInputEnvelope
    connect?: ShowtimePricingTierWhereUniqueInput | ShowtimePricingTierWhereUniqueInput[]
  }

  export type BookingUncheckedCreateNestedManyWithoutShowtimeInput = {
    create?: XOR<BookingCreateWithoutShowtimeInput, BookingUncheckedCreateWithoutShowtimeInput> | BookingCreateWithoutShowtimeInput[] | BookingUncheckedCreateWithoutShowtimeInput[]
    connectOrCreate?: BookingCreateOrConnectWithoutShowtimeInput | BookingCreateOrConnectWithoutShowtimeInput[]
    createMany?: BookingCreateManyShowtimeInputEnvelope
    connect?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
  }

  export type DecimalFieldUpdateOperationsInput = {
    set?: Decimal | DecimalJsLike | number | string
    increment?: Decimal | DecimalJsLike | number | string
    decrement?: Decimal | DecimalJsLike | number | string
    multiply?: Decimal | DecimalJsLike | number | string
    divide?: Decimal | DecimalJsLike | number | string
  }

  export type EnumShowtimeStatusFieldUpdateOperationsInput = {
    set?: $Enums.ShowtimeStatus
  }

  export type MovieUpdateOneRequiredWithoutShowtimesNestedInput = {
    create?: XOR<MovieCreateWithoutShowtimesInput, MovieUncheckedCreateWithoutShowtimesInput>
    connectOrCreate?: MovieCreateOrConnectWithoutShowtimesInput
    upsert?: MovieUpsertWithoutShowtimesInput
    connect?: MovieWhereUniqueInput
    update?: XOR<XOR<MovieUpdateToOneWithWhereWithoutShowtimesInput, MovieUpdateWithoutShowtimesInput>, MovieUncheckedUpdateWithoutShowtimesInput>
  }

  export type AuditoriumUpdateOneRequiredWithoutShowtimesNestedInput = {
    create?: XOR<AuditoriumCreateWithoutShowtimesInput, AuditoriumUncheckedCreateWithoutShowtimesInput>
    connectOrCreate?: AuditoriumCreateOrConnectWithoutShowtimesInput
    upsert?: AuditoriumUpsertWithoutShowtimesInput
    connect?: AuditoriumWhereUniqueInput
    update?: XOR<XOR<AuditoriumUpdateToOneWithWhereWithoutShowtimesInput, AuditoriumUpdateWithoutShowtimesInput>, AuditoriumUncheckedUpdateWithoutShowtimesInput>
  }

  export type ShowtimePricingTierUpdateManyWithoutShowtimeNestedInput = {
    create?: XOR<ShowtimePricingTierCreateWithoutShowtimeInput, ShowtimePricingTierUncheckedCreateWithoutShowtimeInput> | ShowtimePricingTierCreateWithoutShowtimeInput[] | ShowtimePricingTierUncheckedCreateWithoutShowtimeInput[]
    connectOrCreate?: ShowtimePricingTierCreateOrConnectWithoutShowtimeInput | ShowtimePricingTierCreateOrConnectWithoutShowtimeInput[]
    upsert?: ShowtimePricingTierUpsertWithWhereUniqueWithoutShowtimeInput | ShowtimePricingTierUpsertWithWhereUniqueWithoutShowtimeInput[]
    createMany?: ShowtimePricingTierCreateManyShowtimeInputEnvelope
    set?: ShowtimePricingTierWhereUniqueInput | ShowtimePricingTierWhereUniqueInput[]
    disconnect?: ShowtimePricingTierWhereUniqueInput | ShowtimePricingTierWhereUniqueInput[]
    delete?: ShowtimePricingTierWhereUniqueInput | ShowtimePricingTierWhereUniqueInput[]
    connect?: ShowtimePricingTierWhereUniqueInput | ShowtimePricingTierWhereUniqueInput[]
    update?: ShowtimePricingTierUpdateWithWhereUniqueWithoutShowtimeInput | ShowtimePricingTierUpdateWithWhereUniqueWithoutShowtimeInput[]
    updateMany?: ShowtimePricingTierUpdateManyWithWhereWithoutShowtimeInput | ShowtimePricingTierUpdateManyWithWhereWithoutShowtimeInput[]
    deleteMany?: ShowtimePricingTierScalarWhereInput | ShowtimePricingTierScalarWhereInput[]
  }

  export type BookingUpdateManyWithoutShowtimeNestedInput = {
    create?: XOR<BookingCreateWithoutShowtimeInput, BookingUncheckedCreateWithoutShowtimeInput> | BookingCreateWithoutShowtimeInput[] | BookingUncheckedCreateWithoutShowtimeInput[]
    connectOrCreate?: BookingCreateOrConnectWithoutShowtimeInput | BookingCreateOrConnectWithoutShowtimeInput[]
    upsert?: BookingUpsertWithWhereUniqueWithoutShowtimeInput | BookingUpsertWithWhereUniqueWithoutShowtimeInput[]
    createMany?: BookingCreateManyShowtimeInputEnvelope
    set?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
    disconnect?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
    delete?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
    connect?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
    update?: BookingUpdateWithWhereUniqueWithoutShowtimeInput | BookingUpdateWithWhereUniqueWithoutShowtimeInput[]
    updateMany?: BookingUpdateManyWithWhereWithoutShowtimeInput | BookingUpdateManyWithWhereWithoutShowtimeInput[]
    deleteMany?: BookingScalarWhereInput | BookingScalarWhereInput[]
  }

  export type ShowtimePricingTierUncheckedUpdateManyWithoutShowtimeNestedInput = {
    create?: XOR<ShowtimePricingTierCreateWithoutShowtimeInput, ShowtimePricingTierUncheckedCreateWithoutShowtimeInput> | ShowtimePricingTierCreateWithoutShowtimeInput[] | ShowtimePricingTierUncheckedCreateWithoutShowtimeInput[]
    connectOrCreate?: ShowtimePricingTierCreateOrConnectWithoutShowtimeInput | ShowtimePricingTierCreateOrConnectWithoutShowtimeInput[]
    upsert?: ShowtimePricingTierUpsertWithWhereUniqueWithoutShowtimeInput | ShowtimePricingTierUpsertWithWhereUniqueWithoutShowtimeInput[]
    createMany?: ShowtimePricingTierCreateManyShowtimeInputEnvelope
    set?: ShowtimePricingTierWhereUniqueInput | ShowtimePricingTierWhereUniqueInput[]
    disconnect?: ShowtimePricingTierWhereUniqueInput | ShowtimePricingTierWhereUniqueInput[]
    delete?: ShowtimePricingTierWhereUniqueInput | ShowtimePricingTierWhereUniqueInput[]
    connect?: ShowtimePricingTierWhereUniqueInput | ShowtimePricingTierWhereUniqueInput[]
    update?: ShowtimePricingTierUpdateWithWhereUniqueWithoutShowtimeInput | ShowtimePricingTierUpdateWithWhereUniqueWithoutShowtimeInput[]
    updateMany?: ShowtimePricingTierUpdateManyWithWhereWithoutShowtimeInput | ShowtimePricingTierUpdateManyWithWhereWithoutShowtimeInput[]
    deleteMany?: ShowtimePricingTierScalarWhereInput | ShowtimePricingTierScalarWhereInput[]
  }

  export type BookingUncheckedUpdateManyWithoutShowtimeNestedInput = {
    create?: XOR<BookingCreateWithoutShowtimeInput, BookingUncheckedCreateWithoutShowtimeInput> | BookingCreateWithoutShowtimeInput[] | BookingUncheckedCreateWithoutShowtimeInput[]
    connectOrCreate?: BookingCreateOrConnectWithoutShowtimeInput | BookingCreateOrConnectWithoutShowtimeInput[]
    upsert?: BookingUpsertWithWhereUniqueWithoutShowtimeInput | BookingUpsertWithWhereUniqueWithoutShowtimeInput[]
    createMany?: BookingCreateManyShowtimeInputEnvelope
    set?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
    disconnect?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
    delete?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
    connect?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
    update?: BookingUpdateWithWhereUniqueWithoutShowtimeInput | BookingUpdateWithWhereUniqueWithoutShowtimeInput[]
    updateMany?: BookingUpdateManyWithWhereWithoutShowtimeInput | BookingUpdateManyWithWhereWithoutShowtimeInput[]
    deleteMany?: BookingScalarWhereInput | BookingScalarWhereInput[]
  }

  export type ShowtimeCreateNestedOneWithoutPricingTiersInput = {
    create?: XOR<ShowtimeCreateWithoutPricingTiersInput, ShowtimeUncheckedCreateWithoutPricingTiersInput>
    connectOrCreate?: ShowtimeCreateOrConnectWithoutPricingTiersInput
    connect?: ShowtimeWhereUniqueInput
  }

  export type ShowtimeUpdateOneRequiredWithoutPricingTiersNestedInput = {
    create?: XOR<ShowtimeCreateWithoutPricingTiersInput, ShowtimeUncheckedCreateWithoutPricingTiersInput>
    connectOrCreate?: ShowtimeCreateOrConnectWithoutPricingTiersInput
    upsert?: ShowtimeUpsertWithoutPricingTiersInput
    connect?: ShowtimeWhereUniqueInput
    update?: XOR<XOR<ShowtimeUpdateToOneWithWhereWithoutPricingTiersInput, ShowtimeUpdateWithoutPricingTiersInput>, ShowtimeUncheckedUpdateWithoutPricingTiersInput>
  }

  export type UserCreateNestedOneWithoutBookingsInput = {
    create?: XOR<UserCreateWithoutBookingsInput, UserUncheckedCreateWithoutBookingsInput>
    connectOrCreate?: UserCreateOrConnectWithoutBookingsInput
    connect?: UserWhereUniqueInput
  }

  export type ShowtimeCreateNestedOneWithoutBookingsInput = {
    create?: XOR<ShowtimeCreateWithoutBookingsInput, ShowtimeUncheckedCreateWithoutBookingsInput>
    connectOrCreate?: ShowtimeCreateOrConnectWithoutBookingsInput
    connect?: ShowtimeWhereUniqueInput
  }

  export type BookingTicketCreateNestedManyWithoutBookingInput = {
    create?: XOR<BookingTicketCreateWithoutBookingInput, BookingTicketUncheckedCreateWithoutBookingInput> | BookingTicketCreateWithoutBookingInput[] | BookingTicketUncheckedCreateWithoutBookingInput[]
    connectOrCreate?: BookingTicketCreateOrConnectWithoutBookingInput | BookingTicketCreateOrConnectWithoutBookingInput[]
    createMany?: BookingTicketCreateManyBookingInputEnvelope
    connect?: BookingTicketWhereUniqueInput | BookingTicketWhereUniqueInput[]
  }

  export type BookingAuditCreateNestedManyWithoutBookingInput = {
    create?: XOR<BookingAuditCreateWithoutBookingInput, BookingAuditUncheckedCreateWithoutBookingInput> | BookingAuditCreateWithoutBookingInput[] | BookingAuditUncheckedCreateWithoutBookingInput[]
    connectOrCreate?: BookingAuditCreateOrConnectWithoutBookingInput | BookingAuditCreateOrConnectWithoutBookingInput[]
    createMany?: BookingAuditCreateManyBookingInputEnvelope
    connect?: BookingAuditWhereUniqueInput | BookingAuditWhereUniqueInput[]
  }

  export type SettlementTransactionCreateNestedManyWithoutBookingInput = {
    create?: XOR<SettlementTransactionCreateWithoutBookingInput, SettlementTransactionUncheckedCreateWithoutBookingInput> | SettlementTransactionCreateWithoutBookingInput[] | SettlementTransactionUncheckedCreateWithoutBookingInput[]
    connectOrCreate?: SettlementTransactionCreateOrConnectWithoutBookingInput | SettlementTransactionCreateOrConnectWithoutBookingInput[]
    createMany?: SettlementTransactionCreateManyBookingInputEnvelope
    connect?: SettlementTransactionWhereUniqueInput | SettlementTransactionWhereUniqueInput[]
  }

  export type BookingTicketUncheckedCreateNestedManyWithoutBookingInput = {
    create?: XOR<BookingTicketCreateWithoutBookingInput, BookingTicketUncheckedCreateWithoutBookingInput> | BookingTicketCreateWithoutBookingInput[] | BookingTicketUncheckedCreateWithoutBookingInput[]
    connectOrCreate?: BookingTicketCreateOrConnectWithoutBookingInput | BookingTicketCreateOrConnectWithoutBookingInput[]
    createMany?: BookingTicketCreateManyBookingInputEnvelope
    connect?: BookingTicketWhereUniqueInput | BookingTicketWhereUniqueInput[]
  }

  export type BookingAuditUncheckedCreateNestedManyWithoutBookingInput = {
    create?: XOR<BookingAuditCreateWithoutBookingInput, BookingAuditUncheckedCreateWithoutBookingInput> | BookingAuditCreateWithoutBookingInput[] | BookingAuditUncheckedCreateWithoutBookingInput[]
    connectOrCreate?: BookingAuditCreateOrConnectWithoutBookingInput | BookingAuditCreateOrConnectWithoutBookingInput[]
    createMany?: BookingAuditCreateManyBookingInputEnvelope
    connect?: BookingAuditWhereUniqueInput | BookingAuditWhereUniqueInput[]
  }

  export type SettlementTransactionUncheckedCreateNestedManyWithoutBookingInput = {
    create?: XOR<SettlementTransactionCreateWithoutBookingInput, SettlementTransactionUncheckedCreateWithoutBookingInput> | SettlementTransactionCreateWithoutBookingInput[] | SettlementTransactionUncheckedCreateWithoutBookingInput[]
    connectOrCreate?: SettlementTransactionCreateOrConnectWithoutBookingInput | SettlementTransactionCreateOrConnectWithoutBookingInput[]
    createMany?: SettlementTransactionCreateManyBookingInputEnvelope
    connect?: SettlementTransactionWhereUniqueInput | SettlementTransactionWhereUniqueInput[]
  }

  export type EnumBookingStatusFieldUpdateOperationsInput = {
    set?: $Enums.BookingStatus
  }

  export type UserUpdateOneWithoutBookingsNestedInput = {
    create?: XOR<UserCreateWithoutBookingsInput, UserUncheckedCreateWithoutBookingsInput>
    connectOrCreate?: UserCreateOrConnectWithoutBookingsInput
    upsert?: UserUpsertWithoutBookingsInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutBookingsInput, UserUpdateWithoutBookingsInput>, UserUncheckedUpdateWithoutBookingsInput>
  }

  export type ShowtimeUpdateOneRequiredWithoutBookingsNestedInput = {
    create?: XOR<ShowtimeCreateWithoutBookingsInput, ShowtimeUncheckedCreateWithoutBookingsInput>
    connectOrCreate?: ShowtimeCreateOrConnectWithoutBookingsInput
    upsert?: ShowtimeUpsertWithoutBookingsInput
    connect?: ShowtimeWhereUniqueInput
    update?: XOR<XOR<ShowtimeUpdateToOneWithWhereWithoutBookingsInput, ShowtimeUpdateWithoutBookingsInput>, ShowtimeUncheckedUpdateWithoutBookingsInput>
  }

  export type BookingTicketUpdateManyWithoutBookingNestedInput = {
    create?: XOR<BookingTicketCreateWithoutBookingInput, BookingTicketUncheckedCreateWithoutBookingInput> | BookingTicketCreateWithoutBookingInput[] | BookingTicketUncheckedCreateWithoutBookingInput[]
    connectOrCreate?: BookingTicketCreateOrConnectWithoutBookingInput | BookingTicketCreateOrConnectWithoutBookingInput[]
    upsert?: BookingTicketUpsertWithWhereUniqueWithoutBookingInput | BookingTicketUpsertWithWhereUniqueWithoutBookingInput[]
    createMany?: BookingTicketCreateManyBookingInputEnvelope
    set?: BookingTicketWhereUniqueInput | BookingTicketWhereUniqueInput[]
    disconnect?: BookingTicketWhereUniqueInput | BookingTicketWhereUniqueInput[]
    delete?: BookingTicketWhereUniqueInput | BookingTicketWhereUniqueInput[]
    connect?: BookingTicketWhereUniqueInput | BookingTicketWhereUniqueInput[]
    update?: BookingTicketUpdateWithWhereUniqueWithoutBookingInput | BookingTicketUpdateWithWhereUniqueWithoutBookingInput[]
    updateMany?: BookingTicketUpdateManyWithWhereWithoutBookingInput | BookingTicketUpdateManyWithWhereWithoutBookingInput[]
    deleteMany?: BookingTicketScalarWhereInput | BookingTicketScalarWhereInput[]
  }

  export type BookingAuditUpdateManyWithoutBookingNestedInput = {
    create?: XOR<BookingAuditCreateWithoutBookingInput, BookingAuditUncheckedCreateWithoutBookingInput> | BookingAuditCreateWithoutBookingInput[] | BookingAuditUncheckedCreateWithoutBookingInput[]
    connectOrCreate?: BookingAuditCreateOrConnectWithoutBookingInput | BookingAuditCreateOrConnectWithoutBookingInput[]
    upsert?: BookingAuditUpsertWithWhereUniqueWithoutBookingInput | BookingAuditUpsertWithWhereUniqueWithoutBookingInput[]
    createMany?: BookingAuditCreateManyBookingInputEnvelope
    set?: BookingAuditWhereUniqueInput | BookingAuditWhereUniqueInput[]
    disconnect?: BookingAuditWhereUniqueInput | BookingAuditWhereUniqueInput[]
    delete?: BookingAuditWhereUniqueInput | BookingAuditWhereUniqueInput[]
    connect?: BookingAuditWhereUniqueInput | BookingAuditWhereUniqueInput[]
    update?: BookingAuditUpdateWithWhereUniqueWithoutBookingInput | BookingAuditUpdateWithWhereUniqueWithoutBookingInput[]
    updateMany?: BookingAuditUpdateManyWithWhereWithoutBookingInput | BookingAuditUpdateManyWithWhereWithoutBookingInput[]
    deleteMany?: BookingAuditScalarWhereInput | BookingAuditScalarWhereInput[]
  }

  export type SettlementTransactionUpdateManyWithoutBookingNestedInput = {
    create?: XOR<SettlementTransactionCreateWithoutBookingInput, SettlementTransactionUncheckedCreateWithoutBookingInput> | SettlementTransactionCreateWithoutBookingInput[] | SettlementTransactionUncheckedCreateWithoutBookingInput[]
    connectOrCreate?: SettlementTransactionCreateOrConnectWithoutBookingInput | SettlementTransactionCreateOrConnectWithoutBookingInput[]
    upsert?: SettlementTransactionUpsertWithWhereUniqueWithoutBookingInput | SettlementTransactionUpsertWithWhereUniqueWithoutBookingInput[]
    createMany?: SettlementTransactionCreateManyBookingInputEnvelope
    set?: SettlementTransactionWhereUniqueInput | SettlementTransactionWhereUniqueInput[]
    disconnect?: SettlementTransactionWhereUniqueInput | SettlementTransactionWhereUniqueInput[]
    delete?: SettlementTransactionWhereUniqueInput | SettlementTransactionWhereUniqueInput[]
    connect?: SettlementTransactionWhereUniqueInput | SettlementTransactionWhereUniqueInput[]
    update?: SettlementTransactionUpdateWithWhereUniqueWithoutBookingInput | SettlementTransactionUpdateWithWhereUniqueWithoutBookingInput[]
    updateMany?: SettlementTransactionUpdateManyWithWhereWithoutBookingInput | SettlementTransactionUpdateManyWithWhereWithoutBookingInput[]
    deleteMany?: SettlementTransactionScalarWhereInput | SettlementTransactionScalarWhereInput[]
  }

  export type BookingTicketUncheckedUpdateManyWithoutBookingNestedInput = {
    create?: XOR<BookingTicketCreateWithoutBookingInput, BookingTicketUncheckedCreateWithoutBookingInput> | BookingTicketCreateWithoutBookingInput[] | BookingTicketUncheckedCreateWithoutBookingInput[]
    connectOrCreate?: BookingTicketCreateOrConnectWithoutBookingInput | BookingTicketCreateOrConnectWithoutBookingInput[]
    upsert?: BookingTicketUpsertWithWhereUniqueWithoutBookingInput | BookingTicketUpsertWithWhereUniqueWithoutBookingInput[]
    createMany?: BookingTicketCreateManyBookingInputEnvelope
    set?: BookingTicketWhereUniqueInput | BookingTicketWhereUniqueInput[]
    disconnect?: BookingTicketWhereUniqueInput | BookingTicketWhereUniqueInput[]
    delete?: BookingTicketWhereUniqueInput | BookingTicketWhereUniqueInput[]
    connect?: BookingTicketWhereUniqueInput | BookingTicketWhereUniqueInput[]
    update?: BookingTicketUpdateWithWhereUniqueWithoutBookingInput | BookingTicketUpdateWithWhereUniqueWithoutBookingInput[]
    updateMany?: BookingTicketUpdateManyWithWhereWithoutBookingInput | BookingTicketUpdateManyWithWhereWithoutBookingInput[]
    deleteMany?: BookingTicketScalarWhereInput | BookingTicketScalarWhereInput[]
  }

  export type BookingAuditUncheckedUpdateManyWithoutBookingNestedInput = {
    create?: XOR<BookingAuditCreateWithoutBookingInput, BookingAuditUncheckedCreateWithoutBookingInput> | BookingAuditCreateWithoutBookingInput[] | BookingAuditUncheckedCreateWithoutBookingInput[]
    connectOrCreate?: BookingAuditCreateOrConnectWithoutBookingInput | BookingAuditCreateOrConnectWithoutBookingInput[]
    upsert?: BookingAuditUpsertWithWhereUniqueWithoutBookingInput | BookingAuditUpsertWithWhereUniqueWithoutBookingInput[]
    createMany?: BookingAuditCreateManyBookingInputEnvelope
    set?: BookingAuditWhereUniqueInput | BookingAuditWhereUniqueInput[]
    disconnect?: BookingAuditWhereUniqueInput | BookingAuditWhereUniqueInput[]
    delete?: BookingAuditWhereUniqueInput | BookingAuditWhereUniqueInput[]
    connect?: BookingAuditWhereUniqueInput | BookingAuditWhereUniqueInput[]
    update?: BookingAuditUpdateWithWhereUniqueWithoutBookingInput | BookingAuditUpdateWithWhereUniqueWithoutBookingInput[]
    updateMany?: BookingAuditUpdateManyWithWhereWithoutBookingInput | BookingAuditUpdateManyWithWhereWithoutBookingInput[]
    deleteMany?: BookingAuditScalarWhereInput | BookingAuditScalarWhereInput[]
  }

  export type SettlementTransactionUncheckedUpdateManyWithoutBookingNestedInput = {
    create?: XOR<SettlementTransactionCreateWithoutBookingInput, SettlementTransactionUncheckedCreateWithoutBookingInput> | SettlementTransactionCreateWithoutBookingInput[] | SettlementTransactionUncheckedCreateWithoutBookingInput[]
    connectOrCreate?: SettlementTransactionCreateOrConnectWithoutBookingInput | SettlementTransactionCreateOrConnectWithoutBookingInput[]
    upsert?: SettlementTransactionUpsertWithWhereUniqueWithoutBookingInput | SettlementTransactionUpsertWithWhereUniqueWithoutBookingInput[]
    createMany?: SettlementTransactionCreateManyBookingInputEnvelope
    set?: SettlementTransactionWhereUniqueInput | SettlementTransactionWhereUniqueInput[]
    disconnect?: SettlementTransactionWhereUniqueInput | SettlementTransactionWhereUniqueInput[]
    delete?: SettlementTransactionWhereUniqueInput | SettlementTransactionWhereUniqueInput[]
    connect?: SettlementTransactionWhereUniqueInput | SettlementTransactionWhereUniqueInput[]
    update?: SettlementTransactionUpdateWithWhereUniqueWithoutBookingInput | SettlementTransactionUpdateWithWhereUniqueWithoutBookingInput[]
    updateMany?: SettlementTransactionUpdateManyWithWhereWithoutBookingInput | SettlementTransactionUpdateManyWithWhereWithoutBookingInput[]
    deleteMany?: SettlementTransactionScalarWhereInput | SettlementTransactionScalarWhereInput[]
  }

  export type BookingCreateNestedOneWithoutTicketsInput = {
    create?: XOR<BookingCreateWithoutTicketsInput, BookingUncheckedCreateWithoutTicketsInput>
    connectOrCreate?: BookingCreateOrConnectWithoutTicketsInput
    connect?: BookingWhereUniqueInput
  }

  export type BookingUpdateOneRequiredWithoutTicketsNestedInput = {
    create?: XOR<BookingCreateWithoutTicketsInput, BookingUncheckedCreateWithoutTicketsInput>
    connectOrCreate?: BookingCreateOrConnectWithoutTicketsInput
    upsert?: BookingUpsertWithoutTicketsInput
    connect?: BookingWhereUniqueInput
    update?: XOR<XOR<BookingUpdateToOneWithWhereWithoutTicketsInput, BookingUpdateWithoutTicketsInput>, BookingUncheckedUpdateWithoutTicketsInput>
  }

  export type BookingCreateNestedOneWithoutAuditLogInput = {
    create?: XOR<BookingCreateWithoutAuditLogInput, BookingUncheckedCreateWithoutAuditLogInput>
    connectOrCreate?: BookingCreateOrConnectWithoutAuditLogInput
    connect?: BookingWhereUniqueInput
  }

  export type BookingUpdateOneRequiredWithoutAuditLogNestedInput = {
    create?: XOR<BookingCreateWithoutAuditLogInput, BookingUncheckedCreateWithoutAuditLogInput>
    connectOrCreate?: BookingCreateOrConnectWithoutAuditLogInput
    upsert?: BookingUpsertWithoutAuditLogInput
    connect?: BookingWhereUniqueInput
    update?: XOR<XOR<BookingUpdateToOneWithWhereWithoutAuditLogInput, BookingUpdateWithoutAuditLogInput>, BookingUncheckedUpdateWithoutAuditLogInput>
  }

  export type BookingCreateNestedOneWithoutSettlementsInput = {
    create?: XOR<BookingCreateWithoutSettlementsInput, BookingUncheckedCreateWithoutSettlementsInput>
    connectOrCreate?: BookingCreateOrConnectWithoutSettlementsInput
    connect?: BookingWhereUniqueInput
  }

  export type EnumSettlementStatusFieldUpdateOperationsInput = {
    set?: $Enums.SettlementStatus
  }

  export type BookingUpdateOneWithoutSettlementsNestedInput = {
    create?: XOR<BookingCreateWithoutSettlementsInput, BookingUncheckedCreateWithoutSettlementsInput>
    connectOrCreate?: BookingCreateOrConnectWithoutSettlementsInput
    upsert?: BookingUpsertWithoutSettlementsInput
    disconnect?: BookingWhereInput | boolean
    delete?: BookingWhereInput | boolean
    connect?: BookingWhereUniqueInput
    update?: XOR<XOR<BookingUpdateToOneWithWhereWithoutSettlementsInput, BookingUpdateWithoutSettlementsInput>, BookingUncheckedUpdateWithoutSettlementsInput>
  }

  export type NotificationCampaignCreateNestedManyWithoutSegmentInput = {
    create?: XOR<NotificationCampaignCreateWithoutSegmentInput, NotificationCampaignUncheckedCreateWithoutSegmentInput> | NotificationCampaignCreateWithoutSegmentInput[] | NotificationCampaignUncheckedCreateWithoutSegmentInput[]
    connectOrCreate?: NotificationCampaignCreateOrConnectWithoutSegmentInput | NotificationCampaignCreateOrConnectWithoutSegmentInput[]
    createMany?: NotificationCampaignCreateManySegmentInputEnvelope
    connect?: NotificationCampaignWhereUniqueInput | NotificationCampaignWhereUniqueInput[]
  }

  export type NotificationCampaignUncheckedCreateNestedManyWithoutSegmentInput = {
    create?: XOR<NotificationCampaignCreateWithoutSegmentInput, NotificationCampaignUncheckedCreateWithoutSegmentInput> | NotificationCampaignCreateWithoutSegmentInput[] | NotificationCampaignUncheckedCreateWithoutSegmentInput[]
    connectOrCreate?: NotificationCampaignCreateOrConnectWithoutSegmentInput | NotificationCampaignCreateOrConnectWithoutSegmentInput[]
    createMany?: NotificationCampaignCreateManySegmentInputEnvelope
    connect?: NotificationCampaignWhereUniqueInput | NotificationCampaignWhereUniqueInput[]
  }

  export type NotificationCampaignUpdateManyWithoutSegmentNestedInput = {
    create?: XOR<NotificationCampaignCreateWithoutSegmentInput, NotificationCampaignUncheckedCreateWithoutSegmentInput> | NotificationCampaignCreateWithoutSegmentInput[] | NotificationCampaignUncheckedCreateWithoutSegmentInput[]
    connectOrCreate?: NotificationCampaignCreateOrConnectWithoutSegmentInput | NotificationCampaignCreateOrConnectWithoutSegmentInput[]
    upsert?: NotificationCampaignUpsertWithWhereUniqueWithoutSegmentInput | NotificationCampaignUpsertWithWhereUniqueWithoutSegmentInput[]
    createMany?: NotificationCampaignCreateManySegmentInputEnvelope
    set?: NotificationCampaignWhereUniqueInput | NotificationCampaignWhereUniqueInput[]
    disconnect?: NotificationCampaignWhereUniqueInput | NotificationCampaignWhereUniqueInput[]
    delete?: NotificationCampaignWhereUniqueInput | NotificationCampaignWhereUniqueInput[]
    connect?: NotificationCampaignWhereUniqueInput | NotificationCampaignWhereUniqueInput[]
    update?: NotificationCampaignUpdateWithWhereUniqueWithoutSegmentInput | NotificationCampaignUpdateWithWhereUniqueWithoutSegmentInput[]
    updateMany?: NotificationCampaignUpdateManyWithWhereWithoutSegmentInput | NotificationCampaignUpdateManyWithWhereWithoutSegmentInput[]
    deleteMany?: NotificationCampaignScalarWhereInput | NotificationCampaignScalarWhereInput[]
  }

  export type NotificationCampaignUncheckedUpdateManyWithoutSegmentNestedInput = {
    create?: XOR<NotificationCampaignCreateWithoutSegmentInput, NotificationCampaignUncheckedCreateWithoutSegmentInput> | NotificationCampaignCreateWithoutSegmentInput[] | NotificationCampaignUncheckedCreateWithoutSegmentInput[]
    connectOrCreate?: NotificationCampaignCreateOrConnectWithoutSegmentInput | NotificationCampaignCreateOrConnectWithoutSegmentInput[]
    upsert?: NotificationCampaignUpsertWithWhereUniqueWithoutSegmentInput | NotificationCampaignUpsertWithWhereUniqueWithoutSegmentInput[]
    createMany?: NotificationCampaignCreateManySegmentInputEnvelope
    set?: NotificationCampaignWhereUniqueInput | NotificationCampaignWhereUniqueInput[]
    disconnect?: NotificationCampaignWhereUniqueInput | NotificationCampaignWhereUniqueInput[]
    delete?: NotificationCampaignWhereUniqueInput | NotificationCampaignWhereUniqueInput[]
    connect?: NotificationCampaignWhereUniqueInput | NotificationCampaignWhereUniqueInput[]
    update?: NotificationCampaignUpdateWithWhereUniqueWithoutSegmentInput | NotificationCampaignUpdateWithWhereUniqueWithoutSegmentInput[]
    updateMany?: NotificationCampaignUpdateManyWithWhereWithoutSegmentInput | NotificationCampaignUpdateManyWithWhereWithoutSegmentInput[]
    deleteMany?: NotificationCampaignScalarWhereInput | NotificationCampaignScalarWhereInput[]
  }

  export type NotificationSegmentCreateNestedOneWithoutCampaignsInput = {
    create?: XOR<NotificationSegmentCreateWithoutCampaignsInput, NotificationSegmentUncheckedCreateWithoutCampaignsInput>
    connectOrCreate?: NotificationSegmentCreateOrConnectWithoutCampaignsInput
    connect?: NotificationSegmentWhereUniqueInput
  }

  export type EnumCampaignStatusFieldUpdateOperationsInput = {
    set?: $Enums.CampaignStatus
  }

  export type NotificationSegmentUpdateOneRequiredWithoutCampaignsNestedInput = {
    create?: XOR<NotificationSegmentCreateWithoutCampaignsInput, NotificationSegmentUncheckedCreateWithoutCampaignsInput>
    connectOrCreate?: NotificationSegmentCreateOrConnectWithoutCampaignsInput
    upsert?: NotificationSegmentUpsertWithoutCampaignsInput
    connect?: NotificationSegmentWhereUniqueInput
    update?: XOR<XOR<NotificationSegmentUpdateToOneWithWhereWithoutCampaignsInput, NotificationSegmentUpdateWithoutCampaignsInput>, NotificationSegmentUncheckedUpdateWithoutCampaignsInput>
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedEnumAdminStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.AdminStatus | EnumAdminStatusFieldRefInput<$PrismaModel>
    in?: $Enums.AdminStatus[]
    notIn?: $Enums.AdminStatus[]
    not?: NestedEnumAdminStatusFilter<$PrismaModel> | $Enums.AdminStatus
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type NestedEnumAdminStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.AdminStatus | EnumAdminStatusFieldRefInput<$PrismaModel>
    in?: $Enums.AdminStatus[]
    notIn?: $Enums.AdminStatus[]
    not?: NestedEnumAdminStatusWithAggregatesFilter<$PrismaModel> | $Enums.AdminStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumAdminStatusFilter<$PrismaModel>
    _max?: NestedEnumAdminStatusFilter<$PrismaModel>
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type NestedEnumAdminRoleFilter<$PrismaModel = never> = {
    equals?: $Enums.AdminRole | EnumAdminRoleFieldRefInput<$PrismaModel>
    in?: $Enums.AdminRole[]
    notIn?: $Enums.AdminRole[]
    not?: NestedEnumAdminRoleFilter<$PrismaModel> | $Enums.AdminRole
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedEnumAdminRoleWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.AdminRole | EnumAdminRoleFieldRefInput<$PrismaModel>
    in?: $Enums.AdminRole[]
    notIn?: $Enums.AdminRole[]
    not?: NestedEnumAdminRoleWithAggregatesFilter<$PrismaModel> | $Enums.AdminRole
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumAdminRoleFilter<$PrismaModel>
    _max?: NestedEnumAdminRoleFilter<$PrismaModel>
  }

  export type NestedEnumMovieStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.MovieStatus | EnumMovieStatusFieldRefInput<$PrismaModel>
    in?: $Enums.MovieStatus[]
    notIn?: $Enums.MovieStatus[]
    not?: NestedEnumMovieStatusFilter<$PrismaModel> | $Enums.MovieStatus
  }

  export type NestedDecimalNullableFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
  }

  export type NestedEnumMovieStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.MovieStatus | EnumMovieStatusFieldRefInput<$PrismaModel>
    in?: $Enums.MovieStatus[]
    notIn?: $Enums.MovieStatus[]
    not?: NestedEnumMovieStatusWithAggregatesFilter<$PrismaModel> | $Enums.MovieStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumMovieStatusFilter<$PrismaModel>
    _max?: NestedEnumMovieStatusFilter<$PrismaModel>
  }

  export type NestedIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type NestedDecimalNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedDecimalNullableFilter<$PrismaModel>
    _sum?: NestedDecimalNullableFilter<$PrismaModel>
    _min?: NestedDecimalNullableFilter<$PrismaModel>
    _max?: NestedDecimalNullableFilter<$PrismaModel>
  }
  export type NestedJsonNullableFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<NestedJsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<NestedJsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type NestedJsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue
    lte?: InputJsonValue
    gt?: InputJsonValue
    gte?: InputJsonValue
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }
  export type NestedJsonFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<NestedJsonFilterBase<$PrismaModel>>, Exclude<keyof Required<NestedJsonFilterBase<$PrismaModel>>, 'path'>>,
        Required<NestedJsonFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<NestedJsonFilterBase<$PrismaModel>>, 'path'>>

  export type NestedJsonFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue
    lte?: InputJsonValue
    gt?: InputJsonValue
    gte?: InputJsonValue
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type NestedDecimalFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[]
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[]
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
  }

  export type NestedEnumShowtimeStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.ShowtimeStatus | EnumShowtimeStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ShowtimeStatus[]
    notIn?: $Enums.ShowtimeStatus[]
    not?: NestedEnumShowtimeStatusFilter<$PrismaModel> | $Enums.ShowtimeStatus
  }

  export type NestedDecimalWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[]
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[]
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedDecimalFilter<$PrismaModel>
    _sum?: NestedDecimalFilter<$PrismaModel>
    _min?: NestedDecimalFilter<$PrismaModel>
    _max?: NestedDecimalFilter<$PrismaModel>
  }

  export type NestedEnumShowtimeStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ShowtimeStatus | EnumShowtimeStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ShowtimeStatus[]
    notIn?: $Enums.ShowtimeStatus[]
    not?: NestedEnumShowtimeStatusWithAggregatesFilter<$PrismaModel> | $Enums.ShowtimeStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumShowtimeStatusFilter<$PrismaModel>
    _max?: NestedEnumShowtimeStatusFilter<$PrismaModel>
  }

  export type NestedEnumBookingStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.BookingStatus | EnumBookingStatusFieldRefInput<$PrismaModel>
    in?: $Enums.BookingStatus[]
    notIn?: $Enums.BookingStatus[]
    not?: NestedEnumBookingStatusFilter<$PrismaModel> | $Enums.BookingStatus
  }

  export type NestedEnumBookingStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.BookingStatus | EnumBookingStatusFieldRefInput<$PrismaModel>
    in?: $Enums.BookingStatus[]
    notIn?: $Enums.BookingStatus[]
    not?: NestedEnumBookingStatusWithAggregatesFilter<$PrismaModel> | $Enums.BookingStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumBookingStatusFilter<$PrismaModel>
    _max?: NestedEnumBookingStatusFilter<$PrismaModel>
  }

  export type NestedEnumSettlementStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.SettlementStatus | EnumSettlementStatusFieldRefInput<$PrismaModel>
    in?: $Enums.SettlementStatus[]
    notIn?: $Enums.SettlementStatus[]
    not?: NestedEnumSettlementStatusFilter<$PrismaModel> | $Enums.SettlementStatus
  }

  export type NestedEnumSettlementStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.SettlementStatus | EnumSettlementStatusFieldRefInput<$PrismaModel>
    in?: $Enums.SettlementStatus[]
    notIn?: $Enums.SettlementStatus[]
    not?: NestedEnumSettlementStatusWithAggregatesFilter<$PrismaModel> | $Enums.SettlementStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumSettlementStatusFilter<$PrismaModel>
    _max?: NestedEnumSettlementStatusFilter<$PrismaModel>
  }

  export type NestedEnumCampaignStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.CampaignStatus | EnumCampaignStatusFieldRefInput<$PrismaModel>
    in?: $Enums.CampaignStatus[]
    notIn?: $Enums.CampaignStatus[]
    not?: NestedEnumCampaignStatusFilter<$PrismaModel> | $Enums.CampaignStatus
  }

  export type NestedEnumCampaignStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.CampaignStatus | EnumCampaignStatusFieldRefInput<$PrismaModel>
    in?: $Enums.CampaignStatus[]
    notIn?: $Enums.CampaignStatus[]
    not?: NestedEnumCampaignStatusWithAggregatesFilter<$PrismaModel> | $Enums.CampaignStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumCampaignStatusFilter<$PrismaModel>
    _max?: NestedEnumCampaignStatusFilter<$PrismaModel>
  }

  export type AdminUserCreateWithoutUserInput = {
    id?: string
    status?: $Enums.AdminStatus
    lastActiveAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    roles?: AdminUserRoleCreateNestedManyWithoutAdminUserInput
  }

  export type AdminUserUncheckedCreateWithoutUserInput = {
    id?: string
    status?: $Enums.AdminStatus
    lastActiveAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    roles?: AdminUserRoleUncheckedCreateNestedManyWithoutAdminUserInput
  }

  export type AdminUserCreateOrConnectWithoutUserInput = {
    where: AdminUserWhereUniqueInput
    create: XOR<AdminUserCreateWithoutUserInput, AdminUserUncheckedCreateWithoutUserInput>
  }

  export type SessionCreateWithoutUserInput = {
    id?: string
    refreshToken: string
    expiresAt: Date | string
    createdAt?: Date | string
    revokedAt?: Date | string | null
    ipAddress?: string | null
    userAgent?: string | null
  }

  export type SessionUncheckedCreateWithoutUserInput = {
    id?: string
    refreshToken: string
    expiresAt: Date | string
    createdAt?: Date | string
    revokedAt?: Date | string | null
    ipAddress?: string | null
    userAgent?: string | null
  }

  export type SessionCreateOrConnectWithoutUserInput = {
    where: SessionWhereUniqueInput
    create: XOR<SessionCreateWithoutUserInput, SessionUncheckedCreateWithoutUserInput>
  }

  export type SessionCreateManyUserInputEnvelope = {
    data: SessionCreateManyUserInput | SessionCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type BookingCreateWithoutUserInput = {
    id?: string
    reference: string
    purchaserEmail: string
    purchaserName: string
    status?: $Enums.BookingStatus
    totalAmount: Decimal | DecimalJsLike | number | string
    currency?: string
    purchasedAt?: Date | string
    movieTitle: string
    showtime: ShowtimeCreateNestedOneWithoutBookingsInput
    tickets?: BookingTicketCreateNestedManyWithoutBookingInput
    auditLog?: BookingAuditCreateNestedManyWithoutBookingInput
    settlements?: SettlementTransactionCreateNestedManyWithoutBookingInput
  }

  export type BookingUncheckedCreateWithoutUserInput = {
    id?: string
    reference: string
    showtimeId: string
    purchaserEmail: string
    purchaserName: string
    status?: $Enums.BookingStatus
    totalAmount: Decimal | DecimalJsLike | number | string
    currency?: string
    purchasedAt?: Date | string
    movieTitle: string
    tickets?: BookingTicketUncheckedCreateNestedManyWithoutBookingInput
    auditLog?: BookingAuditUncheckedCreateNestedManyWithoutBookingInput
    settlements?: SettlementTransactionUncheckedCreateNestedManyWithoutBookingInput
  }

  export type BookingCreateOrConnectWithoutUserInput = {
    where: BookingWhereUniqueInput
    create: XOR<BookingCreateWithoutUserInput, BookingUncheckedCreateWithoutUserInput>
  }

  export type BookingCreateManyUserInputEnvelope = {
    data: BookingCreateManyUserInput | BookingCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type PasswordResetTokenCreateWithoutUserInput = {
    id?: string
    otp: string
    expiresAt: Date | string
    usedAt?: Date | string | null
    createdAt?: Date | string
  }

  export type PasswordResetTokenUncheckedCreateWithoutUserInput = {
    id?: string
    otp: string
    expiresAt: Date | string
    usedAt?: Date | string | null
    createdAt?: Date | string
  }

  export type PasswordResetTokenCreateOrConnectWithoutUserInput = {
    where: PasswordResetTokenWhereUniqueInput
    create: XOR<PasswordResetTokenCreateWithoutUserInput, PasswordResetTokenUncheckedCreateWithoutUserInput>
  }

  export type PasswordResetTokenCreateManyUserInputEnvelope = {
    data: PasswordResetTokenCreateManyUserInput | PasswordResetTokenCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type AdminUserUpsertWithoutUserInput = {
    update: XOR<AdminUserUpdateWithoutUserInput, AdminUserUncheckedUpdateWithoutUserInput>
    create: XOR<AdminUserCreateWithoutUserInput, AdminUserUncheckedCreateWithoutUserInput>
    where?: AdminUserWhereInput
  }

  export type AdminUserUpdateToOneWithWhereWithoutUserInput = {
    where?: AdminUserWhereInput
    data: XOR<AdminUserUpdateWithoutUserInput, AdminUserUncheckedUpdateWithoutUserInput>
  }

  export type AdminUserUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumAdminStatusFieldUpdateOperationsInput | $Enums.AdminStatus
    lastActiveAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    roles?: AdminUserRoleUpdateManyWithoutAdminUserNestedInput
  }

  export type AdminUserUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumAdminStatusFieldUpdateOperationsInput | $Enums.AdminStatus
    lastActiveAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    roles?: AdminUserRoleUncheckedUpdateManyWithoutAdminUserNestedInput
  }

  export type SessionUpsertWithWhereUniqueWithoutUserInput = {
    where: SessionWhereUniqueInput
    update: XOR<SessionUpdateWithoutUserInput, SessionUncheckedUpdateWithoutUserInput>
    create: XOR<SessionCreateWithoutUserInput, SessionUncheckedCreateWithoutUserInput>
  }

  export type SessionUpdateWithWhereUniqueWithoutUserInput = {
    where: SessionWhereUniqueInput
    data: XOR<SessionUpdateWithoutUserInput, SessionUncheckedUpdateWithoutUserInput>
  }

  export type SessionUpdateManyWithWhereWithoutUserInput = {
    where: SessionScalarWhereInput
    data: XOR<SessionUpdateManyMutationInput, SessionUncheckedUpdateManyWithoutUserInput>
  }

  export type SessionScalarWhereInput = {
    AND?: SessionScalarWhereInput | SessionScalarWhereInput[]
    OR?: SessionScalarWhereInput[]
    NOT?: SessionScalarWhereInput | SessionScalarWhereInput[]
    id?: StringFilter<"Session"> | string
    userId?: StringFilter<"Session"> | string
    refreshToken?: StringFilter<"Session"> | string
    expiresAt?: DateTimeFilter<"Session"> | Date | string
    createdAt?: DateTimeFilter<"Session"> | Date | string
    revokedAt?: DateTimeNullableFilter<"Session"> | Date | string | null
    ipAddress?: StringNullableFilter<"Session"> | string | null
    userAgent?: StringNullableFilter<"Session"> | string | null
  }

  export type BookingUpsertWithWhereUniqueWithoutUserInput = {
    where: BookingWhereUniqueInput
    update: XOR<BookingUpdateWithoutUserInput, BookingUncheckedUpdateWithoutUserInput>
    create: XOR<BookingCreateWithoutUserInput, BookingUncheckedCreateWithoutUserInput>
  }

  export type BookingUpdateWithWhereUniqueWithoutUserInput = {
    where: BookingWhereUniqueInput
    data: XOR<BookingUpdateWithoutUserInput, BookingUncheckedUpdateWithoutUserInput>
  }

  export type BookingUpdateManyWithWhereWithoutUserInput = {
    where: BookingScalarWhereInput
    data: XOR<BookingUpdateManyMutationInput, BookingUncheckedUpdateManyWithoutUserInput>
  }

  export type BookingScalarWhereInput = {
    AND?: BookingScalarWhereInput | BookingScalarWhereInput[]
    OR?: BookingScalarWhereInput[]
    NOT?: BookingScalarWhereInput | BookingScalarWhereInput[]
    id?: StringFilter<"Booking"> | string
    reference?: StringFilter<"Booking"> | string
    showtimeId?: StringFilter<"Booking"> | string
    userId?: StringNullableFilter<"Booking"> | string | null
    purchaserEmail?: StringFilter<"Booking"> | string
    purchaserName?: StringFilter<"Booking"> | string
    status?: EnumBookingStatusFilter<"Booking"> | $Enums.BookingStatus
    totalAmount?: DecimalFilter<"Booking"> | Decimal | DecimalJsLike | number | string
    currency?: StringFilter<"Booking"> | string
    purchasedAt?: DateTimeFilter<"Booking"> | Date | string
    movieTitle?: StringFilter<"Booking"> | string
  }

  export type PasswordResetTokenUpsertWithWhereUniqueWithoutUserInput = {
    where: PasswordResetTokenWhereUniqueInput
    update: XOR<PasswordResetTokenUpdateWithoutUserInput, PasswordResetTokenUncheckedUpdateWithoutUserInput>
    create: XOR<PasswordResetTokenCreateWithoutUserInput, PasswordResetTokenUncheckedCreateWithoutUserInput>
  }

  export type PasswordResetTokenUpdateWithWhereUniqueWithoutUserInput = {
    where: PasswordResetTokenWhereUniqueInput
    data: XOR<PasswordResetTokenUpdateWithoutUserInput, PasswordResetTokenUncheckedUpdateWithoutUserInput>
  }

  export type PasswordResetTokenUpdateManyWithWhereWithoutUserInput = {
    where: PasswordResetTokenScalarWhereInput
    data: XOR<PasswordResetTokenUpdateManyMutationInput, PasswordResetTokenUncheckedUpdateManyWithoutUserInput>
  }

  export type PasswordResetTokenScalarWhereInput = {
    AND?: PasswordResetTokenScalarWhereInput | PasswordResetTokenScalarWhereInput[]
    OR?: PasswordResetTokenScalarWhereInput[]
    NOT?: PasswordResetTokenScalarWhereInput | PasswordResetTokenScalarWhereInput[]
    id?: StringFilter<"PasswordResetToken"> | string
    userId?: StringFilter<"PasswordResetToken"> | string
    otp?: StringFilter<"PasswordResetToken"> | string
    expiresAt?: DateTimeFilter<"PasswordResetToken"> | Date | string
    usedAt?: DateTimeNullableFilter<"PasswordResetToken"> | Date | string | null
    createdAt?: DateTimeFilter<"PasswordResetToken"> | Date | string
  }

  export type UserCreateWithoutAdminProfileInput = {
    id?: string
    email: string
    passwordHash: string
    displayName: string
    avatarUrl?: string | null
    phoneNumber?: string | null
    isAdmin?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    sessions?: SessionCreateNestedManyWithoutUserInput
    bookings?: BookingCreateNestedManyWithoutUserInput
    passwordResetTokens?: PasswordResetTokenCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutAdminProfileInput = {
    id?: string
    email: string
    passwordHash: string
    displayName: string
    avatarUrl?: string | null
    phoneNumber?: string | null
    isAdmin?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    bookings?: BookingUncheckedCreateNestedManyWithoutUserInput
    passwordResetTokens?: PasswordResetTokenUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutAdminProfileInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutAdminProfileInput, UserUncheckedCreateWithoutAdminProfileInput>
  }

  export type AdminUserRoleCreateWithoutAdminUserInput = {
    role: $Enums.AdminRole
  }

  export type AdminUserRoleUncheckedCreateWithoutAdminUserInput = {
    id?: number
    role: $Enums.AdminRole
  }

  export type AdminUserRoleCreateOrConnectWithoutAdminUserInput = {
    where: AdminUserRoleWhereUniqueInput
    create: XOR<AdminUserRoleCreateWithoutAdminUserInput, AdminUserRoleUncheckedCreateWithoutAdminUserInput>
  }

  export type AdminUserRoleCreateManyAdminUserInputEnvelope = {
    data: AdminUserRoleCreateManyAdminUserInput | AdminUserRoleCreateManyAdminUserInput[]
    skipDuplicates?: boolean
  }

  export type UserUpsertWithoutAdminProfileInput = {
    update: XOR<UserUpdateWithoutAdminProfileInput, UserUncheckedUpdateWithoutAdminProfileInput>
    create: XOR<UserCreateWithoutAdminProfileInput, UserUncheckedCreateWithoutAdminProfileInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutAdminProfileInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutAdminProfileInput, UserUncheckedUpdateWithoutAdminProfileInput>
  }

  export type UserUpdateWithoutAdminProfileInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    displayName?: StringFieldUpdateOperationsInput | string
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    isAdmin?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sessions?: SessionUpdateManyWithoutUserNestedInput
    bookings?: BookingUpdateManyWithoutUserNestedInput
    passwordResetTokens?: PasswordResetTokenUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutAdminProfileInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    displayName?: StringFieldUpdateOperationsInput | string
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    isAdmin?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    bookings?: BookingUncheckedUpdateManyWithoutUserNestedInput
    passwordResetTokens?: PasswordResetTokenUncheckedUpdateManyWithoutUserNestedInput
  }

  export type AdminUserRoleUpsertWithWhereUniqueWithoutAdminUserInput = {
    where: AdminUserRoleWhereUniqueInput
    update: XOR<AdminUserRoleUpdateWithoutAdminUserInput, AdminUserRoleUncheckedUpdateWithoutAdminUserInput>
    create: XOR<AdminUserRoleCreateWithoutAdminUserInput, AdminUserRoleUncheckedCreateWithoutAdminUserInput>
  }

  export type AdminUserRoleUpdateWithWhereUniqueWithoutAdminUserInput = {
    where: AdminUserRoleWhereUniqueInput
    data: XOR<AdminUserRoleUpdateWithoutAdminUserInput, AdminUserRoleUncheckedUpdateWithoutAdminUserInput>
  }

  export type AdminUserRoleUpdateManyWithWhereWithoutAdminUserInput = {
    where: AdminUserRoleScalarWhereInput
    data: XOR<AdminUserRoleUpdateManyMutationInput, AdminUserRoleUncheckedUpdateManyWithoutAdminUserInput>
  }

  export type AdminUserRoleScalarWhereInput = {
    AND?: AdminUserRoleScalarWhereInput | AdminUserRoleScalarWhereInput[]
    OR?: AdminUserRoleScalarWhereInput[]
    NOT?: AdminUserRoleScalarWhereInput | AdminUserRoleScalarWhereInput[]
    id?: IntFilter<"AdminUserRole"> | number
    adminUserId?: StringFilter<"AdminUserRole"> | string
    role?: EnumAdminRoleFilter<"AdminUserRole"> | $Enums.AdminRole
  }

  export type AdminUserCreateWithoutRolesInput = {
    id?: string
    status?: $Enums.AdminStatus
    lastActiveAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutAdminProfileInput
  }

  export type AdminUserUncheckedCreateWithoutRolesInput = {
    id?: string
    userId: string
    status?: $Enums.AdminStatus
    lastActiveAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AdminUserCreateOrConnectWithoutRolesInput = {
    where: AdminUserWhereUniqueInput
    create: XOR<AdminUserCreateWithoutRolesInput, AdminUserUncheckedCreateWithoutRolesInput>
  }

  export type AdminUserUpsertWithoutRolesInput = {
    update: XOR<AdminUserUpdateWithoutRolesInput, AdminUserUncheckedUpdateWithoutRolesInput>
    create: XOR<AdminUserCreateWithoutRolesInput, AdminUserUncheckedCreateWithoutRolesInput>
    where?: AdminUserWhereInput
  }

  export type AdminUserUpdateToOneWithWhereWithoutRolesInput = {
    where?: AdminUserWhereInput
    data: XOR<AdminUserUpdateWithoutRolesInput, AdminUserUncheckedUpdateWithoutRolesInput>
  }

  export type AdminUserUpdateWithoutRolesInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumAdminStatusFieldUpdateOperationsInput | $Enums.AdminStatus
    lastActiveAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutAdminProfileNestedInput
  }

  export type AdminUserUncheckedUpdateWithoutRolesInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    status?: EnumAdminStatusFieldUpdateOperationsInput | $Enums.AdminStatus
    lastActiveAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserCreateWithoutSessionsInput = {
    id?: string
    email: string
    passwordHash: string
    displayName: string
    avatarUrl?: string | null
    phoneNumber?: string | null
    isAdmin?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    adminProfile?: AdminUserCreateNestedOneWithoutUserInput
    bookings?: BookingCreateNestedManyWithoutUserInput
    passwordResetTokens?: PasswordResetTokenCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutSessionsInput = {
    id?: string
    email: string
    passwordHash: string
    displayName: string
    avatarUrl?: string | null
    phoneNumber?: string | null
    isAdmin?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    adminProfile?: AdminUserUncheckedCreateNestedOneWithoutUserInput
    bookings?: BookingUncheckedCreateNestedManyWithoutUserInput
    passwordResetTokens?: PasswordResetTokenUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutSessionsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutSessionsInput, UserUncheckedCreateWithoutSessionsInput>
  }

  export type UserUpsertWithoutSessionsInput = {
    update: XOR<UserUpdateWithoutSessionsInput, UserUncheckedUpdateWithoutSessionsInput>
    create: XOR<UserCreateWithoutSessionsInput, UserUncheckedCreateWithoutSessionsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutSessionsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutSessionsInput, UserUncheckedUpdateWithoutSessionsInput>
  }

  export type UserUpdateWithoutSessionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    displayName?: StringFieldUpdateOperationsInput | string
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    isAdmin?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    adminProfile?: AdminUserUpdateOneWithoutUserNestedInput
    bookings?: BookingUpdateManyWithoutUserNestedInput
    passwordResetTokens?: PasswordResetTokenUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutSessionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    displayName?: StringFieldUpdateOperationsInput | string
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    isAdmin?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    adminProfile?: AdminUserUncheckedUpdateOneWithoutUserNestedInput
    bookings?: BookingUncheckedUpdateManyWithoutUserNestedInput
    passwordResetTokens?: PasswordResetTokenUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateWithoutPasswordResetTokensInput = {
    id?: string
    email: string
    passwordHash: string
    displayName: string
    avatarUrl?: string | null
    phoneNumber?: string | null
    isAdmin?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    adminProfile?: AdminUserCreateNestedOneWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    bookings?: BookingCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutPasswordResetTokensInput = {
    id?: string
    email: string
    passwordHash: string
    displayName: string
    avatarUrl?: string | null
    phoneNumber?: string | null
    isAdmin?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    adminProfile?: AdminUserUncheckedCreateNestedOneWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    bookings?: BookingUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutPasswordResetTokensInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutPasswordResetTokensInput, UserUncheckedCreateWithoutPasswordResetTokensInput>
  }

  export type UserUpsertWithoutPasswordResetTokensInput = {
    update: XOR<UserUpdateWithoutPasswordResetTokensInput, UserUncheckedUpdateWithoutPasswordResetTokensInput>
    create: XOR<UserCreateWithoutPasswordResetTokensInput, UserUncheckedCreateWithoutPasswordResetTokensInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutPasswordResetTokensInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutPasswordResetTokensInput, UserUncheckedUpdateWithoutPasswordResetTokensInput>
  }

  export type UserUpdateWithoutPasswordResetTokensInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    displayName?: StringFieldUpdateOperationsInput | string
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    isAdmin?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    adminProfile?: AdminUserUpdateOneWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    bookings?: BookingUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutPasswordResetTokensInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    displayName?: StringFieldUpdateOperationsInput | string
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    isAdmin?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    adminProfile?: AdminUserUncheckedUpdateOneWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    bookings?: BookingUncheckedUpdateManyWithoutUserNestedInput
  }

  export type MovieGenreCreateWithoutMovieInput = {
    name: string
  }

  export type MovieGenreUncheckedCreateWithoutMovieInput = {
    id?: number
    name: string
  }

  export type MovieGenreCreateOrConnectWithoutMovieInput = {
    where: MovieGenreWhereUniqueInput
    create: XOR<MovieGenreCreateWithoutMovieInput, MovieGenreUncheckedCreateWithoutMovieInput>
  }

  export type MovieGenreCreateManyMovieInputEnvelope = {
    data: MovieGenreCreateManyMovieInput | MovieGenreCreateManyMovieInput[]
    skipDuplicates?: boolean
  }

  export type MovieLanguageCreateWithoutMovieInput = {
    name: string
  }

  export type MovieLanguageUncheckedCreateWithoutMovieInput = {
    id?: number
    name: string
  }

  export type MovieLanguageCreateOrConnectWithoutMovieInput = {
    where: MovieLanguageWhereUniqueInput
    create: XOR<MovieLanguageCreateWithoutMovieInput, MovieLanguageUncheckedCreateWithoutMovieInput>
  }

  export type MovieLanguageCreateManyMovieInputEnvelope = {
    data: MovieLanguageCreateManyMovieInput | MovieLanguageCreateManyMovieInput[]
    skipDuplicates?: boolean
  }

  export type ShowtimeCreateWithoutMovieInput = {
    id?: string
    startsAt: Date | string
    endsAt: Date | string
    basePrice: Decimal | DecimalJsLike | number | string
    status?: $Enums.ShowtimeStatus
    seatLayoutVersion?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    auditorium: AuditoriumCreateNestedOneWithoutShowtimesInput
    pricingTiers?: ShowtimePricingTierCreateNestedManyWithoutShowtimeInput
    bookings?: BookingCreateNestedManyWithoutShowtimeInput
  }

  export type ShowtimeUncheckedCreateWithoutMovieInput = {
    id?: string
    auditoriumId: string
    startsAt: Date | string
    endsAt: Date | string
    basePrice: Decimal | DecimalJsLike | number | string
    status?: $Enums.ShowtimeStatus
    seatLayoutVersion?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    pricingTiers?: ShowtimePricingTierUncheckedCreateNestedManyWithoutShowtimeInput
    bookings?: BookingUncheckedCreateNestedManyWithoutShowtimeInput
  }

  export type ShowtimeCreateOrConnectWithoutMovieInput = {
    where: ShowtimeWhereUniqueInput
    create: XOR<ShowtimeCreateWithoutMovieInput, ShowtimeUncheckedCreateWithoutMovieInput>
  }

  export type ShowtimeCreateManyMovieInputEnvelope = {
    data: ShowtimeCreateManyMovieInput | ShowtimeCreateManyMovieInput[]
    skipDuplicates?: boolean
  }

  export type MovieGenreUpsertWithWhereUniqueWithoutMovieInput = {
    where: MovieGenreWhereUniqueInput
    update: XOR<MovieGenreUpdateWithoutMovieInput, MovieGenreUncheckedUpdateWithoutMovieInput>
    create: XOR<MovieGenreCreateWithoutMovieInput, MovieGenreUncheckedCreateWithoutMovieInput>
  }

  export type MovieGenreUpdateWithWhereUniqueWithoutMovieInput = {
    where: MovieGenreWhereUniqueInput
    data: XOR<MovieGenreUpdateWithoutMovieInput, MovieGenreUncheckedUpdateWithoutMovieInput>
  }

  export type MovieGenreUpdateManyWithWhereWithoutMovieInput = {
    where: MovieGenreScalarWhereInput
    data: XOR<MovieGenreUpdateManyMutationInput, MovieGenreUncheckedUpdateManyWithoutMovieInput>
  }

  export type MovieGenreScalarWhereInput = {
    AND?: MovieGenreScalarWhereInput | MovieGenreScalarWhereInput[]
    OR?: MovieGenreScalarWhereInput[]
    NOT?: MovieGenreScalarWhereInput | MovieGenreScalarWhereInput[]
    id?: IntFilter<"MovieGenre"> | number
    movieId?: StringFilter<"MovieGenre"> | string
    name?: StringFilter<"MovieGenre"> | string
  }

  export type MovieLanguageUpsertWithWhereUniqueWithoutMovieInput = {
    where: MovieLanguageWhereUniqueInput
    update: XOR<MovieLanguageUpdateWithoutMovieInput, MovieLanguageUncheckedUpdateWithoutMovieInput>
    create: XOR<MovieLanguageCreateWithoutMovieInput, MovieLanguageUncheckedCreateWithoutMovieInput>
  }

  export type MovieLanguageUpdateWithWhereUniqueWithoutMovieInput = {
    where: MovieLanguageWhereUniqueInput
    data: XOR<MovieLanguageUpdateWithoutMovieInput, MovieLanguageUncheckedUpdateWithoutMovieInput>
  }

  export type MovieLanguageUpdateManyWithWhereWithoutMovieInput = {
    where: MovieLanguageScalarWhereInput
    data: XOR<MovieLanguageUpdateManyMutationInput, MovieLanguageUncheckedUpdateManyWithoutMovieInput>
  }

  export type MovieLanguageScalarWhereInput = {
    AND?: MovieLanguageScalarWhereInput | MovieLanguageScalarWhereInput[]
    OR?: MovieLanguageScalarWhereInput[]
    NOT?: MovieLanguageScalarWhereInput | MovieLanguageScalarWhereInput[]
    id?: IntFilter<"MovieLanguage"> | number
    movieId?: StringFilter<"MovieLanguage"> | string
    name?: StringFilter<"MovieLanguage"> | string
  }

  export type ShowtimeUpsertWithWhereUniqueWithoutMovieInput = {
    where: ShowtimeWhereUniqueInput
    update: XOR<ShowtimeUpdateWithoutMovieInput, ShowtimeUncheckedUpdateWithoutMovieInput>
    create: XOR<ShowtimeCreateWithoutMovieInput, ShowtimeUncheckedCreateWithoutMovieInput>
  }

  export type ShowtimeUpdateWithWhereUniqueWithoutMovieInput = {
    where: ShowtimeWhereUniqueInput
    data: XOR<ShowtimeUpdateWithoutMovieInput, ShowtimeUncheckedUpdateWithoutMovieInput>
  }

  export type ShowtimeUpdateManyWithWhereWithoutMovieInput = {
    where: ShowtimeScalarWhereInput
    data: XOR<ShowtimeUpdateManyMutationInput, ShowtimeUncheckedUpdateManyWithoutMovieInput>
  }

  export type ShowtimeScalarWhereInput = {
    AND?: ShowtimeScalarWhereInput | ShowtimeScalarWhereInput[]
    OR?: ShowtimeScalarWhereInput[]
    NOT?: ShowtimeScalarWhereInput | ShowtimeScalarWhereInput[]
    id?: StringFilter<"Showtime"> | string
    movieId?: StringFilter<"Showtime"> | string
    auditoriumId?: StringFilter<"Showtime"> | string
    startsAt?: DateTimeFilter<"Showtime"> | Date | string
    endsAt?: DateTimeFilter<"Showtime"> | Date | string
    basePrice?: DecimalFilter<"Showtime"> | Decimal | DecimalJsLike | number | string
    status?: EnumShowtimeStatusFilter<"Showtime"> | $Enums.ShowtimeStatus
    seatLayoutVersion?: IntFilter<"Showtime"> | number
    createdAt?: DateTimeFilter<"Showtime"> | Date | string
    updatedAt?: DateTimeFilter<"Showtime"> | Date | string
  }

  export type MovieCreateWithoutGenresInput = {
    id?: string
    title: string
    slug: string
    status?: $Enums.MovieStatus
    durationMinutes?: number | null
    synopsis?: string | null
    tagline?: string | null
    posterUrl?: string | null
    backdropUrl?: string | null
    releaseYear?: number | null
    rating?: Decimal | DecimalJsLike | number | string | null
    isTrending?: boolean
    isTopPick?: boolean
    isUpcoming?: boolean
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    languages?: MovieLanguageCreateNestedManyWithoutMovieInput
    showtimes?: ShowtimeCreateNestedManyWithoutMovieInput
  }

  export type MovieUncheckedCreateWithoutGenresInput = {
    id?: string
    title: string
    slug: string
    status?: $Enums.MovieStatus
    durationMinutes?: number | null
    synopsis?: string | null
    tagline?: string | null
    posterUrl?: string | null
    backdropUrl?: string | null
    releaseYear?: number | null
    rating?: Decimal | DecimalJsLike | number | string | null
    isTrending?: boolean
    isTopPick?: boolean
    isUpcoming?: boolean
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    languages?: MovieLanguageUncheckedCreateNestedManyWithoutMovieInput
    showtimes?: ShowtimeUncheckedCreateNestedManyWithoutMovieInput
  }

  export type MovieCreateOrConnectWithoutGenresInput = {
    where: MovieWhereUniqueInput
    create: XOR<MovieCreateWithoutGenresInput, MovieUncheckedCreateWithoutGenresInput>
  }

  export type MovieUpsertWithoutGenresInput = {
    update: XOR<MovieUpdateWithoutGenresInput, MovieUncheckedUpdateWithoutGenresInput>
    create: XOR<MovieCreateWithoutGenresInput, MovieUncheckedCreateWithoutGenresInput>
    where?: MovieWhereInput
  }

  export type MovieUpdateToOneWithWhereWithoutGenresInput = {
    where?: MovieWhereInput
    data: XOR<MovieUpdateWithoutGenresInput, MovieUncheckedUpdateWithoutGenresInput>
  }

  export type MovieUpdateWithoutGenresInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    status?: EnumMovieStatusFieldUpdateOperationsInput | $Enums.MovieStatus
    durationMinutes?: NullableIntFieldUpdateOperationsInput | number | null
    synopsis?: NullableStringFieldUpdateOperationsInput | string | null
    tagline?: NullableStringFieldUpdateOperationsInput | string | null
    posterUrl?: NullableStringFieldUpdateOperationsInput | string | null
    backdropUrl?: NullableStringFieldUpdateOperationsInput | string | null
    releaseYear?: NullableIntFieldUpdateOperationsInput | number | null
    rating?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    isTrending?: BoolFieldUpdateOperationsInput | boolean
    isTopPick?: BoolFieldUpdateOperationsInput | boolean
    isUpcoming?: BoolFieldUpdateOperationsInput | boolean
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    languages?: MovieLanguageUpdateManyWithoutMovieNestedInput
    showtimes?: ShowtimeUpdateManyWithoutMovieNestedInput
  }

  export type MovieUncheckedUpdateWithoutGenresInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    status?: EnumMovieStatusFieldUpdateOperationsInput | $Enums.MovieStatus
    durationMinutes?: NullableIntFieldUpdateOperationsInput | number | null
    synopsis?: NullableStringFieldUpdateOperationsInput | string | null
    tagline?: NullableStringFieldUpdateOperationsInput | string | null
    posterUrl?: NullableStringFieldUpdateOperationsInput | string | null
    backdropUrl?: NullableStringFieldUpdateOperationsInput | string | null
    releaseYear?: NullableIntFieldUpdateOperationsInput | number | null
    rating?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    isTrending?: BoolFieldUpdateOperationsInput | boolean
    isTopPick?: BoolFieldUpdateOperationsInput | boolean
    isUpcoming?: BoolFieldUpdateOperationsInput | boolean
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    languages?: MovieLanguageUncheckedUpdateManyWithoutMovieNestedInput
    showtimes?: ShowtimeUncheckedUpdateManyWithoutMovieNestedInput
  }

  export type MovieCreateWithoutLanguagesInput = {
    id?: string
    title: string
    slug: string
    status?: $Enums.MovieStatus
    durationMinutes?: number | null
    synopsis?: string | null
    tagline?: string | null
    posterUrl?: string | null
    backdropUrl?: string | null
    releaseYear?: number | null
    rating?: Decimal | DecimalJsLike | number | string | null
    isTrending?: boolean
    isTopPick?: boolean
    isUpcoming?: boolean
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    genres?: MovieGenreCreateNestedManyWithoutMovieInput
    showtimes?: ShowtimeCreateNestedManyWithoutMovieInput
  }

  export type MovieUncheckedCreateWithoutLanguagesInput = {
    id?: string
    title: string
    slug: string
    status?: $Enums.MovieStatus
    durationMinutes?: number | null
    synopsis?: string | null
    tagline?: string | null
    posterUrl?: string | null
    backdropUrl?: string | null
    releaseYear?: number | null
    rating?: Decimal | DecimalJsLike | number | string | null
    isTrending?: boolean
    isTopPick?: boolean
    isUpcoming?: boolean
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    genres?: MovieGenreUncheckedCreateNestedManyWithoutMovieInput
    showtimes?: ShowtimeUncheckedCreateNestedManyWithoutMovieInput
  }

  export type MovieCreateOrConnectWithoutLanguagesInput = {
    where: MovieWhereUniqueInput
    create: XOR<MovieCreateWithoutLanguagesInput, MovieUncheckedCreateWithoutLanguagesInput>
  }

  export type MovieUpsertWithoutLanguagesInput = {
    update: XOR<MovieUpdateWithoutLanguagesInput, MovieUncheckedUpdateWithoutLanguagesInput>
    create: XOR<MovieCreateWithoutLanguagesInput, MovieUncheckedCreateWithoutLanguagesInput>
    where?: MovieWhereInput
  }

  export type MovieUpdateToOneWithWhereWithoutLanguagesInput = {
    where?: MovieWhereInput
    data: XOR<MovieUpdateWithoutLanguagesInput, MovieUncheckedUpdateWithoutLanguagesInput>
  }

  export type MovieUpdateWithoutLanguagesInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    status?: EnumMovieStatusFieldUpdateOperationsInput | $Enums.MovieStatus
    durationMinutes?: NullableIntFieldUpdateOperationsInput | number | null
    synopsis?: NullableStringFieldUpdateOperationsInput | string | null
    tagline?: NullableStringFieldUpdateOperationsInput | string | null
    posterUrl?: NullableStringFieldUpdateOperationsInput | string | null
    backdropUrl?: NullableStringFieldUpdateOperationsInput | string | null
    releaseYear?: NullableIntFieldUpdateOperationsInput | number | null
    rating?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    isTrending?: BoolFieldUpdateOperationsInput | boolean
    isTopPick?: BoolFieldUpdateOperationsInput | boolean
    isUpcoming?: BoolFieldUpdateOperationsInput | boolean
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    genres?: MovieGenreUpdateManyWithoutMovieNestedInput
    showtimes?: ShowtimeUpdateManyWithoutMovieNestedInput
  }

  export type MovieUncheckedUpdateWithoutLanguagesInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    status?: EnumMovieStatusFieldUpdateOperationsInput | $Enums.MovieStatus
    durationMinutes?: NullableIntFieldUpdateOperationsInput | number | null
    synopsis?: NullableStringFieldUpdateOperationsInput | string | null
    tagline?: NullableStringFieldUpdateOperationsInput | string | null
    posterUrl?: NullableStringFieldUpdateOperationsInput | string | null
    backdropUrl?: NullableStringFieldUpdateOperationsInput | string | null
    releaseYear?: NullableIntFieldUpdateOperationsInput | number | null
    rating?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    isTrending?: BoolFieldUpdateOperationsInput | boolean
    isTopPick?: BoolFieldUpdateOperationsInput | boolean
    isUpcoming?: BoolFieldUpdateOperationsInput | boolean
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    genres?: MovieGenreUncheckedUpdateManyWithoutMovieNestedInput
    showtimes?: ShowtimeUncheckedUpdateManyWithoutMovieNestedInput
  }

  export type ShowtimeCreateWithoutAuditoriumInput = {
    id?: string
    startsAt: Date | string
    endsAt: Date | string
    basePrice: Decimal | DecimalJsLike | number | string
    status?: $Enums.ShowtimeStatus
    seatLayoutVersion?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    movie: MovieCreateNestedOneWithoutShowtimesInput
    pricingTiers?: ShowtimePricingTierCreateNestedManyWithoutShowtimeInput
    bookings?: BookingCreateNestedManyWithoutShowtimeInput
  }

  export type ShowtimeUncheckedCreateWithoutAuditoriumInput = {
    id?: string
    movieId: string
    startsAt: Date | string
    endsAt: Date | string
    basePrice: Decimal | DecimalJsLike | number | string
    status?: $Enums.ShowtimeStatus
    seatLayoutVersion?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    pricingTiers?: ShowtimePricingTierUncheckedCreateNestedManyWithoutShowtimeInput
    bookings?: BookingUncheckedCreateNestedManyWithoutShowtimeInput
  }

  export type ShowtimeCreateOrConnectWithoutAuditoriumInput = {
    where: ShowtimeWhereUniqueInput
    create: XOR<ShowtimeCreateWithoutAuditoriumInput, ShowtimeUncheckedCreateWithoutAuditoriumInput>
  }

  export type ShowtimeCreateManyAuditoriumInputEnvelope = {
    data: ShowtimeCreateManyAuditoriumInput | ShowtimeCreateManyAuditoriumInput[]
    skipDuplicates?: boolean
  }

  export type ShowtimeUpsertWithWhereUniqueWithoutAuditoriumInput = {
    where: ShowtimeWhereUniqueInput
    update: XOR<ShowtimeUpdateWithoutAuditoriumInput, ShowtimeUncheckedUpdateWithoutAuditoriumInput>
    create: XOR<ShowtimeCreateWithoutAuditoriumInput, ShowtimeUncheckedCreateWithoutAuditoriumInput>
  }

  export type ShowtimeUpdateWithWhereUniqueWithoutAuditoriumInput = {
    where: ShowtimeWhereUniqueInput
    data: XOR<ShowtimeUpdateWithoutAuditoriumInput, ShowtimeUncheckedUpdateWithoutAuditoriumInput>
  }

  export type ShowtimeUpdateManyWithWhereWithoutAuditoriumInput = {
    where: ShowtimeScalarWhereInput
    data: XOR<ShowtimeUpdateManyMutationInput, ShowtimeUncheckedUpdateManyWithoutAuditoriumInput>
  }

  export type MovieCreateWithoutShowtimesInput = {
    id?: string
    title: string
    slug: string
    status?: $Enums.MovieStatus
    durationMinutes?: number | null
    synopsis?: string | null
    tagline?: string | null
    posterUrl?: string | null
    backdropUrl?: string | null
    releaseYear?: number | null
    rating?: Decimal | DecimalJsLike | number | string | null
    isTrending?: boolean
    isTopPick?: boolean
    isUpcoming?: boolean
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    genres?: MovieGenreCreateNestedManyWithoutMovieInput
    languages?: MovieLanguageCreateNestedManyWithoutMovieInput
  }

  export type MovieUncheckedCreateWithoutShowtimesInput = {
    id?: string
    title: string
    slug: string
    status?: $Enums.MovieStatus
    durationMinutes?: number | null
    synopsis?: string | null
    tagline?: string | null
    posterUrl?: string | null
    backdropUrl?: string | null
    releaseYear?: number | null
    rating?: Decimal | DecimalJsLike | number | string | null
    isTrending?: boolean
    isTopPick?: boolean
    isUpcoming?: boolean
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    genres?: MovieGenreUncheckedCreateNestedManyWithoutMovieInput
    languages?: MovieLanguageUncheckedCreateNestedManyWithoutMovieInput
  }

  export type MovieCreateOrConnectWithoutShowtimesInput = {
    where: MovieWhereUniqueInput
    create: XOR<MovieCreateWithoutShowtimesInput, MovieUncheckedCreateWithoutShowtimesInput>
  }

  export type AuditoriumCreateWithoutShowtimesInput = {
    id?: string
    cinemaId: string
    cinemaName: string
    name: string
    capacity: number
    layoutVersion?: number
    layoutJson: JsonNullValueInput | InputJsonValue
    layoutUpdatedAt?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AuditoriumUncheckedCreateWithoutShowtimesInput = {
    id?: string
    cinemaId: string
    cinemaName: string
    name: string
    capacity: number
    layoutVersion?: number
    layoutJson: JsonNullValueInput | InputJsonValue
    layoutUpdatedAt?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AuditoriumCreateOrConnectWithoutShowtimesInput = {
    where: AuditoriumWhereUniqueInput
    create: XOR<AuditoriumCreateWithoutShowtimesInput, AuditoriumUncheckedCreateWithoutShowtimesInput>
  }

  export type ShowtimePricingTierCreateWithoutShowtimeInput = {
    id?: string
    label: string
    price: Decimal | DecimalJsLike | number | string
    seatTypes: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type ShowtimePricingTierUncheckedCreateWithoutShowtimeInput = {
    id?: string
    label: string
    price: Decimal | DecimalJsLike | number | string
    seatTypes: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type ShowtimePricingTierCreateOrConnectWithoutShowtimeInput = {
    where: ShowtimePricingTierWhereUniqueInput
    create: XOR<ShowtimePricingTierCreateWithoutShowtimeInput, ShowtimePricingTierUncheckedCreateWithoutShowtimeInput>
  }

  export type ShowtimePricingTierCreateManyShowtimeInputEnvelope = {
    data: ShowtimePricingTierCreateManyShowtimeInput | ShowtimePricingTierCreateManyShowtimeInput[]
    skipDuplicates?: boolean
  }

  export type BookingCreateWithoutShowtimeInput = {
    id?: string
    reference: string
    purchaserEmail: string
    purchaserName: string
    status?: $Enums.BookingStatus
    totalAmount: Decimal | DecimalJsLike | number | string
    currency?: string
    purchasedAt?: Date | string
    movieTitle: string
    user?: UserCreateNestedOneWithoutBookingsInput
    tickets?: BookingTicketCreateNestedManyWithoutBookingInput
    auditLog?: BookingAuditCreateNestedManyWithoutBookingInput
    settlements?: SettlementTransactionCreateNestedManyWithoutBookingInput
  }

  export type BookingUncheckedCreateWithoutShowtimeInput = {
    id?: string
    reference: string
    userId?: string | null
    purchaserEmail: string
    purchaserName: string
    status?: $Enums.BookingStatus
    totalAmount: Decimal | DecimalJsLike | number | string
    currency?: string
    purchasedAt?: Date | string
    movieTitle: string
    tickets?: BookingTicketUncheckedCreateNestedManyWithoutBookingInput
    auditLog?: BookingAuditUncheckedCreateNestedManyWithoutBookingInput
    settlements?: SettlementTransactionUncheckedCreateNestedManyWithoutBookingInput
  }

  export type BookingCreateOrConnectWithoutShowtimeInput = {
    where: BookingWhereUniqueInput
    create: XOR<BookingCreateWithoutShowtimeInput, BookingUncheckedCreateWithoutShowtimeInput>
  }

  export type BookingCreateManyShowtimeInputEnvelope = {
    data: BookingCreateManyShowtimeInput | BookingCreateManyShowtimeInput[]
    skipDuplicates?: boolean
  }

  export type MovieUpsertWithoutShowtimesInput = {
    update: XOR<MovieUpdateWithoutShowtimesInput, MovieUncheckedUpdateWithoutShowtimesInput>
    create: XOR<MovieCreateWithoutShowtimesInput, MovieUncheckedCreateWithoutShowtimesInput>
    where?: MovieWhereInput
  }

  export type MovieUpdateToOneWithWhereWithoutShowtimesInput = {
    where?: MovieWhereInput
    data: XOR<MovieUpdateWithoutShowtimesInput, MovieUncheckedUpdateWithoutShowtimesInput>
  }

  export type MovieUpdateWithoutShowtimesInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    status?: EnumMovieStatusFieldUpdateOperationsInput | $Enums.MovieStatus
    durationMinutes?: NullableIntFieldUpdateOperationsInput | number | null
    synopsis?: NullableStringFieldUpdateOperationsInput | string | null
    tagline?: NullableStringFieldUpdateOperationsInput | string | null
    posterUrl?: NullableStringFieldUpdateOperationsInput | string | null
    backdropUrl?: NullableStringFieldUpdateOperationsInput | string | null
    releaseYear?: NullableIntFieldUpdateOperationsInput | number | null
    rating?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    isTrending?: BoolFieldUpdateOperationsInput | boolean
    isTopPick?: BoolFieldUpdateOperationsInput | boolean
    isUpcoming?: BoolFieldUpdateOperationsInput | boolean
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    genres?: MovieGenreUpdateManyWithoutMovieNestedInput
    languages?: MovieLanguageUpdateManyWithoutMovieNestedInput
  }

  export type MovieUncheckedUpdateWithoutShowtimesInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    status?: EnumMovieStatusFieldUpdateOperationsInput | $Enums.MovieStatus
    durationMinutes?: NullableIntFieldUpdateOperationsInput | number | null
    synopsis?: NullableStringFieldUpdateOperationsInput | string | null
    tagline?: NullableStringFieldUpdateOperationsInput | string | null
    posterUrl?: NullableStringFieldUpdateOperationsInput | string | null
    backdropUrl?: NullableStringFieldUpdateOperationsInput | string | null
    releaseYear?: NullableIntFieldUpdateOperationsInput | number | null
    rating?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    isTrending?: BoolFieldUpdateOperationsInput | boolean
    isTopPick?: BoolFieldUpdateOperationsInput | boolean
    isUpcoming?: BoolFieldUpdateOperationsInput | boolean
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    genres?: MovieGenreUncheckedUpdateManyWithoutMovieNestedInput
    languages?: MovieLanguageUncheckedUpdateManyWithoutMovieNestedInput
  }

  export type AuditoriumUpsertWithoutShowtimesInput = {
    update: XOR<AuditoriumUpdateWithoutShowtimesInput, AuditoriumUncheckedUpdateWithoutShowtimesInput>
    create: XOR<AuditoriumCreateWithoutShowtimesInput, AuditoriumUncheckedCreateWithoutShowtimesInput>
    where?: AuditoriumWhereInput
  }

  export type AuditoriumUpdateToOneWithWhereWithoutShowtimesInput = {
    where?: AuditoriumWhereInput
    data: XOR<AuditoriumUpdateWithoutShowtimesInput, AuditoriumUncheckedUpdateWithoutShowtimesInput>
  }

  export type AuditoriumUpdateWithoutShowtimesInput = {
    id?: StringFieldUpdateOperationsInput | string
    cinemaId?: StringFieldUpdateOperationsInput | string
    cinemaName?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    capacity?: IntFieldUpdateOperationsInput | number
    layoutVersion?: IntFieldUpdateOperationsInput | number
    layoutJson?: JsonNullValueInput | InputJsonValue
    layoutUpdatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuditoriumUncheckedUpdateWithoutShowtimesInput = {
    id?: StringFieldUpdateOperationsInput | string
    cinemaId?: StringFieldUpdateOperationsInput | string
    cinemaName?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    capacity?: IntFieldUpdateOperationsInput | number
    layoutVersion?: IntFieldUpdateOperationsInput | number
    layoutJson?: JsonNullValueInput | InputJsonValue
    layoutUpdatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ShowtimePricingTierUpsertWithWhereUniqueWithoutShowtimeInput = {
    where: ShowtimePricingTierWhereUniqueInput
    update: XOR<ShowtimePricingTierUpdateWithoutShowtimeInput, ShowtimePricingTierUncheckedUpdateWithoutShowtimeInput>
    create: XOR<ShowtimePricingTierCreateWithoutShowtimeInput, ShowtimePricingTierUncheckedCreateWithoutShowtimeInput>
  }

  export type ShowtimePricingTierUpdateWithWhereUniqueWithoutShowtimeInput = {
    where: ShowtimePricingTierWhereUniqueInput
    data: XOR<ShowtimePricingTierUpdateWithoutShowtimeInput, ShowtimePricingTierUncheckedUpdateWithoutShowtimeInput>
  }

  export type ShowtimePricingTierUpdateManyWithWhereWithoutShowtimeInput = {
    where: ShowtimePricingTierScalarWhereInput
    data: XOR<ShowtimePricingTierUpdateManyMutationInput, ShowtimePricingTierUncheckedUpdateManyWithoutShowtimeInput>
  }

  export type ShowtimePricingTierScalarWhereInput = {
    AND?: ShowtimePricingTierScalarWhereInput | ShowtimePricingTierScalarWhereInput[]
    OR?: ShowtimePricingTierScalarWhereInput[]
    NOT?: ShowtimePricingTierScalarWhereInput | ShowtimePricingTierScalarWhereInput[]
    id?: StringFilter<"ShowtimePricingTier"> | string
    showtimeId?: StringFilter<"ShowtimePricingTier"> | string
    label?: StringFilter<"ShowtimePricingTier"> | string
    price?: DecimalFilter<"ShowtimePricingTier"> | Decimal | DecimalJsLike | number | string
    seatTypes?: JsonFilter<"ShowtimePricingTier">
    createdAt?: DateTimeFilter<"ShowtimePricingTier"> | Date | string
  }

  export type BookingUpsertWithWhereUniqueWithoutShowtimeInput = {
    where: BookingWhereUniqueInput
    update: XOR<BookingUpdateWithoutShowtimeInput, BookingUncheckedUpdateWithoutShowtimeInput>
    create: XOR<BookingCreateWithoutShowtimeInput, BookingUncheckedCreateWithoutShowtimeInput>
  }

  export type BookingUpdateWithWhereUniqueWithoutShowtimeInput = {
    where: BookingWhereUniqueInput
    data: XOR<BookingUpdateWithoutShowtimeInput, BookingUncheckedUpdateWithoutShowtimeInput>
  }

  export type BookingUpdateManyWithWhereWithoutShowtimeInput = {
    where: BookingScalarWhereInput
    data: XOR<BookingUpdateManyMutationInput, BookingUncheckedUpdateManyWithoutShowtimeInput>
  }

  export type ShowtimeCreateWithoutPricingTiersInput = {
    id?: string
    startsAt: Date | string
    endsAt: Date | string
    basePrice: Decimal | DecimalJsLike | number | string
    status?: $Enums.ShowtimeStatus
    seatLayoutVersion?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    movie: MovieCreateNestedOneWithoutShowtimesInput
    auditorium: AuditoriumCreateNestedOneWithoutShowtimesInput
    bookings?: BookingCreateNestedManyWithoutShowtimeInput
  }

  export type ShowtimeUncheckedCreateWithoutPricingTiersInput = {
    id?: string
    movieId: string
    auditoriumId: string
    startsAt: Date | string
    endsAt: Date | string
    basePrice: Decimal | DecimalJsLike | number | string
    status?: $Enums.ShowtimeStatus
    seatLayoutVersion?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    bookings?: BookingUncheckedCreateNestedManyWithoutShowtimeInput
  }

  export type ShowtimeCreateOrConnectWithoutPricingTiersInput = {
    where: ShowtimeWhereUniqueInput
    create: XOR<ShowtimeCreateWithoutPricingTiersInput, ShowtimeUncheckedCreateWithoutPricingTiersInput>
  }

  export type ShowtimeUpsertWithoutPricingTiersInput = {
    update: XOR<ShowtimeUpdateWithoutPricingTiersInput, ShowtimeUncheckedUpdateWithoutPricingTiersInput>
    create: XOR<ShowtimeCreateWithoutPricingTiersInput, ShowtimeUncheckedCreateWithoutPricingTiersInput>
    where?: ShowtimeWhereInput
  }

  export type ShowtimeUpdateToOneWithWhereWithoutPricingTiersInput = {
    where?: ShowtimeWhereInput
    data: XOR<ShowtimeUpdateWithoutPricingTiersInput, ShowtimeUncheckedUpdateWithoutPricingTiersInput>
  }

  export type ShowtimeUpdateWithoutPricingTiersInput = {
    id?: StringFieldUpdateOperationsInput | string
    startsAt?: DateTimeFieldUpdateOperationsInput | Date | string
    endsAt?: DateTimeFieldUpdateOperationsInput | Date | string
    basePrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: EnumShowtimeStatusFieldUpdateOperationsInput | $Enums.ShowtimeStatus
    seatLayoutVersion?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    movie?: MovieUpdateOneRequiredWithoutShowtimesNestedInput
    auditorium?: AuditoriumUpdateOneRequiredWithoutShowtimesNestedInput
    bookings?: BookingUpdateManyWithoutShowtimeNestedInput
  }

  export type ShowtimeUncheckedUpdateWithoutPricingTiersInput = {
    id?: StringFieldUpdateOperationsInput | string
    movieId?: StringFieldUpdateOperationsInput | string
    auditoriumId?: StringFieldUpdateOperationsInput | string
    startsAt?: DateTimeFieldUpdateOperationsInput | Date | string
    endsAt?: DateTimeFieldUpdateOperationsInput | Date | string
    basePrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: EnumShowtimeStatusFieldUpdateOperationsInput | $Enums.ShowtimeStatus
    seatLayoutVersion?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    bookings?: BookingUncheckedUpdateManyWithoutShowtimeNestedInput
  }

  export type UserCreateWithoutBookingsInput = {
    id?: string
    email: string
    passwordHash: string
    displayName: string
    avatarUrl?: string | null
    phoneNumber?: string | null
    isAdmin?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    adminProfile?: AdminUserCreateNestedOneWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    passwordResetTokens?: PasswordResetTokenCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutBookingsInput = {
    id?: string
    email: string
    passwordHash: string
    displayName: string
    avatarUrl?: string | null
    phoneNumber?: string | null
    isAdmin?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    adminProfile?: AdminUserUncheckedCreateNestedOneWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    passwordResetTokens?: PasswordResetTokenUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutBookingsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutBookingsInput, UserUncheckedCreateWithoutBookingsInput>
  }

  export type ShowtimeCreateWithoutBookingsInput = {
    id?: string
    startsAt: Date | string
    endsAt: Date | string
    basePrice: Decimal | DecimalJsLike | number | string
    status?: $Enums.ShowtimeStatus
    seatLayoutVersion?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    movie: MovieCreateNestedOneWithoutShowtimesInput
    auditorium: AuditoriumCreateNestedOneWithoutShowtimesInput
    pricingTiers?: ShowtimePricingTierCreateNestedManyWithoutShowtimeInput
  }

  export type ShowtimeUncheckedCreateWithoutBookingsInput = {
    id?: string
    movieId: string
    auditoriumId: string
    startsAt: Date | string
    endsAt: Date | string
    basePrice: Decimal | DecimalJsLike | number | string
    status?: $Enums.ShowtimeStatus
    seatLayoutVersion?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    pricingTiers?: ShowtimePricingTierUncheckedCreateNestedManyWithoutShowtimeInput
  }

  export type ShowtimeCreateOrConnectWithoutBookingsInput = {
    where: ShowtimeWhereUniqueInput
    create: XOR<ShowtimeCreateWithoutBookingsInput, ShowtimeUncheckedCreateWithoutBookingsInput>
  }

  export type BookingTicketCreateWithoutBookingInput = {
    id?: string
    seatId: string
    seatLabel: string
    price: Decimal | DecimalJsLike | number | string
    tierLabel?: string | null
    tierId?: string | null
  }

  export type BookingTicketUncheckedCreateWithoutBookingInput = {
    id?: string
    seatId: string
    seatLabel: string
    price: Decimal | DecimalJsLike | number | string
    tierLabel?: string | null
    tierId?: string | null
  }

  export type BookingTicketCreateOrConnectWithoutBookingInput = {
    where: BookingTicketWhereUniqueInput
    create: XOR<BookingTicketCreateWithoutBookingInput, BookingTicketUncheckedCreateWithoutBookingInput>
  }

  export type BookingTicketCreateManyBookingInputEnvelope = {
    data: BookingTicketCreateManyBookingInput | BookingTicketCreateManyBookingInput[]
    skipDuplicates?: boolean
  }

  export type BookingAuditCreateWithoutBookingInput = {
    id?: string
    type: string
    message: string
    actor: string
    createdAt?: Date | string
  }

  export type BookingAuditUncheckedCreateWithoutBookingInput = {
    id?: string
    type: string
    message: string
    actor: string
    createdAt?: Date | string
  }

  export type BookingAuditCreateOrConnectWithoutBookingInput = {
    where: BookingAuditWhereUniqueInput
    create: XOR<BookingAuditCreateWithoutBookingInput, BookingAuditUncheckedCreateWithoutBookingInput>
  }

  export type BookingAuditCreateManyBookingInputEnvelope = {
    data: BookingAuditCreateManyBookingInput | BookingAuditCreateManyBookingInput[]
    skipDuplicates?: boolean
  }

  export type SettlementTransactionCreateWithoutBookingInput = {
    id?: string
    gateway: string
    transactionId: string
    amount: Decimal | DecimalJsLike | number | string
    currency?: string
    status?: $Enums.SettlementStatus
    fees: Decimal | DecimalJsLike | number | string
    netPayout: Decimal | DecimalJsLike | number | string
    settledAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SettlementTransactionUncheckedCreateWithoutBookingInput = {
    id?: string
    gateway: string
    transactionId: string
    amount: Decimal | DecimalJsLike | number | string
    currency?: string
    status?: $Enums.SettlementStatus
    fees: Decimal | DecimalJsLike | number | string
    netPayout: Decimal | DecimalJsLike | number | string
    settledAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SettlementTransactionCreateOrConnectWithoutBookingInput = {
    where: SettlementTransactionWhereUniqueInput
    create: XOR<SettlementTransactionCreateWithoutBookingInput, SettlementTransactionUncheckedCreateWithoutBookingInput>
  }

  export type SettlementTransactionCreateManyBookingInputEnvelope = {
    data: SettlementTransactionCreateManyBookingInput | SettlementTransactionCreateManyBookingInput[]
    skipDuplicates?: boolean
  }

  export type UserUpsertWithoutBookingsInput = {
    update: XOR<UserUpdateWithoutBookingsInput, UserUncheckedUpdateWithoutBookingsInput>
    create: XOR<UserCreateWithoutBookingsInput, UserUncheckedCreateWithoutBookingsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutBookingsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutBookingsInput, UserUncheckedUpdateWithoutBookingsInput>
  }

  export type UserUpdateWithoutBookingsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    displayName?: StringFieldUpdateOperationsInput | string
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    isAdmin?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    adminProfile?: AdminUserUpdateOneWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    passwordResetTokens?: PasswordResetTokenUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutBookingsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    displayName?: StringFieldUpdateOperationsInput | string
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    isAdmin?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    adminProfile?: AdminUserUncheckedUpdateOneWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    passwordResetTokens?: PasswordResetTokenUncheckedUpdateManyWithoutUserNestedInput
  }

  export type ShowtimeUpsertWithoutBookingsInput = {
    update: XOR<ShowtimeUpdateWithoutBookingsInput, ShowtimeUncheckedUpdateWithoutBookingsInput>
    create: XOR<ShowtimeCreateWithoutBookingsInput, ShowtimeUncheckedCreateWithoutBookingsInput>
    where?: ShowtimeWhereInput
  }

  export type ShowtimeUpdateToOneWithWhereWithoutBookingsInput = {
    where?: ShowtimeWhereInput
    data: XOR<ShowtimeUpdateWithoutBookingsInput, ShowtimeUncheckedUpdateWithoutBookingsInput>
  }

  export type ShowtimeUpdateWithoutBookingsInput = {
    id?: StringFieldUpdateOperationsInput | string
    startsAt?: DateTimeFieldUpdateOperationsInput | Date | string
    endsAt?: DateTimeFieldUpdateOperationsInput | Date | string
    basePrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: EnumShowtimeStatusFieldUpdateOperationsInput | $Enums.ShowtimeStatus
    seatLayoutVersion?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    movie?: MovieUpdateOneRequiredWithoutShowtimesNestedInput
    auditorium?: AuditoriumUpdateOneRequiredWithoutShowtimesNestedInput
    pricingTiers?: ShowtimePricingTierUpdateManyWithoutShowtimeNestedInput
  }

  export type ShowtimeUncheckedUpdateWithoutBookingsInput = {
    id?: StringFieldUpdateOperationsInput | string
    movieId?: StringFieldUpdateOperationsInput | string
    auditoriumId?: StringFieldUpdateOperationsInput | string
    startsAt?: DateTimeFieldUpdateOperationsInput | Date | string
    endsAt?: DateTimeFieldUpdateOperationsInput | Date | string
    basePrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: EnumShowtimeStatusFieldUpdateOperationsInput | $Enums.ShowtimeStatus
    seatLayoutVersion?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    pricingTiers?: ShowtimePricingTierUncheckedUpdateManyWithoutShowtimeNestedInput
  }

  export type BookingTicketUpsertWithWhereUniqueWithoutBookingInput = {
    where: BookingTicketWhereUniqueInput
    update: XOR<BookingTicketUpdateWithoutBookingInput, BookingTicketUncheckedUpdateWithoutBookingInput>
    create: XOR<BookingTicketCreateWithoutBookingInput, BookingTicketUncheckedCreateWithoutBookingInput>
  }

  export type BookingTicketUpdateWithWhereUniqueWithoutBookingInput = {
    where: BookingTicketWhereUniqueInput
    data: XOR<BookingTicketUpdateWithoutBookingInput, BookingTicketUncheckedUpdateWithoutBookingInput>
  }

  export type BookingTicketUpdateManyWithWhereWithoutBookingInput = {
    where: BookingTicketScalarWhereInput
    data: XOR<BookingTicketUpdateManyMutationInput, BookingTicketUncheckedUpdateManyWithoutBookingInput>
  }

  export type BookingTicketScalarWhereInput = {
    AND?: BookingTicketScalarWhereInput | BookingTicketScalarWhereInput[]
    OR?: BookingTicketScalarWhereInput[]
    NOT?: BookingTicketScalarWhereInput | BookingTicketScalarWhereInput[]
    id?: StringFilter<"BookingTicket"> | string
    bookingId?: StringFilter<"BookingTicket"> | string
    seatId?: StringFilter<"BookingTicket"> | string
    seatLabel?: StringFilter<"BookingTicket"> | string
    price?: DecimalFilter<"BookingTicket"> | Decimal | DecimalJsLike | number | string
    tierLabel?: StringNullableFilter<"BookingTicket"> | string | null
    tierId?: StringNullableFilter<"BookingTicket"> | string | null
  }

  export type BookingAuditUpsertWithWhereUniqueWithoutBookingInput = {
    where: BookingAuditWhereUniqueInput
    update: XOR<BookingAuditUpdateWithoutBookingInput, BookingAuditUncheckedUpdateWithoutBookingInput>
    create: XOR<BookingAuditCreateWithoutBookingInput, BookingAuditUncheckedCreateWithoutBookingInput>
  }

  export type BookingAuditUpdateWithWhereUniqueWithoutBookingInput = {
    where: BookingAuditWhereUniqueInput
    data: XOR<BookingAuditUpdateWithoutBookingInput, BookingAuditUncheckedUpdateWithoutBookingInput>
  }

  export type BookingAuditUpdateManyWithWhereWithoutBookingInput = {
    where: BookingAuditScalarWhereInput
    data: XOR<BookingAuditUpdateManyMutationInput, BookingAuditUncheckedUpdateManyWithoutBookingInput>
  }

  export type BookingAuditScalarWhereInput = {
    AND?: BookingAuditScalarWhereInput | BookingAuditScalarWhereInput[]
    OR?: BookingAuditScalarWhereInput[]
    NOT?: BookingAuditScalarWhereInput | BookingAuditScalarWhereInput[]
    id?: StringFilter<"BookingAudit"> | string
    bookingId?: StringFilter<"BookingAudit"> | string
    type?: StringFilter<"BookingAudit"> | string
    message?: StringFilter<"BookingAudit"> | string
    actor?: StringFilter<"BookingAudit"> | string
    createdAt?: DateTimeFilter<"BookingAudit"> | Date | string
  }

  export type SettlementTransactionUpsertWithWhereUniqueWithoutBookingInput = {
    where: SettlementTransactionWhereUniqueInput
    update: XOR<SettlementTransactionUpdateWithoutBookingInput, SettlementTransactionUncheckedUpdateWithoutBookingInput>
    create: XOR<SettlementTransactionCreateWithoutBookingInput, SettlementTransactionUncheckedCreateWithoutBookingInput>
  }

  export type SettlementTransactionUpdateWithWhereUniqueWithoutBookingInput = {
    where: SettlementTransactionWhereUniqueInput
    data: XOR<SettlementTransactionUpdateWithoutBookingInput, SettlementTransactionUncheckedUpdateWithoutBookingInput>
  }

  export type SettlementTransactionUpdateManyWithWhereWithoutBookingInput = {
    where: SettlementTransactionScalarWhereInput
    data: XOR<SettlementTransactionUpdateManyMutationInput, SettlementTransactionUncheckedUpdateManyWithoutBookingInput>
  }

  export type SettlementTransactionScalarWhereInput = {
    AND?: SettlementTransactionScalarWhereInput | SettlementTransactionScalarWhereInput[]
    OR?: SettlementTransactionScalarWhereInput[]
    NOT?: SettlementTransactionScalarWhereInput | SettlementTransactionScalarWhereInput[]
    id?: StringFilter<"SettlementTransaction"> | string
    gateway?: StringFilter<"SettlementTransaction"> | string
    transactionId?: StringFilter<"SettlementTransaction"> | string
    amount?: DecimalFilter<"SettlementTransaction"> | Decimal | DecimalJsLike | number | string
    currency?: StringFilter<"SettlementTransaction"> | string
    status?: EnumSettlementStatusFilter<"SettlementTransaction"> | $Enums.SettlementStatus
    fees?: DecimalFilter<"SettlementTransaction"> | Decimal | DecimalJsLike | number | string
    netPayout?: DecimalFilter<"SettlementTransaction"> | Decimal | DecimalJsLike | number | string
    settledAt?: DateTimeNullableFilter<"SettlementTransaction"> | Date | string | null
    createdAt?: DateTimeFilter<"SettlementTransaction"> | Date | string
    updatedAt?: DateTimeFilter<"SettlementTransaction"> | Date | string
    bookingId?: StringNullableFilter<"SettlementTransaction"> | string | null
  }

  export type BookingCreateWithoutTicketsInput = {
    id?: string
    reference: string
    purchaserEmail: string
    purchaserName: string
    status?: $Enums.BookingStatus
    totalAmount: Decimal | DecimalJsLike | number | string
    currency?: string
    purchasedAt?: Date | string
    movieTitle: string
    user?: UserCreateNestedOneWithoutBookingsInput
    showtime: ShowtimeCreateNestedOneWithoutBookingsInput
    auditLog?: BookingAuditCreateNestedManyWithoutBookingInput
    settlements?: SettlementTransactionCreateNestedManyWithoutBookingInput
  }

  export type BookingUncheckedCreateWithoutTicketsInput = {
    id?: string
    reference: string
    showtimeId: string
    userId?: string | null
    purchaserEmail: string
    purchaserName: string
    status?: $Enums.BookingStatus
    totalAmount: Decimal | DecimalJsLike | number | string
    currency?: string
    purchasedAt?: Date | string
    movieTitle: string
    auditLog?: BookingAuditUncheckedCreateNestedManyWithoutBookingInput
    settlements?: SettlementTransactionUncheckedCreateNestedManyWithoutBookingInput
  }

  export type BookingCreateOrConnectWithoutTicketsInput = {
    where: BookingWhereUniqueInput
    create: XOR<BookingCreateWithoutTicketsInput, BookingUncheckedCreateWithoutTicketsInput>
  }

  export type BookingUpsertWithoutTicketsInput = {
    update: XOR<BookingUpdateWithoutTicketsInput, BookingUncheckedUpdateWithoutTicketsInput>
    create: XOR<BookingCreateWithoutTicketsInput, BookingUncheckedCreateWithoutTicketsInput>
    where?: BookingWhereInput
  }

  export type BookingUpdateToOneWithWhereWithoutTicketsInput = {
    where?: BookingWhereInput
    data: XOR<BookingUpdateWithoutTicketsInput, BookingUncheckedUpdateWithoutTicketsInput>
  }

  export type BookingUpdateWithoutTicketsInput = {
    id?: StringFieldUpdateOperationsInput | string
    reference?: StringFieldUpdateOperationsInput | string
    purchaserEmail?: StringFieldUpdateOperationsInput | string
    purchaserName?: StringFieldUpdateOperationsInput | string
    status?: EnumBookingStatusFieldUpdateOperationsInput | $Enums.BookingStatus
    totalAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    purchasedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    movieTitle?: StringFieldUpdateOperationsInput | string
    user?: UserUpdateOneWithoutBookingsNestedInput
    showtime?: ShowtimeUpdateOneRequiredWithoutBookingsNestedInput
    auditLog?: BookingAuditUpdateManyWithoutBookingNestedInput
    settlements?: SettlementTransactionUpdateManyWithoutBookingNestedInput
  }

  export type BookingUncheckedUpdateWithoutTicketsInput = {
    id?: StringFieldUpdateOperationsInput | string
    reference?: StringFieldUpdateOperationsInput | string
    showtimeId?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    purchaserEmail?: StringFieldUpdateOperationsInput | string
    purchaserName?: StringFieldUpdateOperationsInput | string
    status?: EnumBookingStatusFieldUpdateOperationsInput | $Enums.BookingStatus
    totalAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    purchasedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    movieTitle?: StringFieldUpdateOperationsInput | string
    auditLog?: BookingAuditUncheckedUpdateManyWithoutBookingNestedInput
    settlements?: SettlementTransactionUncheckedUpdateManyWithoutBookingNestedInput
  }

  export type BookingCreateWithoutAuditLogInput = {
    id?: string
    reference: string
    purchaserEmail: string
    purchaserName: string
    status?: $Enums.BookingStatus
    totalAmount: Decimal | DecimalJsLike | number | string
    currency?: string
    purchasedAt?: Date | string
    movieTitle: string
    user?: UserCreateNestedOneWithoutBookingsInput
    showtime: ShowtimeCreateNestedOneWithoutBookingsInput
    tickets?: BookingTicketCreateNestedManyWithoutBookingInput
    settlements?: SettlementTransactionCreateNestedManyWithoutBookingInput
  }

  export type BookingUncheckedCreateWithoutAuditLogInput = {
    id?: string
    reference: string
    showtimeId: string
    userId?: string | null
    purchaserEmail: string
    purchaserName: string
    status?: $Enums.BookingStatus
    totalAmount: Decimal | DecimalJsLike | number | string
    currency?: string
    purchasedAt?: Date | string
    movieTitle: string
    tickets?: BookingTicketUncheckedCreateNestedManyWithoutBookingInput
    settlements?: SettlementTransactionUncheckedCreateNestedManyWithoutBookingInput
  }

  export type BookingCreateOrConnectWithoutAuditLogInput = {
    where: BookingWhereUniqueInput
    create: XOR<BookingCreateWithoutAuditLogInput, BookingUncheckedCreateWithoutAuditLogInput>
  }

  export type BookingUpsertWithoutAuditLogInput = {
    update: XOR<BookingUpdateWithoutAuditLogInput, BookingUncheckedUpdateWithoutAuditLogInput>
    create: XOR<BookingCreateWithoutAuditLogInput, BookingUncheckedCreateWithoutAuditLogInput>
    where?: BookingWhereInput
  }

  export type BookingUpdateToOneWithWhereWithoutAuditLogInput = {
    where?: BookingWhereInput
    data: XOR<BookingUpdateWithoutAuditLogInput, BookingUncheckedUpdateWithoutAuditLogInput>
  }

  export type BookingUpdateWithoutAuditLogInput = {
    id?: StringFieldUpdateOperationsInput | string
    reference?: StringFieldUpdateOperationsInput | string
    purchaserEmail?: StringFieldUpdateOperationsInput | string
    purchaserName?: StringFieldUpdateOperationsInput | string
    status?: EnumBookingStatusFieldUpdateOperationsInput | $Enums.BookingStatus
    totalAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    purchasedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    movieTitle?: StringFieldUpdateOperationsInput | string
    user?: UserUpdateOneWithoutBookingsNestedInput
    showtime?: ShowtimeUpdateOneRequiredWithoutBookingsNestedInput
    tickets?: BookingTicketUpdateManyWithoutBookingNestedInput
    settlements?: SettlementTransactionUpdateManyWithoutBookingNestedInput
  }

  export type BookingUncheckedUpdateWithoutAuditLogInput = {
    id?: StringFieldUpdateOperationsInput | string
    reference?: StringFieldUpdateOperationsInput | string
    showtimeId?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    purchaserEmail?: StringFieldUpdateOperationsInput | string
    purchaserName?: StringFieldUpdateOperationsInput | string
    status?: EnumBookingStatusFieldUpdateOperationsInput | $Enums.BookingStatus
    totalAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    purchasedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    movieTitle?: StringFieldUpdateOperationsInput | string
    tickets?: BookingTicketUncheckedUpdateManyWithoutBookingNestedInput
    settlements?: SettlementTransactionUncheckedUpdateManyWithoutBookingNestedInput
  }

  export type BookingCreateWithoutSettlementsInput = {
    id?: string
    reference: string
    purchaserEmail: string
    purchaserName: string
    status?: $Enums.BookingStatus
    totalAmount: Decimal | DecimalJsLike | number | string
    currency?: string
    purchasedAt?: Date | string
    movieTitle: string
    user?: UserCreateNestedOneWithoutBookingsInput
    showtime: ShowtimeCreateNestedOneWithoutBookingsInput
    tickets?: BookingTicketCreateNestedManyWithoutBookingInput
    auditLog?: BookingAuditCreateNestedManyWithoutBookingInput
  }

  export type BookingUncheckedCreateWithoutSettlementsInput = {
    id?: string
    reference: string
    showtimeId: string
    userId?: string | null
    purchaserEmail: string
    purchaserName: string
    status?: $Enums.BookingStatus
    totalAmount: Decimal | DecimalJsLike | number | string
    currency?: string
    purchasedAt?: Date | string
    movieTitle: string
    tickets?: BookingTicketUncheckedCreateNestedManyWithoutBookingInput
    auditLog?: BookingAuditUncheckedCreateNestedManyWithoutBookingInput
  }

  export type BookingCreateOrConnectWithoutSettlementsInput = {
    where: BookingWhereUniqueInput
    create: XOR<BookingCreateWithoutSettlementsInput, BookingUncheckedCreateWithoutSettlementsInput>
  }

  export type BookingUpsertWithoutSettlementsInput = {
    update: XOR<BookingUpdateWithoutSettlementsInput, BookingUncheckedUpdateWithoutSettlementsInput>
    create: XOR<BookingCreateWithoutSettlementsInput, BookingUncheckedCreateWithoutSettlementsInput>
    where?: BookingWhereInput
  }

  export type BookingUpdateToOneWithWhereWithoutSettlementsInput = {
    where?: BookingWhereInput
    data: XOR<BookingUpdateWithoutSettlementsInput, BookingUncheckedUpdateWithoutSettlementsInput>
  }

  export type BookingUpdateWithoutSettlementsInput = {
    id?: StringFieldUpdateOperationsInput | string
    reference?: StringFieldUpdateOperationsInput | string
    purchaserEmail?: StringFieldUpdateOperationsInput | string
    purchaserName?: StringFieldUpdateOperationsInput | string
    status?: EnumBookingStatusFieldUpdateOperationsInput | $Enums.BookingStatus
    totalAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    purchasedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    movieTitle?: StringFieldUpdateOperationsInput | string
    user?: UserUpdateOneWithoutBookingsNestedInput
    showtime?: ShowtimeUpdateOneRequiredWithoutBookingsNestedInput
    tickets?: BookingTicketUpdateManyWithoutBookingNestedInput
    auditLog?: BookingAuditUpdateManyWithoutBookingNestedInput
  }

  export type BookingUncheckedUpdateWithoutSettlementsInput = {
    id?: StringFieldUpdateOperationsInput | string
    reference?: StringFieldUpdateOperationsInput | string
    showtimeId?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    purchaserEmail?: StringFieldUpdateOperationsInput | string
    purchaserName?: StringFieldUpdateOperationsInput | string
    status?: EnumBookingStatusFieldUpdateOperationsInput | $Enums.BookingStatus
    totalAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    purchasedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    movieTitle?: StringFieldUpdateOperationsInput | string
    tickets?: BookingTicketUncheckedUpdateManyWithoutBookingNestedInput
    auditLog?: BookingAuditUncheckedUpdateManyWithoutBookingNestedInput
  }

  export type NotificationCampaignCreateWithoutSegmentInput = {
    id?: string
    name: string
    subject: string
    channels: JsonNullValueInput | InputJsonValue
    status?: $Enums.CampaignStatus
    scheduledAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    statsSent?: number
    statsOpened?: number
    statsClicked?: number
  }

  export type NotificationCampaignUncheckedCreateWithoutSegmentInput = {
    id?: string
    name: string
    subject: string
    channels: JsonNullValueInput | InputJsonValue
    status?: $Enums.CampaignStatus
    scheduledAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    statsSent?: number
    statsOpened?: number
    statsClicked?: number
  }

  export type NotificationCampaignCreateOrConnectWithoutSegmentInput = {
    where: NotificationCampaignWhereUniqueInput
    create: XOR<NotificationCampaignCreateWithoutSegmentInput, NotificationCampaignUncheckedCreateWithoutSegmentInput>
  }

  export type NotificationCampaignCreateManySegmentInputEnvelope = {
    data: NotificationCampaignCreateManySegmentInput | NotificationCampaignCreateManySegmentInput[]
    skipDuplicates?: boolean
  }

  export type NotificationCampaignUpsertWithWhereUniqueWithoutSegmentInput = {
    where: NotificationCampaignWhereUniqueInput
    update: XOR<NotificationCampaignUpdateWithoutSegmentInput, NotificationCampaignUncheckedUpdateWithoutSegmentInput>
    create: XOR<NotificationCampaignCreateWithoutSegmentInput, NotificationCampaignUncheckedCreateWithoutSegmentInput>
  }

  export type NotificationCampaignUpdateWithWhereUniqueWithoutSegmentInput = {
    where: NotificationCampaignWhereUniqueInput
    data: XOR<NotificationCampaignUpdateWithoutSegmentInput, NotificationCampaignUncheckedUpdateWithoutSegmentInput>
  }

  export type NotificationCampaignUpdateManyWithWhereWithoutSegmentInput = {
    where: NotificationCampaignScalarWhereInput
    data: XOR<NotificationCampaignUpdateManyMutationInput, NotificationCampaignUncheckedUpdateManyWithoutSegmentInput>
  }

  export type NotificationCampaignScalarWhereInput = {
    AND?: NotificationCampaignScalarWhereInput | NotificationCampaignScalarWhereInput[]
    OR?: NotificationCampaignScalarWhereInput[]
    NOT?: NotificationCampaignScalarWhereInput | NotificationCampaignScalarWhereInput[]
    id?: StringFilter<"NotificationCampaign"> | string
    name?: StringFilter<"NotificationCampaign"> | string
    subject?: StringFilter<"NotificationCampaign"> | string
    channels?: JsonFilter<"NotificationCampaign">
    status?: EnumCampaignStatusFilter<"NotificationCampaign"> | $Enums.CampaignStatus
    scheduledAt?: DateTimeNullableFilter<"NotificationCampaign"> | Date | string | null
    createdAt?: DateTimeFilter<"NotificationCampaign"> | Date | string
    updatedAt?: DateTimeFilter<"NotificationCampaign"> | Date | string
    segmentId?: StringFilter<"NotificationCampaign"> | string
    statsSent?: IntFilter<"NotificationCampaign"> | number
    statsOpened?: IntFilter<"NotificationCampaign"> | number
    statsClicked?: IntFilter<"NotificationCampaign"> | number
  }

  export type NotificationSegmentCreateWithoutCampaignsInput = {
    id?: string
    name: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type NotificationSegmentUncheckedCreateWithoutCampaignsInput = {
    id?: string
    name: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type NotificationSegmentCreateOrConnectWithoutCampaignsInput = {
    where: NotificationSegmentWhereUniqueInput
    create: XOR<NotificationSegmentCreateWithoutCampaignsInput, NotificationSegmentUncheckedCreateWithoutCampaignsInput>
  }

  export type NotificationSegmentUpsertWithoutCampaignsInput = {
    update: XOR<NotificationSegmentUpdateWithoutCampaignsInput, NotificationSegmentUncheckedUpdateWithoutCampaignsInput>
    create: XOR<NotificationSegmentCreateWithoutCampaignsInput, NotificationSegmentUncheckedCreateWithoutCampaignsInput>
    where?: NotificationSegmentWhereInput
  }

  export type NotificationSegmentUpdateToOneWithWhereWithoutCampaignsInput = {
    where?: NotificationSegmentWhereInput
    data: XOR<NotificationSegmentUpdateWithoutCampaignsInput, NotificationSegmentUncheckedUpdateWithoutCampaignsInput>
  }

  export type NotificationSegmentUpdateWithoutCampaignsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationSegmentUncheckedUpdateWithoutCampaignsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SessionCreateManyUserInput = {
    id?: string
    refreshToken: string
    expiresAt: Date | string
    createdAt?: Date | string
    revokedAt?: Date | string | null
    ipAddress?: string | null
    userAgent?: string | null
  }

  export type BookingCreateManyUserInput = {
    id?: string
    reference: string
    showtimeId: string
    purchaserEmail: string
    purchaserName: string
    status?: $Enums.BookingStatus
    totalAmount: Decimal | DecimalJsLike | number | string
    currency?: string
    purchasedAt?: Date | string
    movieTitle: string
  }

  export type PasswordResetTokenCreateManyUserInput = {
    id?: string
    otp: string
    expiresAt: Date | string
    usedAt?: Date | string | null
    createdAt?: Date | string
  }

  export type SessionUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    refreshToken?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    revokedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type SessionUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    refreshToken?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    revokedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type SessionUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    refreshToken?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    revokedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type BookingUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    reference?: StringFieldUpdateOperationsInput | string
    purchaserEmail?: StringFieldUpdateOperationsInput | string
    purchaserName?: StringFieldUpdateOperationsInput | string
    status?: EnumBookingStatusFieldUpdateOperationsInput | $Enums.BookingStatus
    totalAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    purchasedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    movieTitle?: StringFieldUpdateOperationsInput | string
    showtime?: ShowtimeUpdateOneRequiredWithoutBookingsNestedInput
    tickets?: BookingTicketUpdateManyWithoutBookingNestedInput
    auditLog?: BookingAuditUpdateManyWithoutBookingNestedInput
    settlements?: SettlementTransactionUpdateManyWithoutBookingNestedInput
  }

  export type BookingUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    reference?: StringFieldUpdateOperationsInput | string
    showtimeId?: StringFieldUpdateOperationsInput | string
    purchaserEmail?: StringFieldUpdateOperationsInput | string
    purchaserName?: StringFieldUpdateOperationsInput | string
    status?: EnumBookingStatusFieldUpdateOperationsInput | $Enums.BookingStatus
    totalAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    purchasedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    movieTitle?: StringFieldUpdateOperationsInput | string
    tickets?: BookingTicketUncheckedUpdateManyWithoutBookingNestedInput
    auditLog?: BookingAuditUncheckedUpdateManyWithoutBookingNestedInput
    settlements?: SettlementTransactionUncheckedUpdateManyWithoutBookingNestedInput
  }

  export type BookingUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    reference?: StringFieldUpdateOperationsInput | string
    showtimeId?: StringFieldUpdateOperationsInput | string
    purchaserEmail?: StringFieldUpdateOperationsInput | string
    purchaserName?: StringFieldUpdateOperationsInput | string
    status?: EnumBookingStatusFieldUpdateOperationsInput | $Enums.BookingStatus
    totalAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    purchasedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    movieTitle?: StringFieldUpdateOperationsInput | string
  }

  export type PasswordResetTokenUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    otp?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    usedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PasswordResetTokenUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    otp?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    usedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PasswordResetTokenUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    otp?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    usedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AdminUserRoleCreateManyAdminUserInput = {
    id?: number
    role: $Enums.AdminRole
  }

  export type AdminUserRoleUpdateWithoutAdminUserInput = {
    role?: EnumAdminRoleFieldUpdateOperationsInput | $Enums.AdminRole
  }

  export type AdminUserRoleUncheckedUpdateWithoutAdminUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    role?: EnumAdminRoleFieldUpdateOperationsInput | $Enums.AdminRole
  }

  export type AdminUserRoleUncheckedUpdateManyWithoutAdminUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    role?: EnumAdminRoleFieldUpdateOperationsInput | $Enums.AdminRole
  }

  export type MovieGenreCreateManyMovieInput = {
    id?: number
    name: string
  }

  export type MovieLanguageCreateManyMovieInput = {
    id?: number
    name: string
  }

  export type ShowtimeCreateManyMovieInput = {
    id?: string
    auditoriumId: string
    startsAt: Date | string
    endsAt: Date | string
    basePrice: Decimal | DecimalJsLike | number | string
    status?: $Enums.ShowtimeStatus
    seatLayoutVersion?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MovieGenreUpdateWithoutMovieInput = {
    name?: StringFieldUpdateOperationsInput | string
  }

  export type MovieGenreUncheckedUpdateWithoutMovieInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
  }

  export type MovieGenreUncheckedUpdateManyWithoutMovieInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
  }

  export type MovieLanguageUpdateWithoutMovieInput = {
    name?: StringFieldUpdateOperationsInput | string
  }

  export type MovieLanguageUncheckedUpdateWithoutMovieInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
  }

  export type MovieLanguageUncheckedUpdateManyWithoutMovieInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
  }

  export type ShowtimeUpdateWithoutMovieInput = {
    id?: StringFieldUpdateOperationsInput | string
    startsAt?: DateTimeFieldUpdateOperationsInput | Date | string
    endsAt?: DateTimeFieldUpdateOperationsInput | Date | string
    basePrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: EnumShowtimeStatusFieldUpdateOperationsInput | $Enums.ShowtimeStatus
    seatLayoutVersion?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    auditorium?: AuditoriumUpdateOneRequiredWithoutShowtimesNestedInput
    pricingTiers?: ShowtimePricingTierUpdateManyWithoutShowtimeNestedInput
    bookings?: BookingUpdateManyWithoutShowtimeNestedInput
  }

  export type ShowtimeUncheckedUpdateWithoutMovieInput = {
    id?: StringFieldUpdateOperationsInput | string
    auditoriumId?: StringFieldUpdateOperationsInput | string
    startsAt?: DateTimeFieldUpdateOperationsInput | Date | string
    endsAt?: DateTimeFieldUpdateOperationsInput | Date | string
    basePrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: EnumShowtimeStatusFieldUpdateOperationsInput | $Enums.ShowtimeStatus
    seatLayoutVersion?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    pricingTiers?: ShowtimePricingTierUncheckedUpdateManyWithoutShowtimeNestedInput
    bookings?: BookingUncheckedUpdateManyWithoutShowtimeNestedInput
  }

  export type ShowtimeUncheckedUpdateManyWithoutMovieInput = {
    id?: StringFieldUpdateOperationsInput | string
    auditoriumId?: StringFieldUpdateOperationsInput | string
    startsAt?: DateTimeFieldUpdateOperationsInput | Date | string
    endsAt?: DateTimeFieldUpdateOperationsInput | Date | string
    basePrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: EnumShowtimeStatusFieldUpdateOperationsInput | $Enums.ShowtimeStatus
    seatLayoutVersion?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ShowtimeCreateManyAuditoriumInput = {
    id?: string
    movieId: string
    startsAt: Date | string
    endsAt: Date | string
    basePrice: Decimal | DecimalJsLike | number | string
    status?: $Enums.ShowtimeStatus
    seatLayoutVersion?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ShowtimeUpdateWithoutAuditoriumInput = {
    id?: StringFieldUpdateOperationsInput | string
    startsAt?: DateTimeFieldUpdateOperationsInput | Date | string
    endsAt?: DateTimeFieldUpdateOperationsInput | Date | string
    basePrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: EnumShowtimeStatusFieldUpdateOperationsInput | $Enums.ShowtimeStatus
    seatLayoutVersion?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    movie?: MovieUpdateOneRequiredWithoutShowtimesNestedInput
    pricingTiers?: ShowtimePricingTierUpdateManyWithoutShowtimeNestedInput
    bookings?: BookingUpdateManyWithoutShowtimeNestedInput
  }

  export type ShowtimeUncheckedUpdateWithoutAuditoriumInput = {
    id?: StringFieldUpdateOperationsInput | string
    movieId?: StringFieldUpdateOperationsInput | string
    startsAt?: DateTimeFieldUpdateOperationsInput | Date | string
    endsAt?: DateTimeFieldUpdateOperationsInput | Date | string
    basePrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: EnumShowtimeStatusFieldUpdateOperationsInput | $Enums.ShowtimeStatus
    seatLayoutVersion?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    pricingTiers?: ShowtimePricingTierUncheckedUpdateManyWithoutShowtimeNestedInput
    bookings?: BookingUncheckedUpdateManyWithoutShowtimeNestedInput
  }

  export type ShowtimeUncheckedUpdateManyWithoutAuditoriumInput = {
    id?: StringFieldUpdateOperationsInput | string
    movieId?: StringFieldUpdateOperationsInput | string
    startsAt?: DateTimeFieldUpdateOperationsInput | Date | string
    endsAt?: DateTimeFieldUpdateOperationsInput | Date | string
    basePrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: EnumShowtimeStatusFieldUpdateOperationsInput | $Enums.ShowtimeStatus
    seatLayoutVersion?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ShowtimePricingTierCreateManyShowtimeInput = {
    id?: string
    label: string
    price: Decimal | DecimalJsLike | number | string
    seatTypes: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type BookingCreateManyShowtimeInput = {
    id?: string
    reference: string
    userId?: string | null
    purchaserEmail: string
    purchaserName: string
    status?: $Enums.BookingStatus
    totalAmount: Decimal | DecimalJsLike | number | string
    currency?: string
    purchasedAt?: Date | string
    movieTitle: string
  }

  export type ShowtimePricingTierUpdateWithoutShowtimeInput = {
    id?: StringFieldUpdateOperationsInput | string
    label?: StringFieldUpdateOperationsInput | string
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    seatTypes?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ShowtimePricingTierUncheckedUpdateWithoutShowtimeInput = {
    id?: StringFieldUpdateOperationsInput | string
    label?: StringFieldUpdateOperationsInput | string
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    seatTypes?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ShowtimePricingTierUncheckedUpdateManyWithoutShowtimeInput = {
    id?: StringFieldUpdateOperationsInput | string
    label?: StringFieldUpdateOperationsInput | string
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    seatTypes?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BookingUpdateWithoutShowtimeInput = {
    id?: StringFieldUpdateOperationsInput | string
    reference?: StringFieldUpdateOperationsInput | string
    purchaserEmail?: StringFieldUpdateOperationsInput | string
    purchaserName?: StringFieldUpdateOperationsInput | string
    status?: EnumBookingStatusFieldUpdateOperationsInput | $Enums.BookingStatus
    totalAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    purchasedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    movieTitle?: StringFieldUpdateOperationsInput | string
    user?: UserUpdateOneWithoutBookingsNestedInput
    tickets?: BookingTicketUpdateManyWithoutBookingNestedInput
    auditLog?: BookingAuditUpdateManyWithoutBookingNestedInput
    settlements?: SettlementTransactionUpdateManyWithoutBookingNestedInput
  }

  export type BookingUncheckedUpdateWithoutShowtimeInput = {
    id?: StringFieldUpdateOperationsInput | string
    reference?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    purchaserEmail?: StringFieldUpdateOperationsInput | string
    purchaserName?: StringFieldUpdateOperationsInput | string
    status?: EnumBookingStatusFieldUpdateOperationsInput | $Enums.BookingStatus
    totalAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    purchasedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    movieTitle?: StringFieldUpdateOperationsInput | string
    tickets?: BookingTicketUncheckedUpdateManyWithoutBookingNestedInput
    auditLog?: BookingAuditUncheckedUpdateManyWithoutBookingNestedInput
    settlements?: SettlementTransactionUncheckedUpdateManyWithoutBookingNestedInput
  }

  export type BookingUncheckedUpdateManyWithoutShowtimeInput = {
    id?: StringFieldUpdateOperationsInput | string
    reference?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    purchaserEmail?: StringFieldUpdateOperationsInput | string
    purchaserName?: StringFieldUpdateOperationsInput | string
    status?: EnumBookingStatusFieldUpdateOperationsInput | $Enums.BookingStatus
    totalAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    purchasedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    movieTitle?: StringFieldUpdateOperationsInput | string
  }

  export type BookingTicketCreateManyBookingInput = {
    id?: string
    seatId: string
    seatLabel: string
    price: Decimal | DecimalJsLike | number | string
    tierLabel?: string | null
    tierId?: string | null
  }

  export type BookingAuditCreateManyBookingInput = {
    id?: string
    type: string
    message: string
    actor: string
    createdAt?: Date | string
  }

  export type SettlementTransactionCreateManyBookingInput = {
    id?: string
    gateway: string
    transactionId: string
    amount: Decimal | DecimalJsLike | number | string
    currency?: string
    status?: $Enums.SettlementStatus
    fees: Decimal | DecimalJsLike | number | string
    netPayout: Decimal | DecimalJsLike | number | string
    settledAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BookingTicketUpdateWithoutBookingInput = {
    id?: StringFieldUpdateOperationsInput | string
    seatId?: StringFieldUpdateOperationsInput | string
    seatLabel?: StringFieldUpdateOperationsInput | string
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    tierLabel?: NullableStringFieldUpdateOperationsInput | string | null
    tierId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type BookingTicketUncheckedUpdateWithoutBookingInput = {
    id?: StringFieldUpdateOperationsInput | string
    seatId?: StringFieldUpdateOperationsInput | string
    seatLabel?: StringFieldUpdateOperationsInput | string
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    tierLabel?: NullableStringFieldUpdateOperationsInput | string | null
    tierId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type BookingTicketUncheckedUpdateManyWithoutBookingInput = {
    id?: StringFieldUpdateOperationsInput | string
    seatId?: StringFieldUpdateOperationsInput | string
    seatLabel?: StringFieldUpdateOperationsInput | string
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    tierLabel?: NullableStringFieldUpdateOperationsInput | string | null
    tierId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type BookingAuditUpdateWithoutBookingInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    actor?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BookingAuditUncheckedUpdateWithoutBookingInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    actor?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BookingAuditUncheckedUpdateManyWithoutBookingInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    actor?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SettlementTransactionUpdateWithoutBookingInput = {
    id?: StringFieldUpdateOperationsInput | string
    gateway?: StringFieldUpdateOperationsInput | string
    transactionId?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    status?: EnumSettlementStatusFieldUpdateOperationsInput | $Enums.SettlementStatus
    fees?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    netPayout?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    settledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SettlementTransactionUncheckedUpdateWithoutBookingInput = {
    id?: StringFieldUpdateOperationsInput | string
    gateway?: StringFieldUpdateOperationsInput | string
    transactionId?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    status?: EnumSettlementStatusFieldUpdateOperationsInput | $Enums.SettlementStatus
    fees?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    netPayout?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    settledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SettlementTransactionUncheckedUpdateManyWithoutBookingInput = {
    id?: StringFieldUpdateOperationsInput | string
    gateway?: StringFieldUpdateOperationsInput | string
    transactionId?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    status?: EnumSettlementStatusFieldUpdateOperationsInput | $Enums.SettlementStatus
    fees?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    netPayout?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    settledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationCampaignCreateManySegmentInput = {
    id?: string
    name: string
    subject: string
    channels: JsonNullValueInput | InputJsonValue
    status?: $Enums.CampaignStatus
    scheduledAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    statsSent?: number
    statsOpened?: number
    statsClicked?: number
  }

  export type NotificationCampaignUpdateWithoutSegmentInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    subject?: StringFieldUpdateOperationsInput | string
    channels?: JsonNullValueInput | InputJsonValue
    status?: EnumCampaignStatusFieldUpdateOperationsInput | $Enums.CampaignStatus
    scheduledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    statsSent?: IntFieldUpdateOperationsInput | number
    statsOpened?: IntFieldUpdateOperationsInput | number
    statsClicked?: IntFieldUpdateOperationsInput | number
  }

  export type NotificationCampaignUncheckedUpdateWithoutSegmentInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    subject?: StringFieldUpdateOperationsInput | string
    channels?: JsonNullValueInput | InputJsonValue
    status?: EnumCampaignStatusFieldUpdateOperationsInput | $Enums.CampaignStatus
    scheduledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    statsSent?: IntFieldUpdateOperationsInput | number
    statsOpened?: IntFieldUpdateOperationsInput | number
    statsClicked?: IntFieldUpdateOperationsInput | number
  }

  export type NotificationCampaignUncheckedUpdateManyWithoutSegmentInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    subject?: StringFieldUpdateOperationsInput | string
    channels?: JsonNullValueInput | InputJsonValue
    status?: EnumCampaignStatusFieldUpdateOperationsInput | $Enums.CampaignStatus
    scheduledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    statsSent?: IntFieldUpdateOperationsInput | number
    statsOpened?: IntFieldUpdateOperationsInput | number
    statsClicked?: IntFieldUpdateOperationsInput | number
  }



  /**
   * Aliases for legacy arg types
   */
    /**
     * @deprecated Use UserCountOutputTypeDefaultArgs instead
     */
    export type UserCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = UserCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use AdminUserCountOutputTypeDefaultArgs instead
     */
    export type AdminUserCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = AdminUserCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use MovieCountOutputTypeDefaultArgs instead
     */
    export type MovieCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = MovieCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use AuditoriumCountOutputTypeDefaultArgs instead
     */
    export type AuditoriumCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = AuditoriumCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ShowtimeCountOutputTypeDefaultArgs instead
     */
    export type ShowtimeCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ShowtimeCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use BookingCountOutputTypeDefaultArgs instead
     */
    export type BookingCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = BookingCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use NotificationSegmentCountOutputTypeDefaultArgs instead
     */
    export type NotificationSegmentCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = NotificationSegmentCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use UserDefaultArgs instead
     */
    export type UserArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = UserDefaultArgs<ExtArgs>
    /**
     * @deprecated Use AdminUserDefaultArgs instead
     */
    export type AdminUserArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = AdminUserDefaultArgs<ExtArgs>
    /**
     * @deprecated Use AdminUserRoleDefaultArgs instead
     */
    export type AdminUserRoleArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = AdminUserRoleDefaultArgs<ExtArgs>
    /**
     * @deprecated Use SessionDefaultArgs instead
     */
    export type SessionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = SessionDefaultArgs<ExtArgs>
    /**
     * @deprecated Use PasswordResetTokenDefaultArgs instead
     */
    export type PasswordResetTokenArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = PasswordResetTokenDefaultArgs<ExtArgs>
    /**
     * @deprecated Use MovieDefaultArgs instead
     */
    export type MovieArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = MovieDefaultArgs<ExtArgs>
    /**
     * @deprecated Use MovieGenreDefaultArgs instead
     */
    export type MovieGenreArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = MovieGenreDefaultArgs<ExtArgs>
    /**
     * @deprecated Use MovieLanguageDefaultArgs instead
     */
    export type MovieLanguageArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = MovieLanguageDefaultArgs<ExtArgs>
    /**
     * @deprecated Use AuditoriumDefaultArgs instead
     */
    export type AuditoriumArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = AuditoriumDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ShowtimeDefaultArgs instead
     */
    export type ShowtimeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ShowtimeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ShowtimePricingTierDefaultArgs instead
     */
    export type ShowtimePricingTierArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ShowtimePricingTierDefaultArgs<ExtArgs>
    /**
     * @deprecated Use BookingDefaultArgs instead
     */
    export type BookingArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = BookingDefaultArgs<ExtArgs>
    /**
     * @deprecated Use BookingTicketDefaultArgs instead
     */
    export type BookingTicketArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = BookingTicketDefaultArgs<ExtArgs>
    /**
     * @deprecated Use BookingAuditDefaultArgs instead
     */
    export type BookingAuditArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = BookingAuditDefaultArgs<ExtArgs>
    /**
     * @deprecated Use SettlementTransactionDefaultArgs instead
     */
    export type SettlementTransactionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = SettlementTransactionDefaultArgs<ExtArgs>
    /**
     * @deprecated Use NotificationSegmentDefaultArgs instead
     */
    export type NotificationSegmentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = NotificationSegmentDefaultArgs<ExtArgs>
    /**
     * @deprecated Use NotificationCampaignDefaultArgs instead
     */
    export type NotificationCampaignArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = NotificationCampaignDefaultArgs<ExtArgs>
    /**
     * @deprecated Use PlatformSettingsDefaultArgs instead
     */
    export type PlatformSettingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = PlatformSettingsDefaultArgs<ExtArgs>
    /**
     * @deprecated Use PaymentAuditDefaultArgs instead
     */
    export type PaymentAuditArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = PaymentAuditDefaultArgs<ExtArgs>

  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}